
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final\LE_Final.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
../../../../crt1/gcrt1.S:61
   0:	55 c0       	rjmp	.+170    	; 0xac <__ctors_end>
   2:	00 00       	nop
../../../../crt1/gcrt1.S:67
   4:	79 c0       	rjmp	.+242    	; 0xf8 <__bad_interrupt>
   6:	00 00       	nop
../../../../crt1/gcrt1.S:68
   8:	77 c0       	rjmp	.+238    	; 0xf8 <__bad_interrupt>
   a:	00 00       	nop
../../../../crt1/gcrt1.S:69
   c:	75 c0       	rjmp	.+234    	; 0xf8 <__bad_interrupt>
   e:	00 00       	nop
../../../../crt1/gcrt1.S:70
  10:	73 c0       	rjmp	.+230    	; 0xf8 <__bad_interrupt>
  12:	00 00       	nop
../../../../crt1/gcrt1.S:71
  14:	71 c0       	rjmp	.+226    	; 0xf8 <__bad_interrupt>
  16:	00 00       	nop
../../../../crt1/gcrt1.S:72
  18:	6f c0       	rjmp	.+222    	; 0xf8 <__bad_interrupt>
  1a:	00 00       	nop
../../../../crt1/gcrt1.S:73
  1c:	6d c0       	rjmp	.+218    	; 0xf8 <__bad_interrupt>
  1e:	00 00       	nop
../../../../crt1/gcrt1.S:74
  20:	6b c0       	rjmp	.+214    	; 0xf8 <__bad_interrupt>
  22:	00 00       	nop
../../../../crt1/gcrt1.S:75
  24:	69 c0       	rjmp	.+210    	; 0xf8 <__bad_interrupt>
  26:	00 00       	nop
../../../../crt1/gcrt1.S:76
  28:	67 c0       	rjmp	.+206    	; 0xf8 <__bad_interrupt>
  2a:	00 00       	nop
../../../../crt1/gcrt1.S:77
  2c:	65 c0       	rjmp	.+202    	; 0xf8 <__bad_interrupt>
  2e:	00 00       	nop
../../../../crt1/gcrt1.S:78
  30:	63 c0       	rjmp	.+198    	; 0xf8 <__bad_interrupt>
  32:	00 00       	nop
../../../../crt1/gcrt1.S:79
  34:	61 c0       	rjmp	.+194    	; 0xf8 <__bad_interrupt>
  36:	00 00       	nop
../../../../crt1/gcrt1.S:80
  38:	5f c0       	rjmp	.+190    	; 0xf8 <__bad_interrupt>
  3a:	00 00       	nop
../../../../crt1/gcrt1.S:81
  3c:	10 c2       	rjmp	.+1056   	; 0x45e <__vector_15>
  3e:	00 00       	nop
../../../../crt1/gcrt1.S:82
  40:	5b c0       	rjmp	.+182    	; 0xf8 <__bad_interrupt>
  42:	00 00       	nop
../../../../crt1/gcrt1.S:83
  44:	59 c0       	rjmp	.+178    	; 0xf8 <__bad_interrupt>
  46:	00 00       	nop
../../../../crt1/gcrt1.S:84
  48:	57 c0       	rjmp	.+174    	; 0xf8 <__bad_interrupt>
  4a:	00 00       	nop
../../../../crt1/gcrt1.S:85
  4c:	55 c0       	rjmp	.+170    	; 0xf8 <__bad_interrupt>
  4e:	00 00       	nop
../../../../crt1/gcrt1.S:86
  50:	53 c0       	rjmp	.+166    	; 0xf8 <__bad_interrupt>
  52:	00 00       	nop
../../../../crt1/gcrt1.S:87
  54:	51 c0       	rjmp	.+162    	; 0xf8 <__bad_interrupt>
  56:	00 00       	nop
../../../../crt1/gcrt1.S:88
  58:	4f c0       	rjmp	.+158    	; 0xf8 <__bad_interrupt>
  5a:	00 00       	nop
../../../../crt1/gcrt1.S:89
  5c:	4d c0       	rjmp	.+154    	; 0xf8 <__bad_interrupt>
  5e:	00 00       	nop
../../../../crt1/gcrt1.S:90
  60:	2d c2       	rjmp	.+1114   	; 0x4bc <__vector_24>
  62:	00 00       	nop
../../../../crt1/gcrt1.S:91
  64:	49 c0       	rjmp	.+146    	; 0xf8 <__bad_interrupt>
  66:	00 00       	nop
../../../../crt1/gcrt1.S:92
  68:	47 c0       	rjmp	.+142    	; 0xf8 <__bad_interrupt>
  6a:	00 00       	nop
../../../../crt1/gcrt1.S:93
  6c:	45 c0       	rjmp	.+138    	; 0xf8 <__bad_interrupt>
  6e:	00 00       	nop
../../../../crt1/gcrt1.S:94
  70:	43 c0       	rjmp	.+134    	; 0xf8 <__bad_interrupt>
  72:	00 00       	nop
../../../../crt1/gcrt1.S:95
  74:	41 c0       	rjmp	.+130    	; 0xf8 <__bad_interrupt>
  76:	00 00       	nop
../../../../crt1/gcrt1.S:96
  78:	3f c0       	rjmp	.+126    	; 0xf8 <__bad_interrupt>
  7a:	00 00       	nop
  7c:	08 4a       	sbci	r16, 0xA8	; 168
  7e:	d7 3b       	cpi	r29, 0xB7	; 183
  80:	3b ce       	rjmp	.-906    	; 0xfffffcf8 <__eeprom_end+0xff7efcf8>
  82:	01 6e       	ori	r16, 0xE1	; 225
  84:	84 bc       	out	0x24, r8	; 36
  86:	bf fd       	.word	0xfdbf	; ????
  88:	c1 2f       	mov	r28, r17
  8a:	3d 6c       	ori	r19, 0xCD	; 205
  8c:	74 31       	cpi	r23, 0x14	; 20
  8e:	9a bd       	out	0x2a, r25	; 42
  90:	56 83       	std	Z+6, r21	; 0x06
  92:	3d da       	rcall	.-2950   	; 0xfffff50e <__eeprom_end+0xff7ef50e>
  94:	3d 00       	.word	0x003d	; ????
  96:	c7 7f       	andi	r28, 0xF7	; 247
  98:	11 be       	out	0x31, r1	; 49
  9a:	d9 e4       	ldi	r29, 0x49	; 73
  9c:	bb 4c       	sbci	r27, 0xCB	; 203
  9e:	3e 91       	ld	r19, -X
  a0:	6b aa       	std	Y+51, r6	; 0x33
  a2:	aa be       	out	0x3a, r10	; 58
  a4:	00 00       	nop
  a6:	00 80       	ld	r0, Z
  a8:	3f 00       	.word	0x003f	; ????

000000aa <__ctors_start>:
__trampolines_start():
  aa:	7b 04       	cpc	r7, r11

000000ac <__ctors_end>:
__dtors_end():
../../../../crt1/gcrt1.S:230
  ac:	11 24       	eor	r1, r1
../../../../crt1/gcrt1.S:231
  ae:	1f be       	out	0x3f, r1	; 63
../../../../crt1/gcrt1.S:232
  b0:	cf ef       	ldi	r28, 0xFF	; 255
../../../../crt1/gcrt1.S:234
  b2:	cd bf       	out	0x3d, r28	; 61
../../../../crt1/gcrt1.S:236
  b4:	df e3       	ldi	r29, 0x3F	; 63
../../../../crt1/gcrt1.S:237
  b6:	de bf       	out	0x3e, r29	; 62

000000b8 <_initThreeStuff()>:
_Z15_initThreeStuffv():
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/main.cpp:104

  /* Minimum: Reset if we wound up here through malfunction - this relies on user clearing the  *
   * register on startup, which is rarely done in Arduino land.                                 */
  void __attribute__((weak)) init_reset_flags() ;
  void __attribute__((weak)) init_reset_flags() {
    uint8_t flags = RSTCTRL.RSTFR;
  b8:	80 91 40 00 	lds	r24, 0x0040	; 0x800040 <digital_pin_to_bit_mask+0x7f71c8>
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/main.cpp:105
    RSTCTRL.RSTFR = flags;
  bc:	80 93 40 00 	sts	0x0040, r24	; 0x800040 <digital_pin_to_bit_mask+0x7f71c8>
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/main.cpp:106
    if (flags == 0) {
  c0:	81 11       	cpse	r24, r1
  c2:	05 c0       	rjmp	.+10     	; 0xce <_initThreeStuff()+0x16>
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/main.cpp:107
      _PROTECTED_WRITE(RSTCTRL.SWRR, 1);
  c4:	98 ed       	ldi	r25, 0xD8	; 216
  c6:	21 e0       	ldi	r18, 0x01	; 1
  c8:	94 bf       	out	0x34, r25	; 52
  ca:	20 93 41 00 	sts	0x0041, r18	; 0x800041 <digital_pin_to_bit_mask+0x7f71c9>
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/main.cpp:109
    }
    GPIOR0 = flags;
  ce:	8c bb       	out	0x1c, r24	; 28

000000d0 <__do_clear_bss>:
__do_clear_bss():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
  d0:	28 e3       	ldi	r18, 0x38	; 56
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
  d2:	a0 e0       	ldi	r26, 0x00	; 0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
  d4:	b8 e3       	ldi	r27, 0x38	; 56
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
  d6:	01 c0       	rjmp	.+2      	; 0xda <.do_clear_bss_start>

000000d8 <.do_clear_bss_loop>:
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
  d8:	1d 92       	st	X+, r1

000000da <.do_clear_bss_start>:
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
  da:	ac 39       	cpi	r26, 0x9C	; 156
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
  dc:	b2 07       	cpc	r27, r18
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
  de:	e1 f7       	brne	.-8      	; 0xd8 <.do_clear_bss_loop>

000000e0 <__do_global_ctors>:
__do_global_ctors():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2466
  e0:	10 e0       	ldi	r17, 0x00	; 0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2467
  e2:	c6 e5       	ldi	r28, 0x56	; 86
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2468
  e4:	d0 e0       	ldi	r29, 0x00	; 0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2472
  e6:	03 c0       	rjmp	.+6      	; 0xee <__do_global_ctors+0xe>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2474
  e8:	21 97       	sbiw	r28, 0x01	; 1
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2480
  ea:	fe 01       	movw	r30, r28
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2481
  ec:	99 d6       	rcall	.+3378   	; 0xe20 <__tablejump2__>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2483
  ee:	c5 35       	cpi	r28, 0x55	; 85
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2484
  f0:	d1 07       	cpc	r29, r17
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2489
  f2:	d1 f7       	brne	.-12     	; 0xe8 <__do_global_ctors+0x8>
../../../../crt1/gcrt1.S:314
  f4:	87 d2       	rcall	.+1294   	; 0x604 <main>
../../../../crt1/gcrt1.S:315
  f6:	9a c6       	rjmp	.+3380   	; 0xe2c <_exit>

000000f8 <__bad_interrupt>:
__vector_22():
  f8:	83 cf       	rjmp	.-250    	; 0x0 <__vectors>

000000fa <sortArray(int*, int) [clone .constprop.5]>:
_Z9sortArrayPii.constprop.5():
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:231
      set_RGB(c);
    }
  }
}

void sortArray(int arr[], int size) {
  fa:	29 e0       	ldi	r18, 0x09	; 9
  fc:	30 e0       	ldi	r19, 0x00	; 0
  fe:	fc 01       	movw	r30, r24
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:233
  for (int i = 0; i < size - 1; i++) {
    for (int j = 0; j < size - i - 1; j++) {
 100:	50 e0       	ldi	r21, 0x00	; 0
 102:	40 e0       	ldi	r20, 0x00	; 0
 104:	42 17       	cp	r20, r18
 106:	53 07       	cpc	r21, r19
 108:	7c f4       	brge	.+30     	; 0x128 <__EEPROM_REGION_LENGTH__+0x28>
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:234
      if (arr[j] > arr[j + 1]) {
 10a:	60 81       	ld	r22, Z
 10c:	71 81       	ldd	r23, Z+1	; 0x01
 10e:	a2 81       	ldd	r26, Z+2	; 0x02
 110:	b3 81       	ldd	r27, Z+3	; 0x03
 112:	a6 17       	cp	r26, r22
 114:	b7 07       	cpc	r27, r23
 116:	24 f4       	brge	.+8      	; 0x120 <__EEPROM_REGION_LENGTH__+0x20>
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:236
        int temp = arr[j];
        arr[j] = arr[j + 1];
 118:	a0 83       	st	Z, r26
 11a:	b1 83       	std	Z+1, r27	; 0x01
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:237
        arr[j + 1] = temp;
 11c:	62 83       	std	Z+2, r22	; 0x02
 11e:	73 83       	std	Z+3, r23	; 0x03
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:233
  }
}

void sortArray(int arr[], int size) {
  for (int i = 0; i < size - 1; i++) {
    for (int j = 0; j < size - i - 1; j++) {
 120:	4f 5f       	subi	r20, 0xFF	; 255
 122:	5f 4f       	sbci	r21, 0xFF	; 255
 124:	32 96       	adiw	r30, 0x02	; 2
 126:	ee cf       	rjmp	.-36     	; 0x104 <__EEPROM_REGION_LENGTH__+0x4>
 128:	21 50       	subi	r18, 0x01	; 1
 12a:	31 09       	sbc	r19, r1
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:232
    }
  }
}

void sortArray(int arr[], int size) {
  for (int i = 0; i < size - 1; i++) {
 12c:	41 f7       	brne	.-48     	; 0xfe <sortArray(int*, int) [clone .constprop.5]+0x4>
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:241
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
      }
    }
  }
}
 12e:	08 95       	ret

00000130 <TwoWire::flush()>:
_ZN7TwoWire5flushEv():
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:139
    _data->_module->SCTRLA  = 0x00;
    _data->_module->MCTRLA  = temp_MCTRLA;
    _data->_module->MSTATUS = 0x01;  // force TWI state machine into idle state
    _data->_module->SCTRLA  = temp_SCTRLA;
  #else
  _data->_module->MCTRLB |= TWI_FLUSH_bm;
 130:	dc 01       	movw	r26, r24
 132:	18 96       	adiw	r26, 0x08	; 8
 134:	ed 91       	ld	r30, X+
 136:	fc 91       	ld	r31, X
 138:	84 81       	ldd	r24, Z+4	; 0x04
 13a:	88 60       	ori	r24, 0x08	; 8
 13c:	84 83       	std	Z+4, r24	; 0x04
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:748
 *@return     void
 */
void TwoWire::flush(void) {
  /* Turn off and on TWI module */
  TWI_Flush(&vars);
}
 13e:	08 95       	ret

00000140 <TwoWire::peek()>:
_ZN7TwoWire4peekEv():
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:726
      rxTail   = &(vars._bytesReadWritten);
      rxBuffer =   vars._trBuffer;
    #else                                        // Separate tx/rx Buffers
      rxHead   = &(vars._bytesToRead);
      rxTail   = &(vars._bytesRead);
      rxBuffer =   vars._rxBuffer;
 140:	9c 01       	movw	r18, r24
 142:	2b 5c       	subi	r18, 0xCB	; 203
 144:	3f 4f       	sbci	r19, 0xFF	; 255
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:730
    #endif
  }

  if ((*rxTail) < (*rxHead)) {   // if there are bytes to read
 146:	dc 01       	movw	r26, r24
 148:	1f 96       	adiw	r26, 0x0f	; 15
 14a:	ec 91       	ld	r30, X
 14c:	1f 97       	sbiw	r26, 0x0f	; 15
 14e:	1e 96       	adiw	r26, 0x0e	; 14
 150:	8c 91       	ld	r24, X
 152:	e8 17       	cp	r30, r24
 154:	30 f4       	brcc	.+12     	; 0x162 <TwoWire::peek()+0x22>
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:731
    return rxBuffer[(*rxTail)];
 156:	e2 0f       	add	r30, r18
 158:	f3 2f       	mov	r31, r19
 15a:	f1 1d       	adc	r31, r1
 15c:	80 81       	ld	r24, Z
 15e:	90 e0       	ldi	r25, 0x00	; 0
 160:	08 95       	ret
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:733
  } else {      // No bytes to read
    return -1;
 162:	8f ef       	ldi	r24, 0xFF	; 255
 164:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:735
  }
}
 166:	08 95       	ret

00000168 <TwoWire::read()>:
_ZN7TwoWire4readEv():
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:635
 *@param      void
 *
 *@return     int
 *@retval     byte in the buffer or -1 if buffer is empty
 */
int TwoWire::read(void) {
 168:	fc 01       	movw	r30, r24
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:653
      rxTail   = &(vars._bytesReadWritten);
      rxBuffer =   vars._trBuffer;
    #else                                        // Separate tx/rx Buffers
      rxHead   = &(vars._bytesToRead);
      rxTail   = &(vars._bytesRead);
      rxBuffer =   vars._rxBuffer;
 16a:	dc 01       	movw	r26, r24
 16c:	d5 96       	adiw	r26, 0x35	; 53
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:658
    #endif
  }


  if ((*rxTail) < (*rxHead)) {   // if there are bytes to read
 16e:	97 85       	ldd	r25, Z+15	; 0x0f
 170:	86 85       	ldd	r24, Z+14	; 0x0e
 172:	98 17       	cp	r25, r24
 174:	40 f4       	brcc	.+16     	; 0x186 <TwoWire::read()+0x1e>
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:659
    uint8_t c = rxBuffer[(*rxTail)];
 176:	a9 0f       	add	r26, r25
 178:	b1 1d       	adc	r27, r1
 17a:	2c 91       	ld	r18, X
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:660
    (*rxTail)++;
 17c:	9f 5f       	subi	r25, 0xFF	; 255
 17e:	97 87       	std	Z+15, r25	; 0x0f
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:661
    return c;
 180:	82 2f       	mov	r24, r18
 182:	90 e0       	ldi	r25, 0x00	; 0
 184:	08 95       	ret
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:663
  } else {                      // No bytes to read. At this point, rxTail moved up to
    return -1;                  // rxHead. To reset both to 0, a MasterRead or AddrWrite has to be called
 186:	8f ef       	ldi	r24, 0xFF	; 255
 188:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:665
  }
}
 18a:	08 95       	ret

0000018c <TwoWire::available()>:
_ZN7TwoWire9availableEv():
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:603
 *@param      void
 *
 *@return     int
 *@retval     amount of bytes available to read from the host buffer
 */
int TwoWire::available(void) {
 18c:	fc 01       	movw	r30, r24
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:614
  #endif
  {
    #if defined(TWI_MERGE_BUFFERS)                // Same Buffers for tx/rx
      rxHead  = vars._bytesToReadWrite - vars._bytesReadWritten;
    #else                                         // Separate tx/rx Buffers
      rxHead  = vars._bytesToRead - vars._bytesRead;
 18e:	86 85       	ldd	r24, Z+14	; 0x0e
 190:	97 85       	ldd	r25, Z+15	; 0x0f
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:618
    #endif
  }
  return rxHead;
}
 192:	89 1b       	sub	r24, r25
 194:	99 0b       	sbc	r25, r25
 196:	08 95       	ret

00000198 <TwoWire::write(unsigned char)>:
_ZN7TwoWire5writeEh():
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:536
 *
 *
 *@return     uint8_t
 *@retval     1 if successful, 0 if the buffer is full
 */
size_t TwoWire::write(uint8_t data) {
 198:	fc 01       	movw	r30, r24
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:557
    #endif
  }

  /* Put byte in txBuffer */

  if ((*txHead) < BUFFER_LENGTH) {      // while buffer not full, write to it
 19a:	a5 85       	ldd	r26, Z+13	; 0x0d
 19c:	a0 32       	cpi	r26, 0x20	; 32
 19e:	58 f4       	brcc	.+22     	; 0x1b6 <TwoWire::write(unsigned char)+0x1e>
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:558
    txBuffer[(*txHead)] = data;             // Load data into the buffer
 1a0:	a8 0f       	add	r26, r24
 1a2:	b9 2f       	mov	r27, r25
 1a4:	b1 1d       	adc	r27, r1
 1a6:	55 96       	adiw	r26, 0x15	; 21
 1a8:	6c 93       	st	X, r22
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:559
    (*txHead)++;                            // advancing the head
 1aa:	85 85       	ldd	r24, Z+13	; 0x0d
 1ac:	8f 5f       	subi	r24, 0xFF	; 255
 1ae:	85 87       	std	Z+13, r24	; 0x0d
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:560
    return 1;
 1b0:	81 e0       	ldi	r24, 0x01	; 1
 1b2:	90 e0       	ldi	r25, 0x00	; 0
 1b4:	08 95       	ret
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:562
  } else {
    return 0;
 1b6:	90 e0       	ldi	r25, 0x00	; 0
 1b8:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:564
  }
}
 1ba:	08 95       	ret

000001bc <TwoWire::write(unsigned char const*, unsigned int)>:
_ZN7TwoWire5writeEPKhj():
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:579
 *
 *
 *@return     uint8_t
 *@retval     amount of bytes copied
 */
size_t TwoWire::write(const uint8_t *data, size_t quantity) {
 1bc:	bf 92       	push	r11
 1be:	cf 92       	push	r12
 1c0:	df 92       	push	r13
 1c2:	ef 92       	push	r14
 1c4:	ff 92       	push	r15
 1c6:	0f 93       	push	r16
 1c8:	1f 93       	push	r17
 1ca:	cf 93       	push	r28
 1cc:	df 93       	push	r29
 1ce:	7c 01       	movw	r14, r24
 1d0:	6a 01       	movw	r12, r20
 1d2:	b6 2e       	mov	r11, r22
 1d4:	eb 01       	movw	r28, r22
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:581
  twi_buffer_index_t i = 0;
  for (; i < quantity; i++) {
 1d6:	0c 2f       	mov	r16, r28
 1d8:	0b 19       	sub	r16, r11
 1da:	10 e0       	ldi	r17, 0x00	; 0
 1dc:	0c 15       	cp	r16, r12
 1de:	1d 05       	cpc	r17, r13
 1e0:	28 f4       	brcc	.+10     	; 0x1ec <TwoWire::write(unsigned char const*, unsigned int)+0x30>
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:582
    if (TwoWire::write(*(data++)) == 0)
 1e2:	69 91       	ld	r22, Y+
 1e4:	c7 01       	movw	r24, r14
 1e6:	d8 df       	rcall	.-80     	; 0x198 <TwoWire::write(unsigned char)>
 1e8:	89 2b       	or	r24, r25
 1ea:	a9 f7       	brne	.-22     	; 0x1d6 <TwoWire::write(unsigned char const*, unsigned int)+0x1a>
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:587
      break;   // break if buffer full
  }

  return i;
}
 1ec:	c8 01       	movw	r24, r16
 1ee:	df 91       	pop	r29
 1f0:	cf 91       	pop	r28
 1f2:	1f 91       	pop	r17
 1f4:	0f 91       	pop	r16
 1f6:	ff 90       	pop	r15
 1f8:	ef 90       	pop	r14
 1fa:	df 90       	pop	r13
 1fc:	cf 90       	pop	r12
 1fe:	bf 90       	pop	r11
 200:	08 95       	ret

00000202 <Print::availableForWrite()>:
_ZN5Print17availableForWriteEv():
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/api/Print.h:65
      return write((const uint8_t *)buffer, size);
    }

    // default to zero, meaning "a single write may block"
    // should be overridden by subclasses with buffering
    virtual int availableForWrite() { return 0; }
 202:	90 e0       	ldi	r25, 0x00	; 0
 204:	80 e0       	ldi	r24, 0x00	; 0
 206:	08 95       	ret

00000208 <transmitDataWire()>:
_Z16transmitDataWirev():
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:202
      set_RGB_off();
    default:
      set_RGB_off();      
  }
}
void transmitDataWire() {
 208:	cf 93       	push	r28
 20a:	df 93       	push	r29
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:204
  
  temp[0] = (absolute_distance >> 8) & 0xFF;
 20c:	80 91 60 38 	lds	r24, 0x3860	; 0x803860 <absolute_distance>
 210:	90 91 61 38 	lds	r25, 0x3861	; 0x803861 <absolute_distance+0x1>
 214:	90 93 00 38 	sts	0x3800, r25	; 0x803800 <_edata>
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:205
  temp[1] = absolute_distance & 0xFF;
 218:	80 93 01 38 	sts	0x3801, r24	; 0x803801 <_edata+0x1>
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:206
  temp[2] = (cosine >> 8) & 0xFF;
 21c:	80 91 68 38 	lds	r24, 0x3868	; 0x803868 <cosine>
 220:	90 91 69 38 	lds	r25, 0x3869	; 0x803869 <cosine+0x1>
 224:	90 93 02 38 	sts	0x3802, r25	; 0x803802 <_edata+0x2>
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:207
  temp[3] = cosine & 0xFF;
 228:	80 93 03 38 	sts	0x3803, r24	; 0x803803 <_edata+0x3>
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:208
  temp[4] = (sine >> 8) & 0xFF;
 22c:	80 91 66 38 	lds	r24, 0x3866	; 0x803866 <sine>
 230:	90 91 67 38 	lds	r25, 0x3867	; 0x803867 <sine+0x1>
 234:	90 93 04 38 	sts	0x3804, r25	; 0x803804 <_edata+0x4>
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:209
  temp[5] = sine & 0xFF;
 238:	80 93 05 38 	sts	0x3805, r24	; 0x803805 <_edata+0x5>
 23c:	c0 e0       	ldi	r28, 0x00	; 0
 23e:	d8 e3       	ldi	r29, 0x38	; 56
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:213
  
  for(int i=0;i<6;i++)
  {
    Wire.write(temp[i]);
 240:	69 91       	ld	r22, Y+
write():
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.h:130
    }
    inline size_t write(unsigned int  n) {
      return      write((uint8_t)     n);
    }
    inline size_t write(int           n) {
      return      write((uint8_t)     n);
 242:	8b e0       	ldi	r24, 0x0B	; 11
 244:	98 e3       	ldi	r25, 0x38	; 56
 246:	a8 df       	rcall	.-176    	; 0x198 <TwoWire::write(unsigned char)>
_Z16transmitDataWirev():
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:211
  temp[2] = (cosine >> 8) & 0xFF;
  temp[3] = cosine & 0xFF;
  temp[4] = (sine >> 8) & 0xFF;
  temp[5] = sine & 0xFF;
  
  for(int i=0;i<6;i++)
 248:	88 e3       	ldi	r24, 0x38	; 56
 24a:	c6 30       	cpi	r28, 0x06	; 6
 24c:	d8 07       	cpc	r29, r24
 24e:	c1 f7       	brne	.-16     	; 0x240 <transmitDataWire()+0x38>
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:215
  {
    Wire.write(temp[i]);
  }
}
 250:	df 91       	pop	r29
 252:	cf 91       	pop	r28
 254:	08 95       	ret

00000256 <digitalWrite>:
digitalWrite():
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:240
    default:
      break;
  }
}

void digitalWrite(uint8_t pin, uint8_t val) {
 256:	cf 93       	push	r28
 258:	df 93       	push	r29
check_valid_digital_pin():
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/Arduino.h:873
#if !defined(NUM_TOTAL_PINS)
  #define NUM_TOTAL_PINS                (NUM_DIGITAL_PINS) /* Used the same way as NUM_DIGITAL_PINS. so it doesn't mean what it's named  - I didn't make the convention*/
#endif

inline __attribute__((always_inline)) void check_valid_digital_pin(pin_size_t pin) {
  if (__builtin_constant_p(pin)) {
 25a:	28 2f       	mov	r18, r24
 25c:	30 e0       	ldi	r19, 0x00	; 0
digitalWrite():
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:243
  check_valid_digital_pin(pin);
  /* Get bit mask for pin */
  uint8_t bit_mask = digitalPinToBitMask(pin);
 25e:	e9 01       	movw	r28, r18
 260:	c8 58       	subi	r28, 0x88	; 136
 262:	d1 47       	sbci	r29, 0x71	; 113
 264:	88 81       	ld	r24, Y
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:244
  if (bit_mask == NOT_A_PIN) {
 266:	8f 3f       	cpi	r24, 0xFF	; 255
 268:	09 f4       	brne	.+2      	; 0x26c <digitalWrite+0x16>
 26a:	3f c0       	rjmp	.+126    	; 0x2ea <digitalWrite+0x94>
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:249
    return;
  }

  /* Get port */
  PORT_t *port = digitalPinToPortStruct(pin);
 26c:	a9 01       	movw	r20, r18
 26e:	4a 59       	subi	r20, 0x9A	; 154
 270:	51 47       	sbci	r21, 0x71	; 113
 272:	da 01       	movw	r26, r20
 274:	ec 91       	ld	r30, X
 276:	b0 e2       	ldi	r27, 0x20	; 32
 278:	eb 9f       	mul	r30, r27
 27a:	f0 01       	movw	r30, r0
 27c:	11 24       	eor	r1, r1
 27e:	fc 5f       	subi	r31, 0xFC	; 252
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:257
  the behavior of digitalWrite() on classic AVR devices, where
  you could digitalWrite() a pin while it's an input, to ensure
  that the value of the port was set correctly when it was
  changed to an output. Code in the wild relies on this behavior. */

  if (val == LOW) { /* If LOW */
 280:	61 11       	cpse	r22, r1
 282:	36 c0       	rjmp	.+108    	; 0x2f0 <digitalWrite+0x9a>
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:258
    port->OUTCLR = bit_mask;
 284:	86 83       	std	Z+6, r24	; 0x06
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:282
  } else {
    port->OUTSET = bit_mask;
  }

  /* Input direction */
  if (!(port->DIR & bit_mask)) {
 286:	90 81       	ld	r25, Z
 288:	89 23       	and	r24, r25
 28a:	a1 f4       	brne	.+40     	; 0x2b4 <digitalWrite+0x5e>
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:289
      pull up is enabled if this function is called.
      Should we purposely implement this side effect?
    */

    /* Get bit position for getting pin ctrl reg */
    uint8_t bit_pos = digitalPinToBitPosition(pin);
 28c:	c9 01       	movw	r24, r18
 28e:	8c 5a       	subi	r24, 0xAC	; 172
 290:	91 47       	sbci	r25, 0x71	; 113
 292:	dc 01       	movw	r26, r24
 294:	9c 91       	ld	r25, X
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:292

    /* Calculate where pin control register is */
    volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);
 296:	30 97       	sbiw	r30, 0x00	; 0
 298:	69 f1       	breq	.+90     	; 0x2f4 <digitalWrite+0x9e>
 29a:	98 30       	cpi	r25, 0x08	; 8
 29c:	58 f5       	brcc	.+86     	; 0x2f4 <digitalWrite+0x9e>
 29e:	70 96       	adiw	r30, 0x10	; 16
 2a0:	e9 0f       	add	r30, r25
 2a2:	f1 1d       	adc	r31, r1
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:295

    /* Save system status and disable interrupts */
    uint8_t status = SREG;
 2a4:	9f b7       	in	r25, 0x3f	; 63
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:296
    cli();
 2a6:	f8 94       	cli
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:300

    if (val == LOW) {
      /* Disable pullup */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
 2a8:	80 81       	ld	r24, Z
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:298

    /* Save system status and disable interrupts */
    uint8_t status = SREG;
    cli();

    if (val == LOW) {
 2aa:	61 11       	cpse	r22, r1
 2ac:	26 c0       	rjmp	.+76     	; 0x2fa <digitalWrite+0xa4>
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:300
      /* Disable pullup */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
 2ae:	87 7f       	andi	r24, 0xF7	; 247
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:303
    } else {
      /* Enable pull-up */
      *pin_ctrl_reg |= PORT_PULLUPEN_bm;
 2b0:	80 83       	st	Z, r24
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:307
    }

    /* Restore system status */
    SREG = status;
 2b2:	9f bf       	out	0x3f, r25	; 63
turnOffPWM():
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:107
   * any timers with minimum overhead - critical on these parts
   * Since nothing that will show up here can have more than one
   * one bit set, binary and will give 0x00 if that bit is cleared
   * which is NOT_ON_TIMER.
   */
  uint8_t digital_pin_timer =  digitalPinToTimer(pin) & __PeripheralControl;
 2b4:	2e 5b       	subi	r18, 0xBE	; 190
 2b6:	31 47       	sbci	r19, 0x71	; 113
 2b8:	f9 01       	movw	r30, r18
 2ba:	90 81       	ld	r25, Z
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:109
  /* end megaTinyCore-specific section */
  if (digital_pin_timer== NOT_ON_TIMER) {
 2bc:	99 23       	and	r25, r25
 2be:	a9 f0       	breq	.+42     	; 0x2ea <digitalWrite+0x94>
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:113
    return;
  }

  uint8_t bit_mask = digitalPinToBitMask(pin);
 2c0:	88 81       	ld	r24, Y
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:116
  // TCB_t *timerB;

  switch (digital_pin_timer) {
 2c2:	90 34       	cpi	r25, 0x40	; 64
 2c4:	09 f1       	breq	.+66     	; 0x308 <digitalWrite+0xb2>
 2c6:	90 38       	cpi	r25, 0x80	; 128
 2c8:	e1 f0       	breq	.+56     	; 0x302 <digitalWrite+0xac>
 2ca:	90 31       	cpi	r25, 0x10	; 16
 2cc:	71 f4       	brne	.+28     	; 0x2ea <digitalWrite+0x94>
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:132
          }
          if (bit_mask > 0x04) {  // -> bit_pos > 2 -> output channel controlled by HCMP
            bit_mask <<= 1;       // mind the gap (between LCMP and HCMP)
          }
        #else
          if (digitalPinToPort(pin) == PB) {        // WO0-WO2, Bitmask has one of these bits 1: 0b00hhhlll.
 2ce:	da 01       	movw	r26, r20
 2d0:	9c 91       	ld	r25, X
 2d2:	91 30       	cpi	r25, 0x01	; 1
 2d4:	a1 f4       	brne	.+40     	; 0x2fe <digitalWrite+0xa8>
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:133
            if (bit_mask > 0x04) { // Is it one of the three high ones? If so
 2d6:	85 30       	cpi	r24, 0x05	; 5
 2d8:	10 f0       	brcs	.+4      	; 0x2de <digitalWrite+0x88>
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:134
              bit_mask <<= 1;      // nudge it 1 place left swap nybbles since that's 1 clock faster than 3 rightshifts.
 2da:	88 0f       	add	r24, r24
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:135
              _SWAP(bit_mask);     // swap nybbles since that's 1 clock faster than 3 rightshifts.
 2dc:	82 95       	swap	r24
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:142
          } else {
            // Otherwise, it's WO3-5. These will always be on 0b00hhh000,. Here since we ARE working with a high half timer, we need to just leftshift it once.
            bit_mask <<= 1;
          }
        #endif
        TCA0.SPLIT.CTRLB &= ~bit_mask;
 2de:	90 91 01 0a 	lds	r25, 0x0A01	; 0x800a01 <digital_pin_to_bit_mask+0x7f7b89>
 2e2:	80 95       	com	r24
 2e4:	89 23       	and	r24, r25
 2e6:	80 93 01 0a 	sts	0x0A01, r24	; 0x800a01 <digital_pin_to_bit_mask+0x7f7b89>
digitalWrite():
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:320
   * analogWritten() 255, then digitallyWritten() to HIGH, which
   * would turn it off for the time between turnOffPWM() and
   * PORT->OUTCLR)
   * Since there's no penalty, why make a glitch we don't have to? */
  turnOffPWM(pin);
}
 2ea:	df 91       	pop	r29
 2ec:	cf 91       	pop	r28
 2ee:	08 95       	ret
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:278
    // val will now be 0 (LOW) if the toggling made it LOW
    // or bit_mask if not. And further down, we only need to
    // know if it's
  /* If HIGH OR  > TOGGLE  */
  } else {
    port->OUTSET = bit_mask;
 2f0:	85 83       	std	Z+5, r24	; 0x05
 2f2:	c9 cf       	rjmp	.-110    	; 0x286 <digitalWrite+0x30>
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:292

    /* Get bit position for getting pin ctrl reg */
    uint8_t bit_pos = digitalPinToBitPosition(pin);

    /* Calculate where pin control register is */
    volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);
 2f4:	f0 e0       	ldi	r31, 0x00	; 0
 2f6:	e0 e0       	ldi	r30, 0x00	; 0
 2f8:	d5 cf       	rjmp	.-86     	; 0x2a4 <digitalWrite+0x4e>
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:303
    if (val == LOW) {
      /* Disable pullup */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
    } else {
      /* Enable pull-up */
      *pin_ctrl_reg |= PORT_PULLUPEN_bm;
 2fa:	88 60       	ori	r24, 0x08	; 8
 2fc:	d9 cf       	rjmp	.-78     	; 0x2b0 <digitalWrite+0x5a>
turnOffPWM():
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:139
              bit_mask <<= 1;      // nudge it 1 place left swap nybbles since that's 1 clock faster than 3 rightshifts.
              _SWAP(bit_mask);     // swap nybbles since that's 1 clock faster than 3 rightshifts.
            }
          } else {
            // Otherwise, it's WO3-5. These will always be on 0b00hhh000,. Here since we ARE working with a high half timer, we need to just leftshift it once.
            bit_mask <<= 1;
 2fe:	88 0f       	add	r24, r24
 300:	ee cf       	rjmp	.-36     	; 0x2de <digitalWrite+0x88>
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:157
    /* We don't need the type b timers as this core does not use them for PWM      */

    // 1-series parts have a DAC that we can use...
    #if defined(DAC0)
      case DACOUT:
        DAC0.CTRLA = 0x00;
 302:	10 92 a0 06 	sts	0x06A0, r1	; 0x8006a0 <digital_pin_to_bit_mask+0x7f7828>
 306:	f1 cf       	rjmp	.-30     	; 0x2ea <digitalWrite+0x94>
digitalWrite():
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:194
            #endif

            SREG = oldSREG;
          }
        #else
          uint8_t fc_mask = (bit_mask == 0x02 ? 0x80 : 0x40);
 308:	20 e4       	ldi	r18, 0x40	; 64
turnOffPWM():
 30a:	82 30       	cpi	r24, 0x02	; 2
 30c:	09 f4       	brne	.+2      	; 0x310 <digitalWrite+0xba>
digitalWrite():
 30e:	20 e8       	ldi	r18, 0x80	; 128
turnOffPWM():
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:195
          if (TCD0.FAULTCTRL & fc_mask) {
 310:	90 91 92 0a 	lds	r25, 0x0A92	; 0x800a92 <digital_pin_to_bit_mask+0x7f7c1a>
 314:	92 23       	and	r25, r18
 316:	49 f3       	breq	.-46     	; 0x2ea <digitalWrite+0x94>
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:196
            uint8_t oldSREG = SREG;
 318:	6f b7       	in	r22, 0x3f	; 63
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:197
            cli();
 31a:	f8 94       	cli
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:200
            // uint8_t TCD0_prescaler=TCD0.CTRLA&(~TCD_ENABLE_bm);
            //
            TCD0.CTRLA &= ~TCD_ENABLE_bm;
 31c:	90 91 80 0a 	lds	r25, 0x0A80	; 0x800a80 <digital_pin_to_bit_mask+0x7f7c08>
 320:	9e 7f       	andi	r25, 0xFE	; 254
 322:	90 93 80 0a 	sts	0x0A80, r25	; 0x800a80 <digital_pin_to_bit_mask+0x7f7c08>
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:201
            _PROTECTED_WRITE(TCD0.FAULTCTRL, TCD0.FAULTCTRL & (~fc_mask));
 326:	40 91 92 0a 	lds	r20, 0x0A92	; 0x800a92 <digital_pin_to_bit_mask+0x7f7c1a>
 32a:	30 e0       	ldi	r19, 0x00	; 0
 32c:	20 95       	com	r18
 32e:	30 95       	com	r19
 330:	50 e0       	ldi	r21, 0x00	; 0
 332:	24 23       	and	r18, r20
 334:	35 23       	and	r19, r21
 336:	98 ed       	ldi	r25, 0xD8	; 216
 338:	94 bf       	out	0x34, r25	; 52
 33a:	20 93 92 0a 	sts	0x0A92, r18	; 0x800a92 <digital_pin_to_bit_mask+0x7f7c1a>
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:202
            while (!(TCD0.STATUS & TCD_ENRDY_bm)); // wait until it can be re-enabled
 33e:	90 91 8e 0a 	lds	r25, 0x0A8E	; 0x800a8e <digital_pin_to_bit_mask+0x7f7c16>
 342:	90 ff       	sbrs	r25, 0
 344:	fc cf       	rjmp	.-8      	; 0x33e <digitalWrite+0xe8>
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:203
            TCD0.CTRLA |= TCD_ENABLE_bm;           // re-enable it
 346:	90 91 80 0a 	lds	r25, 0x0A80	; 0x800a80 <digital_pin_to_bit_mask+0x7f7c08>
 34a:	91 60       	ori	r25, 0x01	; 1
 34c:	90 93 80 0a 	sts	0x0A80, r25	; 0x800a80 <digital_pin_to_bit_mask+0x7f7c08>
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:220
                  PORTA.PIN6CTRL &= ~(PORT_INVEN_bm);
                } else {
                  PORTA.PIN7CTRL &= ~(PORT_INVEN_bm);
                }
              #else
                if (bit_mask == 0x01) {
 350:	81 30       	cpi	r24, 0x01	; 1
 352:	39 f4       	brne	.+14     	; 0x362 <digitalWrite+0x10c>
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:221
                  PORTC.PIN0CTRL &= ~(PORT_INVEN_bm);
 354:	80 91 50 04 	lds	r24, 0x0450	; 0x800450 <digital_pin_to_bit_mask+0x7f75d8>
 358:	8f 77       	andi	r24, 0x7F	; 127
 35a:	80 93 50 04 	sts	0x0450, r24	; 0x800450 <digital_pin_to_bit_mask+0x7f75d8>
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:227
                } else {
                  PORTC.PIN1CTRL &= ~(PORT_INVEN_bm);
                }
              #endif
            #endif
            SREG = oldSREG;
 35e:	6f bf       	out	0x3f, r22	; 63
 360:	c4 cf       	rjmp	.-120    	; 0x2ea <digitalWrite+0x94>
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:223
                }
              #else
                if (bit_mask == 0x01) {
                  PORTC.PIN0CTRL &= ~(PORT_INVEN_bm);
                } else {
                  PORTC.PIN1CTRL &= ~(PORT_INVEN_bm);
 362:	80 91 51 04 	lds	r24, 0x0451	; 0x800451 <digital_pin_to_bit_mask+0x7f75d9>
 366:	8f 77       	andi	r24, 0x7F	; 127
 368:	80 93 51 04 	sts	0x0451, r24	; 0x800451 <digital_pin_to_bit_mask+0x7f75d9>
 36c:	f8 cf       	rjmp	.-16     	; 0x35e <digitalWrite+0x108>

0000036e <set_RGB_off()>:
_Z11set_RGB_offv():
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:160
// }


void set_RGB_off()
{
  digitalWrite(LED_RED_1,HIGH); 
 36e:	61 e0       	ldi	r22, 0x01	; 1
 370:	8a e0       	ldi	r24, 0x0A	; 10
 372:	71 df       	rcall	.-286    	; 0x256 <digitalWrite>
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:161
  digitalWrite(LED_GREEN_1,HIGH);
 374:	61 e0       	ldi	r22, 0x01	; 1
 376:	8b e0       	ldi	r24, 0x0B	; 11
 378:	6e df       	rcall	.-292    	; 0x256 <digitalWrite>
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:162
  digitalWrite(LED_BLUE_1,HIGH);
 37a:	61 e0       	ldi	r22, 0x01	; 1
 37c:	8c e0       	ldi	r24, 0x0C	; 12
 37e:	6b df       	rcall	.-298    	; 0x256 <digitalWrite>
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:163
  digitalWrite(LED_RED_2,HIGH);
 380:	61 e0       	ldi	r22, 0x01	; 1
 382:	85 e0       	ldi	r24, 0x05	; 5
 384:	68 df       	rcall	.-304    	; 0x256 <digitalWrite>
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:164
  digitalWrite(LED_GREEN_2,HIGH);
 386:	61 e0       	ldi	r22, 0x01	; 1
 388:	86 e0       	ldi	r24, 0x06	; 6
 38a:	65 df       	rcall	.-310    	; 0x256 <digitalWrite>
 38c:	61 e0       	ldi	r22, 0x01	; 1
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:165
  digitalWrite(LED_BLUE_2,HIGH);
 38e:	87 e0       	ldi	r24, 0x07	; 7
 390:	62 cf       	rjmp	.-316    	; 0x256 <digitalWrite>

00000392 <receiveEvent(int)>:
_Z12receiveEventi():
 392:	cf 93       	push	r28
 394:	90 91 19 38 	lds	r25, 0x3819	; 0x803819 <Wire+0xe>
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:218
    Wire.write(temp[i]);
  }
}

void receiveEvent(int howMany) {
  while (Wire.available()) { // loop through all but the last
 398:	80 91 1a 38 	lds	r24, 0x381A	; 0x80381a <Wire+0xf>
 39c:	98 17       	cp	r25, r24
 39e:	61 f1       	breq	.+88     	; 0x3f8 <receiveEvent(int)+0x66>
 3a0:	8b e0       	ldi	r24, 0x0B	; 11
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:219
    char c = Wire.read(); // receive byte as a character
 3a2:	98 e3       	ldi	r25, 0x38	; 56
 3a4:	e1 de       	rcall	.-574    	; 0x168 <TwoWire::read()>
 3a6:	c8 2f       	mov	r28, r24
 3a8:	82 35       	cpi	r24, 0x52	; 82
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:220
    if (c == 'R')
 3aa:	29 f4       	brne	.+10     	; 0x3b6 <receiveEvent(int)+0x24>
 3ac:	10 92 60 38 	sts	0x3860, r1	; 0x803860 <absolute_distance>
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:222
    {
      absolute_distance=0;
 3b0:	10 92 61 38 	sts	0x3861, r1	; 0x803861 <absolute_distance+0x1>
 3b4:	ef cf       	rjmp	.-34     	; 0x394 <receiveEvent(int)+0x2>
set_RGB():
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:181
}

void set_RGB(char color)

{
  set_RGB_off();
 3b6:	db df       	rcall	.-74     	; 0x36e <set_RGB_off()>
 3b8:	c4 34       	cpi	r28, 0x44	; 68
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:182
  switch(color)
 3ba:	59 f0       	breq	.+22     	; 0x3d2 <receiveEvent(int)+0x40>
 3bc:	24 f4       	brge	.+8      	; 0x3c6 <receiveEvent(int)+0x34>
 3be:	c2 34       	cpi	r28, 0x42	; 66
 3c0:	a9 f0       	breq	.+42     	; 0x3ec <receiveEvent(int)+0x5a>
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:199
      digitalWrite(LED_BLUE_2,LOW);
      break;
    case OFF:
      set_RGB_off();
    default:
      set_RGB_off();      
 3c2:	d5 df       	rcall	.-86     	; 0x36e <set_RGB_off()>
 3c4:	e7 cf       	rjmp	.-50     	; 0x394 <receiveEvent(int)+0x2>
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:182

void set_RGB(char color)

{
  set_RGB_off();
  switch(color)
 3c6:	c7 34       	cpi	r28, 0x47	; 71
 3c8:	59 f0       	breq	.+22     	; 0x3e0 <receiveEvent(int)+0x4e>
 3ca:	cf 34       	cpi	r28, 0x4F	; 79
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:197
    case BLUE:
      digitalWrite(LED_BLUE_1,LOW);
      digitalWrite(LED_BLUE_2,LOW);
      break;
    case OFF:
      set_RGB_off();
 3cc:	d1 f7       	brne	.-12     	; 0x3c2 <receiveEvent(int)+0x30>
 3ce:	cf df       	rcall	.-98     	; 0x36e <set_RGB_off()>
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:185
{
  set_RGB_off();
  switch(color)
  {
    case RED:
      digitalWrite(LED_RED_1,LOW); 
 3d0:	f8 cf       	rjmp	.-16     	; 0x3c2 <receiveEvent(int)+0x30>
 3d2:	60 e0       	ldi	r22, 0x00	; 0
 3d4:	8a e0       	ldi	r24, 0x0A	; 10
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:186
      digitalWrite(LED_RED_2,LOW);
 3d6:	3f df       	rcall	.-386    	; 0x256 <digitalWrite>
 3d8:	60 e0       	ldi	r22, 0x00	; 0
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:194
      digitalWrite(LED_GREEN_1,LOW);
      digitalWrite(LED_GREEN_2,LOW);
      break;
    case BLUE:
      digitalWrite(LED_BLUE_1,LOW);
      digitalWrite(LED_BLUE_2,LOW);
 3da:	85 e0       	ldi	r24, 0x05	; 5
 3dc:	3c df       	rcall	.-392    	; 0x256 <digitalWrite>
 3de:	da cf       	rjmp	.-76     	; 0x394 <receiveEvent(int)+0x2>
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:189
    case RED:
      digitalWrite(LED_RED_1,LOW); 
      digitalWrite(LED_RED_2,LOW);
      break;
    case GREEN:
      digitalWrite(LED_GREEN_1,LOW);
 3e0:	60 e0       	ldi	r22, 0x00	; 0
 3e2:	8b e0       	ldi	r24, 0x0B	; 11
 3e4:	38 df       	rcall	.-400    	; 0x256 <digitalWrite>
 3e6:	60 e0       	ldi	r22, 0x00	; 0
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:190
      digitalWrite(LED_GREEN_2,LOW);
 3e8:	86 e0       	ldi	r24, 0x06	; 6
 3ea:	f8 cf       	rjmp	.-16     	; 0x3dc <receiveEvent(int)+0x4a>
 3ec:	60 e0       	ldi	r22, 0x00	; 0
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:193
      break;
    case BLUE:
      digitalWrite(LED_BLUE_1,LOW);
 3ee:	8c e0       	ldi	r24, 0x0C	; 12
 3f0:	32 df       	rcall	.-412    	; 0x256 <digitalWrite>
 3f2:	60 e0       	ldi	r22, 0x00	; 0
 3f4:	87 e0       	ldi	r24, 0x07	; 7
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:194
      digitalWrite(LED_BLUE_2,LOW);
 3f6:	f2 cf       	rjmp	.-28     	; 0x3dc <receiveEvent(int)+0x4a>
_Z12receiveEventi():
 3f8:	cf 91       	pop	r28
 3fa:	08 95       	ret

000003fc <analogRead>:
analogRead():
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:229
    else 
    {
      set_RGB(c);
    }
  }
}
 3fc:	8c 5f       	subi	r24, 0xFC	; 252
 3fe:	90 91 00 06 	lds	r25, 0x0600	; 0x800600 <digital_pin_to_bit_mask+0x7f7788>
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_analog.c:711
      // don't waste flash on smallest parts.
      if ((pin & 0x7F) > 0x1F) { // highest valid mux value for any 0 or 1-series part.
        return ADC_ERROR_BAD_PIN_OR_CHANNEL;
      }
    #endif
    if (!ADC0.CTRLA & 0x01) return ADC_ERROR_DISABLED;
 402:	99 23       	and	r25, r25
 404:	71 f0       	breq	.+28     	; 0x422 <__LOCK_REGION_LENGTH__+0x22>
 406:	80 93 06 06 	sts	0x0606, r24	; 0x800606 <digital_pin_to_bit_mask+0x7f778e>
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_analog.c:715
    pin &= 0x1F;
    /* Reference should be already set up */
    /* Select channel */
    ADC0.MUXPOS = (pin << ADC_MUXPOS_gp);
 40a:	81 e0       	ldi	r24, 0x01	; 1
 40c:	80 93 08 06 	sts	0x0608, r24	; 0x800608 <digital_pin_to_bit_mask+0x7f7790>
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_analog.c:722
    #if defined(STRICT_ERROR_CHECKING)
      if (ADC0.COMMAND) return ADC_ERROR_BUSY;
    #endif

    /* Start conversion */
    ADC0.COMMAND = ADC_STCONV_bm;
 410:	80 91 0b 06 	lds	r24, 0x060B	; 0x80060b <digital_pin_to_bit_mask+0x7f7793>
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_analog.c:725

    /* Wait for result ready */
    while (!(ADC0.INTFLAGS & ADC_RESRDY_bm));
 414:	80 ff       	sbrs	r24, 0
 416:	fc cf       	rjmp	.-8      	; 0x410 <__LOCK_REGION_LENGTH__+0x10>
 418:	80 91 10 06 	lds	r24, 0x0610	; 0x800610 <digital_pin_to_bit_mask+0x7f7798>
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_analog.c:728

    /* Combine two bytes */
    return ADC0.RES;
 41c:	90 91 11 06 	lds	r25, 0x0611	; 0x800611 <digital_pin_to_bit_mask+0x7f7799>
 420:	08 95       	ret
 422:	89 ef       	ldi	r24, 0xF9	; 249
 424:	92 e8       	ldi	r25, 0x82	; 130
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_analog.c:711
      // don't waste flash on smallest parts.
      if ((pin & 0x7F) > 0x1F) { // highest valid mux value for any 0 or 1-series part.
        return ADC_ERROR_BAD_PIN_OR_CHANNEL;
      }
    #endif
    if (!ADC0.CTRLA & 0x01) return ADC_ERROR_DISABLED;
 426:	08 95       	ret

00000428 <pinMode.constprop.11>:
pinMode.constprop.11():
 428:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_analog.c:729
    /* Wait for result ready */
    while (!(ADC0.INTFLAGS & ADC_RESRDY_bm));

    /* Combine two bytes */
    return ADC0.RES;
  }
 42a:	fc 01       	movw	r30, r24
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/Arduino.h:873
 42c:	e8 58       	subi	r30, 0x88	; 136
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:44
}

void pinMode(uint8_t pin, uint8_t mode) {
  check_valid_digital_pin(pin);         /* generate compile error if a constant that is not a valid pin is used as the pin */
  check_valid_pin_mode(mode);           /* generate compile error if a constant that is not a valid pin mode is used as the mode */
  uint8_t bit_mask = digitalPinToBitMask(pin);
 42e:	f1 47       	sbci	r31, 0x71	; 113
 430:	20 81       	ld	r18, Z
 432:	2f 3f       	cpi	r18, 0xFF	; 255
 434:	99 f0       	breq	.+38     	; 0x45c <pinMode.constprop.11+0x34>
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:45
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
 436:	fc 01       	movw	r30, r24
 438:	ea 59       	subi	r30, 0x9A	; 154
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:48
    return;                             /* ignore invalid pins passed at runtime */
  }
  volatile uint8_t * port_base = (volatile uint8_t *) (uint16_t) ((&PORTA) + digitalPinToPort(pin));
 43a:	f1 47       	sbci	r31, 0x71	; 113
 43c:	e0 81       	ld	r30, Z
 43e:	30 e2       	ldi	r19, 0x20	; 32
 440:	e3 9f       	mul	r30, r19
 442:	f0 01       	movw	r30, r0
 444:	11 24       	eor	r1, r1
 446:	fc 5f       	subi	r31, 0xFC	; 252
 448:	21 83       	std	Z+1, r18	; 0x01
 44a:	8c 5a       	subi	r24, 0xAC	; 172
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:51
  if (mode & 0x01) {
    // OUTPUT mode, so write DIRSET with the mask.
    *(port_base + 1) = bit_mask;
 44c:	91 47       	sbci	r25, 0x71	; 113
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:77
  // then load with displacement 2 clocks. IFF the compiler puts this pointer into Y or Z, it is faster and smaller
  // by 2 bytes and one clock. And let's hope it is, because the code above would suck too if it was in X.
  // Handwritten assembly that exploited the knowledge that there will never be a carry would save 1 word and 1 clock.
  // and could probably save at least several times that in initializing the port_base pointer. But if you're using
  // pinMode you probably don't care.
  port_base += (uint8_t) digitalPinToBitPosition(pin);
 44e:	dc 01       	movw	r26, r24
 450:	8c 91       	ld	r24, X
 452:	e8 0f       	add	r30, r24
 454:	f1 1d       	adc	r31, r1
 456:	80 89       	ldd	r24, Z+16	; 0x10
 458:	87 7f       	andi	r24, 0xF7	; 247
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:78
  bit_mask = *(port_base + 0x10);
 45a:	80 8b       	std	Z+16, r24	; 0x10
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:82
  if (mode & 2) {
    bit_mask |= 0x08;
  } else {
    bit_mask &= 0xF7;
 45c:	08 95       	ret

0000045e <__vector_15>:
__vector_15():
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:84
  }
  *(port_base + 0x10) = bit_mask;
 45e:	8f 93       	push	r24
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:85
}
 460:	81 e0       	ldi	r24, 0x01	; 1
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:206
  #else
    ISR(MILLIS_TIMER_VECTOR, ISR_NAKED) {
      // Common Interrupt header for TCB, TCA and TCD;
      // Clears the Timer Interrupt flag and pushes the CPU Registers
      // 7 words / 7 clocks
      __asm__ __volatile__(
 462:	80 93 8d 0a 	sts	0x0A8D, r24	; 0x800a8d <digital_pin_to_bit_mask+0x7f7c15>
 466:	8f b7       	in	r24, 0x3f	; 63
 468:	8f 93       	push	r24
 46a:	ef 93       	push	r30
 46c:	ff 93       	push	r31
 46e:	e2 e9       	ldi	r30, 0x92	; 146
 470:	f8 e3       	ldi	r31, 0x38	; 56
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:317
        [MIINC]  "M" ((0x0000 - MILLIS_INC) & 0xFF),
        [MINCD]  "M" ((0xFFFF - MILLIS_INC) & 0xFF)
      );
  */

      __asm__ __volatile__(
 472:	9f 93       	push	r25
 474:	68 94       	set
 476:	8f ef       	ldi	r24, 0xFF	; 255
 478:	0d c0       	rjmp	.+26     	; 0x494 <sub4>

0000047a <ovf_end>:
 47a:	e8 94       	clt
 47c:	84 81       	ldd	r24, Z+4	; 0x04
 47e:	95 81       	ldd	r25, Z+5	; 0x05
 480:	80 5d       	subi	r24, 0xD0	; 208
 482:	9c 4f       	sbci	r25, 0xFC	; 252
 484:	84 83       	std	Z+4, r24	; 0x04
 486:	95 83       	std	Z+5, r25	; 0x05
 488:	88 5e       	subi	r24, 0xE8	; 232
 48a:	93 40       	sbci	r25, 0x03	; 3
 48c:	80 f0       	brcs	.+32     	; 0x4ae <sub_end>
 48e:	84 83       	std	Z+4, r24	; 0x04
 490:	95 83       	std	Z+5, r25	; 0x05
 492:	8f ef       	ldi	r24, 0xFF	; 255

00000494 <sub4>:
 494:	90 81       	ld	r25, Z
 496:	98 1b       	sub	r25, r24
 498:	91 93       	st	Z+, r25
 49a:	90 81       	ld	r25, Z
 49c:	9f 4f       	sbci	r25, 0xFF	; 255
 49e:	91 93       	st	Z+, r25
 4a0:	90 81       	ld	r25, Z
 4a2:	9f 4f       	sbci	r25, 0xFF	; 255
 4a4:	91 93       	st	Z+, r25
 4a6:	90 81       	ld	r25, Z
 4a8:	9f 4f       	sbci	r25, 0xFF	; 255
 4aa:	91 93       	st	Z+, r25
 4ac:	36 f3       	brts	.-52     	; 0x47a <ovf_end>

000004ae <sub_end>:
 4ae:	9f 91       	pop	r25
 4b0:	ff 91       	pop	r31
 4b2:	ef 91       	pop	r30
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:379
        [MINCD]  "M" ((0xFFFF - MILLIS_INC) & 0xFF)
      );
    #endif /* (defined(MILLIS_USE_TIMERB0) || defined(MILLIS_USE_TIMERB1) || defined(MILLIS_USE_TIMERB2) || defined(MILLIS_USE_TIMERB3) || defined(MILLIS_USE_TIMERB4)) */
    // Common ISR Epilogue for TCA, TCB and TCD, popping register in reverse Order
    // 6 words, 14 clocks
    __asm__ __volatile__(
 4b4:	8f 91       	pop	r24
 4b6:	8f bf       	out	0x3f, r24	; 63
 4b8:	8f 91       	pop	r24
 4ba:	18 95       	reti

000004bc <__vector_24>:
__vector_24():
 4bc:	1f 92       	push	r1
 4be:	0f 92       	push	r0
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:977


/**
 *@brief      TWI0 Slave Interrupt vector
 */
ISR(TWI0_TWIS_vect) {
 4c0:	0f b6       	in	r0, 0x3f	; 63
 4c2:	0f 92       	push	r0
 4c4:	11 24       	eor	r1, r1
 4c6:	1f 93       	push	r17
 4c8:	2f 93       	push	r18
 4ca:	3f 93       	push	r19
 4cc:	4f 93       	push	r20
 4ce:	5f 93       	push	r21
 4d0:	6f 93       	push	r22
 4d2:	7f 93       	push	r23
 4d4:	8f 93       	push	r24
 4d6:	9f 93       	push	r25
 4d8:	af 93       	push	r26
 4da:	bf 93       	push	r27
 4dc:	cf 93       	push	r28
 4de:	df 93       	push	r29
 4e0:	ef 93       	push	r30
 4e2:	ff 93       	push	r31
TWI_HandleSlaveIRQ():
 4e4:	c3 e1       	ldi	r28, 0x13	; 19
 4e6:	d8 e3       	ldi	r29, 0x38	; 56
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:522
  // used as a frame pointer and the compiler avoids using it. So, using it comes with a price of pushing/popping
  // r28/r29, as well as ldi the address of the struct into those, so it only makes sense in a few cases like this.
  // Since the Y register is not call-clobbered, it can be considered persistent in this function and has not to
  // be restored after the icall to the user callbacks, unlike Z (which is used for _module and icall).

  _fastPtr_y(_data,_data);  // force _data into Y and instruct to not change Y
 4e8:	e8 81       	ld	r30, Y
 4ea:	f9 81       	ldd	r31, Y+1	; 0x01
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:564
  #if defined(TWI_MANDS)
    _data->_bools._toggleStreamFn = 0x01;
  #endif

  uint8_t action = 0;
  uint8_t clientStatus = _data->_module->SSTATUS;
 4ec:	83 85       	ldd	r24, Z+11	; 0x0b
 4ee:	86 ff       	sbrs	r24, 6
 4f0:	56 c0       	rjmp	.+172    	; 0x59e <__vector_24+0xe2>
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:566

  if (clientStatus & TWI_APIF_bm) {  // Address/Stop Bit set
 4f2:	80 ff       	sbrs	r24, 0
 4f4:	41 c0       	rjmp	.+130    	; 0x578 <__vector_24+0xbc>
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:567
    if (clientStatus & TWI_AP_bm) {    // Address bit set
 4f6:	15 85       	ldd	r17, Z+13	; 0x0d
 4f8:	81 ff       	sbrs	r24, 1
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:568
      uint8_t payload = _data->_module->SDATA;  // read address from data register
 4fa:	38 c0       	rjmp	.+112    	; 0x56c <__vector_24+0xb0>
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:569
      if (clientStatus & TWI_DIR_bm) {  // Master is reading
 4fc:	8e 81       	ldd	r24, Y+6	; 0x06
 4fe:	88 23       	and	r24, r24
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:570
        if ((*rxHead) > 0) {                    // There is no way to identify a REPSTART,
 500:	59 f0       	breq	.+22     	; 0x518 <__vector_24+0x5c>
popSleep():
 502:	80 91 0a 38 	lds	r24, 0x380A	; 0x80380a <sleepStack>
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:690
        sleepStackLoc = 0;              // reset everything
      }
      sleepStack = sleepStackLoc;
    }
  #else
    SLPCTRL.CTRLA = sleepStack;
 506:	80 93 50 00 	sts	0x0050, r24	; 0x800050 <digital_pin_to_bit_mask+0x7f71d8>
TWI_HandleSlaveIRQ():
 50a:	eb 85       	ldd	r30, Y+11	; 0x0b
 50c:	fc 85       	ldd	r31, Y+12	; 0x0c
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:572
    if (clientStatus & TWI_AP_bm) {    // Address bit set
      uint8_t payload = _data->_module->SDATA;  // read address from data register
      if (clientStatus & TWI_DIR_bm) {  // Master is reading
        if ((*rxHead) > 0) {                    // There is no way to identify a REPSTART,
          popSleep();                           // (have to treat REPSTART as another pop for sleep)
          if (_data->user_onReceive != NULL) {  // so when a Master Read occurs after a Master write
 50e:	30 97       	sbiw	r30, 0x00	; 0
 510:	19 f0       	breq	.+6      	; 0x518 <__vector_24+0x5c>
 512:	8e 81       	ldd	r24, Y+6	; 0x06
 514:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:573
            _data->user_onReceive((*rxHead));   // issue a call to the user callback first
 516:	09 95       	icall
 518:	1c 83       	std	Y+4, r17	; 0x04
 51a:	1d 82       	std	Y+5, r1	; 0x05
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:576
          }
        }
        (*address) = payload;                   // saving address to expose to the user sketch
 51c:	18 86       	std	Y+8, r1	; 0x08
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:577
        (*txHead) = 0;                          // reset buffer positions so the Master can start writing at zero.
 51e:	e9 85       	ldd	r30, Y+9	; 0x09
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:578
        (*txTail) = 0;
 520:	fa 85       	ldd	r31, Y+10	; 0x0a
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:580

        if (_data->user_onRequest != NULL) {
 522:	30 97       	sbiw	r30, 0x00	; 0
 524:	09 f0       	breq	.+2      	; 0x528 <__vector_24+0x6c>
 526:	09 95       	icall
 528:	8d 81       	ldd	r24, Y+5	; 0x05
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:581
          _data->user_onRequest();
 52a:	88 23       	and	r24, r24
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:583
        }
        if ((*txHead) == 0) {                   // If no data to transmit, send NACK
 52c:	19 f1       	breq	.+70     	; 0x574 <__vector_24+0xb8>
__vector_24():
 52e:	83 e0       	ldi	r24, 0x03	; 3
pushSleep():
 530:	90 91 50 00 	lds	r25, 0x0050	; 0x800050 <digital_pin_to_bit_mask+0x7f71d8>
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:672
      sleepStackLoc = SLPCTRL.CTRLA;        // save sleep settings to sleepStack
      SLPCTRL.CTRLA = sleepStackLoc & 0x01; // Set to IDLE if sleep was enabled
    }
    sleepStack = sleepStackLoc;
  #else
    sleepStack = SLPCTRL.CTRLA;           // save old sleep State
 534:	90 93 0a 38 	sts	0x380A, r25	; 0x80380a <sleepStack>
 538:	91 70       	andi	r25, 0x01	; 1
 53a:	90 93 50 00 	sts	0x0050, r25	; 0x800050 <digital_pin_to_bit_mask+0x7f71d8>
TWI_HandleSlaveIRQ():
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:673
    SLPCTRL.CTRLA = sleepStack & 0x01;    // only leave the SEN bit, if it was set
 53e:	e8 81       	ld	r30, Y
 540:	f9 81       	ldd	r31, Y+1	; 0x01
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:639
          action = TWI_ACKACT_bm | TWI_SCMD_COMPTRANS_gc;  // "Execute ACK Action succeeded by waiting for any Start (S/Sr) condition"
        }
      }
    }
  }
  _data->_module->SCTRLB = action;  // using local variable (register) reduces the amount of loading _module
 542:	82 87       	std	Z+10, r24	; 0x0a
__vector_24():
 544:	ff 91       	pop	r31
 546:	ef 91       	pop	r30
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:979
  TwoWire::onSlaveIRQ(&TWI0);
}
 548:	df 91       	pop	r29
 54a:	cf 91       	pop	r28
 54c:	bf 91       	pop	r27
 54e:	af 91       	pop	r26
 550:	9f 91       	pop	r25
 552:	8f 91       	pop	r24
 554:	7f 91       	pop	r23
 556:	6f 91       	pop	r22
 558:	5f 91       	pop	r21
 55a:	4f 91       	pop	r20
 55c:	3f 91       	pop	r19
 55e:	2f 91       	pop	r18
 560:	1f 91       	pop	r17
 562:	0f 90       	pop	r0
 564:	0f be       	out	0x3f, r0	; 63
 566:	0f 90       	pop	r0
 568:	1f 90       	pop	r1
 56a:	18 95       	reti
TWI_HandleSlaveIRQ():
 56c:	1c 83       	std	Y+4, r17	; 0x04
 56e:	1e 82       	std	Y+6, r1	; 0x06
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:590
        } else {
          action = TWI_SCMD_RESPONSE_gc;        // "Execute Acknowledge Action succeeded by reception of next byte"
        }
      } else {                          // Master is writing
        action = TWI_SCMD_RESPONSE_gc;  // "Execute Acknowledge Action succeeded by reception of next byte"
        (*address) = payload;           // saving address to expose to the user sketch
 570:	1f 82       	std	Y+7, r1	; 0x07
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:591
        (*rxHead) = 0;                  // reset buffer positions so the Master can start writing at zero.
 572:	dd cf       	rjmp	.-70     	; 0x52e <__vector_24+0x72>
__vector_24():
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:592
        (*rxTail) = 0;
 574:	86 e0       	ldi	r24, 0x06	; 6
 576:	dc cf       	rjmp	.-72     	; 0x530 <__vector_24+0x74>
popSleep():
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:584

        if (_data->user_onRequest != NULL) {
          _data->user_onRequest();
        }
        if ((*txHead) == 0) {                   // If no data to transmit, send NACK
          action = TWI_ACKACT_bm | TWI_SCMD_COMPTRANS_gc;  // NACK + "Wait for any Start (S/Sr) condition"
 578:	80 91 0a 38 	lds	r24, 0x380A	; 0x80380a <sleepStack>
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:690
        sleepStackLoc = 0;              // reset everything
      }
      sleepStack = sleepStackLoc;
    }
  #else
    SLPCTRL.CTRLA = sleepStack;
 57c:	80 93 50 00 	sts	0x0050, r24	; 0x800050 <digital_pin_to_bit_mask+0x7f71d8>
TWI_HandleSlaveIRQ():
 580:	eb 85       	ldd	r30, Y+11	; 0x0b
 582:	fc 85       	ldd	r31, Y+12	; 0x0c
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:597
        (*rxTail) = 0;
      }
      pushSleep();
    } else {                            // Stop bit set
      popSleep();
      if (_data->user_onReceive != NULL) {
 584:	30 97       	sbiw	r30, 0x00	; 0
 586:	29 f0       	breq	.+10     	; 0x592 <__vector_24+0xd6>
 588:	8e 81       	ldd	r24, Y+6	; 0x06
 58a:	88 23       	and	r24, r24
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:598
        if ((*rxHead) > 0) {
 58c:	11 f0       	breq	.+4      	; 0x592 <__vector_24+0xd6>
 58e:	90 e0       	ldi	r25, 0x00	; 0
 590:	09 95       	icall
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:599
          _data->user_onReceive((*rxHead));
 592:	1e 82       	std	Y+6, r1	; 0x06
 594:	1d 82       	std	Y+5, r1	; 0x05
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:603
        }
      }
      action = TWI_SCMD_COMPTRANS_gc;  // "Wait for any Start (S/Sr) condition"
      (*rxHead) = 0;
 596:	1f 82       	std	Y+7, r1	; 0x07
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:604
      (*txHead) = 0;
 598:	18 86       	std	Y+8, r1	; 0x08
__vector_24():
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:605
      (*rxTail) = 0;
 59a:	82 e0       	ldi	r24, 0x02	; 2
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:606
      (*txTail) = 0;
 59c:	d0 cf       	rjmp	.-96     	; 0x53e <__vector_24+0x82>
TWI_HandleSlaveIRQ():
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:623
        if ((*txTail) < (*txHead)) {            // Data is available
          _data->_module->SDATA = txBuffer[(*txTail)];  // Writing to the register to send data
          (*txTail)++;                            // Increment counter for sent bytes
          action = TWI_SCMD_RESPONSE_gc;          // "Execute a byte read operation followed by Acknowledge Action"
        } else {                                // No more data available
          action = TWI_SCMD_COMPTRANS_gc;         // "Wait for any Start (S/Sr) condition"
 59e:	87 ff       	sbrs	r24, 7
 5a0:	2f c0       	rjmp	.+94     	; 0x600 <__vector_24+0x144>
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:608
      (*rxHead) = 0;
      (*txHead) = 0;
      (*rxTail) = 0;
      (*txTail) = 0;
    }
  } else if (clientStatus & TWI_DIF_bm) { // Data bit set
 5a2:	81 ff       	sbrs	r24, 1
 5a4:	1e c0       	rjmp	.+60     	; 0x5e2 <__vector_24+0x126>
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:609
    if (clientStatus & TWI_DIR_bm) {        // Master is reading
 5a6:	88 71       	andi	r24, 0x18	; 24
 5a8:	39 f0       	breq	.+14     	; 0x5b8 <__vector_24+0xfc>
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:610
      if ((clientStatus & (TWI_COLL_bm | TWI_RXACK_bm)) &&  // If a collision was detected, or RXACK bit is set AND
 5aa:	8a 81       	ldd	r24, Y+2	; 0x02
 5ac:	83 ff       	sbrs	r24, 3
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:611
          (true == _data->_bools._ackMatters)) {            // And we have to check for it
 5ae:	04 c0       	rjmp	.+8      	; 0x5b8 <__vector_24+0xfc>
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:610
      (*rxTail) = 0;
      (*txTail) = 0;
    }
  } else if (clientStatus & TWI_DIF_bm) { // Data bit set
    if (clientStatus & TWI_DIR_bm) {        // Master is reading
      if ((clientStatus & (TWI_COLL_bm | TWI_RXACK_bm)) &&  // If a collision was detected, or RXACK bit is set AND
 5b0:	1d 82       	std	Y+5, r1	; 0x05
 5b2:	87 7f       	andi	r24, 0xF7	; 247
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:612
          (true == _data->_bools._ackMatters)) {            // And we have to check for it
        (*txHead) = 0;                          // Abort further data writes
 5b4:	8a 83       	std	Y+2, r24	; 0x02
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:613
        _data->_bools._ackMatters = false;      // stop checking for NACK
 5b6:	f1 cf       	rjmp	.-30     	; 0x59a <__vector_24+0xde>
 5b8:	8b 81       	ldd	r24, Y+3	; 0x03
 5ba:	8f 5f       	subi	r24, 0xFF	; 255
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:616
        action = TWI_SCMD_COMPTRANS_gc;         // "Wait for any Start (S/Sr) condition"
      } else {                                // RXACK bit not set, no COLL
        _data->_bytesTransmittedS++;            // increment bytes transmitted counter (for register model)
 5bc:	8b 83       	std	Y+3, r24	; 0x03
 5be:	8a 81       	ldd	r24, Y+2	; 0x02
 5c0:	88 60       	ori	r24, 0x08	; 8
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:617
        _data->_bools._ackMatters = true;       // start checking for NACK
 5c2:	8a 83       	std	Y+2, r24	; 0x02
 5c4:	a8 85       	ldd	r26, Y+8	; 0x08
 5c6:	8d 81       	ldd	r24, Y+5	; 0x05
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:618
        if ((*txTail) < (*txHead)) {            // Data is available
 5c8:	a8 17       	cp	r26, r24
 5ca:	38 f7       	brcc	.-50     	; 0x59a <__vector_24+0xde>
 5cc:	ac 0f       	add	r26, r28
 5ce:	bd 2f       	mov	r27, r29
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:619
          _data->_module->SDATA = txBuffer[(*txTail)];  // Writing to the register to send data
 5d0:	b1 1d       	adc	r27, r1
 5d2:	1d 96       	adiw	r26, 0x0d	; 13
 5d4:	8c 91       	ld	r24, X
 5d6:	85 87       	std	Z+13, r24	; 0x0d
 5d8:	88 85       	ldd	r24, Y+8	; 0x08
 5da:	8f 5f       	subi	r24, 0xFF	; 255
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:620
          (*txTail)++;                            // Increment counter for sent bytes
 5dc:	88 87       	std	Y+8, r24	; 0x08
__vector_24():
 5de:	83 e0       	ldi	r24, 0x03	; 3
 5e0:	ae cf       	rjmp	.-164    	; 0x53e <__vector_24+0x82>
TWI_HandleSlaveIRQ():
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:632
      uint8_t payload = _data->_module->SDATA;      // reading SDATA will clear the DATA IRQ flag
      if ((*rxHead) < BUFFER_LENGTH) {              // make sure that we don't have a buffer overflow in case Master ignores NACK
        rxBuffer[(*rxHead)] = payload;              // save data
        (*rxHead)++;                                  // Advance Head
        if ((*rxHead) < BUFFER_LENGTH) {              // if buffer is not yet full
          action = TWI_SCMD_RESPONSE_gc;                // "Execute Acknowledge Action succeeded by reception of next byte"
 5e2:	85 85       	ldd	r24, Z+13	; 0x0d
 5e4:	ee 81       	ldd	r30, Y+6	; 0x06
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:627
        } else {                                // No more data available
          action = TWI_SCMD_COMPTRANS_gc;         // "Wait for any Start (S/Sr) condition"
        }
      }
    } else {                                  // Master is writing
      uint8_t payload = _data->_module->SDATA;      // reading SDATA will clear the DATA IRQ flag
 5e6:	e0 32       	cpi	r30, 0x20	; 32
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:628
      if ((*rxHead) < BUFFER_LENGTH) {              // make sure that we don't have a buffer overflow in case Master ignores NACK
 5e8:	58 f4       	brcc	.+22     	; 0x600 <__vector_24+0x144>
 5ea:	ec 0f       	add	r30, r28
 5ec:	fd 2f       	mov	r31, r29
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:629
        rxBuffer[(*rxHead)] = payload;              // save data
 5ee:	f1 1d       	adc	r31, r1
 5f0:	85 a7       	std	Z+45, r24	; 0x2d
 5f2:	8e 81       	ldd	r24, Y+6	; 0x06
 5f4:	8f 5f       	subi	r24, 0xFF	; 255
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:630
        (*rxHead)++;                                  // Advance Head
 5f6:	8e 83       	std	Y+6, r24	; 0x06
 5f8:	80 32       	cpi	r24, 0x20	; 32
 5fa:	88 f3       	brcs	.-30     	; 0x5de <__vector_24+0x122>
__vector_24():
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:631
        if ((*rxHead) < BUFFER_LENGTH) {              // if buffer is not yet full
 5fc:	86 e0       	ldi	r24, 0x06	; 6
 5fe:	9f cf       	rjmp	.-194    	; 0x53e <__vector_24+0x82>
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:634
          action = TWI_SCMD_RESPONSE_gc;                // "Execute Acknowledge Action succeeded by reception of next byte"
        } else {                                      // else buffer would overflow with next byte
          action = TWI_ACKACT_bm | TWI_SCMD_COMPTRANS_gc;  // "Execute ACK Action succeeded by waiting for any Start (S/Sr) condition"
 600:	80 e0       	ldi	r24, 0x00	; 0
 602:	9d cf       	rjmp	.-198    	; 0x53e <__vector_24+0x82>

00000604 <main>:
main():
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:563

  #if defined(TWI_MANDS)
    _data->_bools._toggleStreamFn = 0x01;
  #endif

  uint8_t action = 0;
 604:	88 ed       	ldi	r24, 0xD8	; 216
 606:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:1536
    #if (defined(CLOCK_TUNE_INTERNAL))
      tune_internal(); // Will be inlined as only called once. Just too long and ugly to put two implementations in middle of this.
    #else
      #if (F_CPU == 20000000)
        /* No division on clock */
        _PROTECTED_WRITE(CLKCTRL_MCLKCTRLB, 0x00);
 608:	84 bf       	out	0x34, r24	; 52
 60a:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <digital_pin_to_bit_mask+0x7f71e9>
init_ADC0():
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:1651


/********************************* ADC ****************************************/
void __attribute__((weak)) init_ADC0() {
  ADC_t* pADC;
  _fastPtr_d(pADC, &ADC0);
 60e:	e0 e0       	ldi	r30, 0x00	; 0
 610:	f6 e0       	ldi	r31, 0x06	; 6
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:1672
   **************************************************************************/
    //                              30 MHz / 32 = 937 kHz,  32 MHz / 32 =  1 MHz.
    #if   F_CPU   > 24000000     // 24 MHz / 16 = 1.5 MHz,  25 MHz / 32 =  780 kHz
      pADC->CTRLC  = ADC_PRESC_DIV32_gc | ADC_REFSEL_VDDREF_gc | ADC_SAMPCAP_bm;
    #elif F_CPU  >= 12000000    // 16 MHz / 16 = 1.0 MHz,  20 MHz / 16 = 1.25 MHz
      pADC->CTRLC  = ADC_PRESC_DIV16_gc | ADC_REFSEL_VDDREF_gc | ADC_SAMPCAP_bm;
 612:	83 e5       	ldi	r24, 0x53	; 83
 614:	82 83       	std	Z+2, r24	; 0x02
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:1683
      pADC->CTRLC  =  ADC_PRESC_DIV2_gc | ADC_REFSEL_VDDREF_gc | ADC_SAMPCAP_bm;
    #endif
    #if   (F_CPU == 6000000 || F_CPU == 12000000 || F_CPU == 24000000 || F_CPU ==25000000)
      pADC->SAMPCTRL = (7); // 9 ADC clocks, 12 us
    #elif (F_CPU == 5000000 || F_CPU == 10000000 || F_CPU == 20000000)
      pADC->SAMPCTRL = (13);   // 15 ADC clock,s 12 us
 616:	8d e0       	ldi	r24, 0x0D	; 13
 618:	85 83       	std	Z+5, r24	; 0x05
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:1687
    #else
      pADC->SAMPCTRL = (10); // 12 ADC clocks, 12 us
    #endif
    pADC->CTRLD    = ADC_INITDLY_DLY16_gc;
 61a:	80 e2       	ldi	r24, 0x20	; 32
 61c:	83 83       	std	Z+3, r24	; 0x03
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:1688
    pADC->CTRLA    = ADC_ENABLE_bm;
 61e:	81 e0       	ldi	r24, 0x01	; 1
 620:	80 83       	st	Z, r24
init_TCA0():
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:1778

void __attribute__((weak)) init_TCA0() {
  /*  TYPE A TIMER   */
  #if !defined(TCA_BUFFERED_3PIN)
    #if defined(PORTMUX_CTRLC)
      PORTMUX.CTRLC = TCA_PORTMUX;
 622:	10 92 02 02 	sts	0x0202, r1	; 0x800202 <digital_pin_to_bit_mask+0x7f738a>
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:1782
    #else
      PORTMUX.TCAROUTEA = TCA_PORTMUX;
    #endif
    TCA0.SPLIT.CTRLD   = TCA_SPLIT_SPLITM_bm;
 626:	80 93 03 0a 	sts	0x0A03, r24	; 0x800a03 <digital_pin_to_bit_mask+0x7f7b8b>
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:1783
    TCA0.SPLIT.LPER    = PWM_TIMER_PERIOD;
 62a:	9e ef       	ldi	r25, 0xFE	; 254
 62c:	90 93 26 0a 	sts	0x0A26, r25	; 0x800a26 <digital_pin_to_bit_mask+0x7f7bae>
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:1784
    TCA0.SPLIT.HPER    = PWM_TIMER_PERIOD;
 630:	90 93 27 0a 	sts	0x0A27, r25	; 0x800a27 <digital_pin_to_bit_mask+0x7f7baf>
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:1785
    TCA0.SPLIT.CTRLA   = (TIMERA_PRESCALER_bm | TCA_SPLIT_ENABLE_bm);
 634:	9b e0       	ldi	r25, 0x0B	; 11
 636:	90 93 00 0a 	sts	0x0A00, r25	; 0x800a00 <digital_pin_to_bit_mask+0x7f7b88>
init_millis():
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:1427
      #endif
    #elif defined(MILLIS_USE_TIMERA1)
      TCA1.SPLIT.INTCTRL |= TCA_SPLIT_HUNF_bm;
    #elif defined(MILLIS_USE_TIMERD0)
      TCD_t* pTCD;
      _fastPtr_d(pTCD, &TCD0);
 63a:	e0 e8       	ldi	r30, 0x80	; 128
 63c:	fa e0       	ldi	r31, 0x0A	; 10
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:1428
      pTCD->CMPBCLR        = TIME_TRACKING_TIMER_PERIOD; // essentially, this is TOP
 63e:	2d ef       	ldi	r18, 0xFD	; 253
 640:	31 e0       	ldi	r19, 0x01	; 1
 642:	26 a7       	std	Z+46, r18	; 0x2e
 644:	37 a7       	std	Z+47, r19	; 0x2f
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:1429
      pTCD->CTRLB          = 0x00; // oneramp mode
 646:	11 82       	std	Z+1, r1	; 0x01
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:1430
      pTCD->CTRLC          = 0x80;
 648:	90 e8       	ldi	r25, 0x80	; 128
 64a:	92 83       	std	Z+2, r25	; 0x02
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:1431
      pTCD->INTCTRL        = 0x01; // enable interrupt
 64c:	84 87       	std	Z+12, r24	; 0x0c
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:1432
      pTCD->CTRLA          = TIMERD0_PRESCALER | 0x01; // set clock source and enable!
 64e:	81 e1       	ldi	r24, 0x11	; 17
 650:	80 83       	st	Z, r24
main():
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/main.cpp:53
 * just waiting for the DU-series now                                                           */
int main() {
  onBeforeInit(); // Emnpty callback called before init but after the .init stuff. First normal code executed
  init(); // Interrupts are turned on just prior to init() returning.
  initVariant();
  if (!onAfterInit()) sei();  // enable interrupts.
 652:	78 94       	sei
onRequest():
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:963
 *@param      void (*function)(void) - a void returning function that does not accept any parameters
 *
 *@return     void
 */
void TwoWire::onRequest(void (*function)(void)) {
  vars.user_onRequest = function;
 654:	84 e0       	ldi	r24, 0x04	; 4
 656:	91 e0       	ldi	r25, 0x01	; 1
 658:	80 93 1c 38 	sts	0x381C, r24	; 0x80381c <Wire+0x11>
 65c:	90 93 1d 38 	sts	0x381D, r25	; 0x80381d <Wire+0x12>
TWI_SlaveInit():
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:95
  #if defined(TWI_MANDS)                      // Check if the user wants to use Master AND Slave
    if (_data->_bools._clientEnabled  == 1) {  // Master is allowed to be enabled, don't re-enable the client though
      return;
    }
  #else                                         // Master or Slave
    if ((_data->_bools._hostEnabled | _data->_bools._clientEnabled) == 1) {  //If either are enabled
 660:	80 91 15 38 	lds	r24, 0x3815	; 0x803815 <Wire+0xa>
 664:	81 fd       	sbrc	r24, 1
 666:	17 c0       	rjmp	.+46     	; 0x696 <main+0x92>
 668:	82 fd       	sbrc	r24, 2
 66a:	15 c0       	rjmp	.+42     	; 0x696 <main+0x92>
TWI0_ClearPins():
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi_pins.c:140
    #endif
  #elif defined(MEGATINYCORE)  /* tinyAVR 0/1-series */
    #if (MEGATINYCORE_SERIES < 2) // Hey, this erratum isn't listed for the 2-series, so we don't have to do this!
      // 6 bytes of flash saved for 2-series parts, aww yeah!
      #if defined(PORTMUX_TWI0_bm)
        if ((PORTMUX.CTRLB & PORTMUX_TWI0_bm)) {
 66c:	80 91 01 02 	lds	r24, 0x0201	; 0x800201 <digital_pin_to_bit_mask+0x7f7389>
 670:	84 ff       	sbrs	r24, 4
 672:	25 c1       	rjmp	.+586    	; 0x8be <__DATA_REGION_LENGTH__+0xbe>
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi_pins.c:143
          // make sure we don't get errata'ed - make sure their bits in the
          // PORTx.OUT registers are 0.
          PORTA.OUTCLR = 0x06;  // if swapped it's on PA1, PA2
 674:	86 e0       	ldi	r24, 0x06	; 6
 676:	80 93 06 04 	sts	0x0406, r24	; 0x800406 <digital_pin_to_bit_mask+0x7f758e>
TWI_SlaveInit():
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:110
    }
  #else
    TWI0_ClearPins();
  #endif

  _data->_bools._clientEnabled = 1;
 67a:	80 91 15 38 	lds	r24, 0x3815	; 0x803815 <Wire+0xa>
 67e:	84 60       	ori	r24, 0x04	; 4
 680:	80 93 15 38 	sts	0x3815, r24	; 0x803815 <Wire+0xa>
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:111
  _data->_module->SADDR        = (address << 1) | receive_broadcast;
 684:	e0 91 13 38 	lds	r30, 0x3813	; 0x803813 <Wire+0x8>
 688:	f0 91 14 38 	lds	r31, 0x3814	; 0x803814 <Wire+0x9>
 68c:	80 e1       	ldi	r24, 0x10	; 16
 68e:	84 87       	std	Z+12, r24	; 0x0c
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:112
  _data->_module->SADDRMASK    = second_address;
 690:	16 86       	std	Z+14, r1	; 0x0e
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:113
  _data->_module->SCTRLA       = TWI_DIEN_bm | TWI_APIEN_bm | TWI_PIEN_bm  | TWI_ENABLE_bm;
 692:	81 ee       	ldi	r24, 0xE1	; 225
 694:	81 87       	std	Z+9, r24	; 0x09
onReceive():
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:949
 *@param      void (*function)(int) - a void returning function that accepts an int as parameter
 *
 *@return     void
 */
void TwoWire::onReceive(void (*function)(int)) {
  vars.user_onReceive = function;
 696:	89 ec       	ldi	r24, 0xC9	; 201
 698:	91 e0       	ldi	r25, 0x01	; 1
 69a:	80 93 1e 38 	sts	0x381E, r24	; 0x80381e <Wire+0x13>
 69e:	90 93 1f 38 	sts	0x381F, r25	; 0x80381f <Wire+0x14>
setup():
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:69
  //4 - 0xB
  //5 - 0xC
  //6 - 0xD
  Wire.onReceive(receiveEvent); // register event

  pinMode(LED_RED_1,OUTPUT);
 6a2:	8a e0       	ldi	r24, 0x0A	; 10
 6a4:	c1 de       	rcall	.-638    	; 0x428 <pinMode.constprop.11>
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:70
  pinMode(LED_GREEN_1,OUTPUT);
 6a6:	8b e0       	ldi	r24, 0x0B	; 11
 6a8:	bf de       	rcall	.-642    	; 0x428 <pinMode.constprop.11>
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:71
  pinMode(LED_BLUE_1,OUTPUT);
 6aa:	8c e0       	ldi	r24, 0x0C	; 12
 6ac:	bd de       	rcall	.-646    	; 0x428 <pinMode.constprop.11>
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:72
  pinMode(LED_RED_2,OUTPUT);
 6ae:	85 e0       	ldi	r24, 0x05	; 5
 6b0:	bb de       	rcall	.-650    	; 0x428 <pinMode.constprop.11>
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:73
  pinMode(LED_GREEN_2,OUTPUT);
 6b2:	86 e0       	ldi	r24, 0x06	; 6
 6b4:	b9 de       	rcall	.-654    	; 0x428 <pinMode.constprop.11>
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:74
  pinMode(LED_BLUE_2,OUTPUT);
 6b6:	87 e0       	ldi	r24, 0x07	; 7
 6b8:	b7 de       	rcall	.-658    	; 0x428 <pinMode.constprop.11>
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:76
//  
  digitalWrite(LED_RED_1,LOW); 
 6ba:	60 e0       	ldi	r22, 0x00	; 0
 6bc:	8a e0       	ldi	r24, 0x0A	; 10
 6be:	cb dd       	rcall	.-1130   	; 0x256 <digitalWrite>
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:77
  digitalWrite(LED_GREEN_1,HIGH);
 6c0:	61 e0       	ldi	r22, 0x01	; 1
 6c2:	8b e0       	ldi	r24, 0x0B	; 11
 6c4:	c8 dd       	rcall	.-1136   	; 0x256 <digitalWrite>
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:78
  digitalWrite(LED_BLUE_1,HIGH);
 6c6:	61 e0       	ldi	r22, 0x01	; 1
 6c8:	8c e0       	ldi	r24, 0x0C	; 12
 6ca:	c5 dd       	rcall	.-1142   	; 0x256 <digitalWrite>
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:79
  digitalWrite(LED_RED_2,LOW);
 6cc:	60 e0       	ldi	r22, 0x00	; 0
 6ce:	85 e0       	ldi	r24, 0x05	; 5
 6d0:	c2 dd       	rcall	.-1148   	; 0x256 <digitalWrite>
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:80
  digitalWrite(LED_GREEN_2,HIGH);
 6d2:	61 e0       	ldi	r22, 0x01	; 1
 6d4:	86 e0       	ldi	r24, 0x06	; 6
 6d6:	bf dd       	rcall	.-1154   	; 0x256 <digitalWrite>
 6d8:	61 e0       	ldi	r22, 0x01	; 1
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:81
  digitalWrite(LED_BLUE_2,HIGH);
 6da:	87 e0       	ldi	r24, 0x07	; 7
 6dc:	bc dd       	rcall	.-1160   	; 0x256 <digitalWrite>
 6de:	82 e0       	ldi	r24, 0x02	; 2
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:82
  cosine = analogRead(COS_IN)-512 - cosine_off;
 6e0:	8d de       	rcall	.-742    	; 0x3fc <analogRead>
 6e2:	8b 53       	subi	r24, 0x3B	; 59
 6e4:	92 40       	sbci	r25, 0x02	; 2
 6e6:	80 93 68 38 	sts	0x3868, r24	; 0x803868 <cosine>
 6ea:	90 93 69 38 	sts	0x3869, r25	; 0x803869 <cosine+0x1>
 6ee:	83 e0       	ldi	r24, 0x03	; 3
 6f0:	85 de       	rcall	.-758    	; 0x3fc <analogRead>
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:83
  sine = analogRead(SIN_IN)-512 - sine_off;
 6f2:	ec 01       	movw	r28, r24
 6f4:	cf 52       	subi	r28, 0x2F	; 47
 6f6:	d2 40       	sbci	r29, 0x02	; 2
 6f8:	c0 93 66 38 	sts	0x3866, r28	; 0x803866 <sine>
 6fc:	d0 93 67 38 	sts	0x3867, r29	; 0x803867 <sine+0x1>
 700:	60 91 68 38 	lds	r22, 0x3868	; 0x803868 <cosine>
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:84
  current_distance = atan2(sine,cosine)*180/3.14159*1000/360+500;
 704:	70 91 69 38 	lds	r23, 0x3869	; 0x803869 <cosine+0x1>
 708:	07 2e       	mov	r0, r23
 70a:	00 0c       	add	r0, r0
 70c:	88 0b       	sbc	r24, r24
 70e:	99 0b       	sbc	r25, r25
 710:	69 d2       	rcall	.+1234   	; 0xbe4 <__floatsisf>
 712:	6b 01       	movw	r12, r22
 714:	7c 01       	movw	r14, r24
 716:	be 01       	movw	r22, r28
 718:	dd 0f       	add	r29, r29
 71a:	88 0b       	sbc	r24, r24
 71c:	99 0b       	sbc	r25, r25
 71e:	62 d2       	rcall	.+1220   	; 0xbe4 <__floatsisf>
 720:	a7 01       	movw	r20, r14
 722:	96 01       	movw	r18, r12
 724:	71 d1       	rcall	.+738    	; 0xa08 <atan2>
 726:	20 e0       	ldi	r18, 0x00	; 0
 728:	30 e0       	ldi	r19, 0x00	; 0
 72a:	44 e3       	ldi	r20, 0x34	; 52
 72c:	53 e4       	ldi	r21, 0x43	; 67
 72e:	12 d3       	rcall	.+1572   	; 0xd54 <__mulsf3>
 730:	20 ed       	ldi	r18, 0xD0	; 208
 732:	3f e0       	ldi	r19, 0x0F	; 15
 734:	49 e4       	ldi	r20, 0x49	; 73
 736:	50 e4       	ldi	r21, 0x40	; 64
 738:	ba d1       	rcall	.+884    	; 0xaae <__divsf3>
 73a:	20 e0       	ldi	r18, 0x00	; 0
 73c:	30 e0       	ldi	r19, 0x00	; 0
 73e:	4a e7       	ldi	r20, 0x7A	; 122
 740:	54 e4       	ldi	r21, 0x44	; 68
 742:	08 d3       	rcall	.+1552   	; 0xd54 <__mulsf3>
 744:	20 e0       	ldi	r18, 0x00	; 0
 746:	30 e0       	ldi	r19, 0x00	; 0
 748:	44 eb       	ldi	r20, 0xB4	; 180
 74a:	53 e4       	ldi	r21, 0x43	; 67
 74c:	b0 d1       	rcall	.+864    	; 0xaae <__divsf3>
 74e:	20 e0       	ldi	r18, 0x00	; 0
 750:	30 e0       	ldi	r19, 0x00	; 0
 752:	4a ef       	ldi	r20, 0xFA	; 250
 754:	53 e4       	ldi	r21, 0x43	; 67
 756:	e5 d0       	rcall	.+458    	; 0x922 <__addsf3>
 758:	12 d2       	rcall	.+1060   	; 0xb7e <__fixsfsi>
 75a:	60 93 64 38 	sts	0x3864, r22	; 0x803864 <previous_distance>
 75e:	70 93 65 38 	sts	0x3865, r23	; 0x803865 <previous_distance+0x1>
 762:	10 92 60 38 	sts	0x3860, r1	; 0x803860 <absolute_distance>
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:86
  previous_distance = current_distance;
  absolute_distance = current_distance - previous_distance;
 766:	10 92 61 38 	sts	0x3861, r1	; 0x803861 <absolute_distance+0x1>
loop():
 76a:	c8 ee       	ldi	r28, 0xE8	; 232
 76c:	d3 e0       	ldi	r29, 0x03	; 3
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:120
  if (abs(difference) > Switch_Bound)
  {
      // Moving Up
      if (difference < 0)
      {
        absolute_distance += ((Upper_Bound - previous_distance) + (current_distance - Lower_Bound));
 76e:	0e e7       	ldi	r16, 0x7E	; 126
 770:	18 e3       	ldi	r17, 0x38	; 56
 772:	4a e6       	ldi	r20, 0x6A	; 106
 774:	e4 2e       	mov	r14, r20
 776:	48 e3       	ldi	r20, 0x38	; 56
 778:	f4 2e       	mov	r15, r20
 77a:	82 e0       	ldi	r24, 0x02	; 2
 77c:	3f de       	rcall	.-898    	; 0x3fc <analogRead>
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:93

void loop() {

  // Take 10 samples
  for (int i = 0; i < SAMPLE_SIZE; i++) {
    cosineSamples[i] = analogRead(COS_IN) - 512 - cosine_off;
 77e:	8b 53       	subi	r24, 0x3B	; 59
 780:	92 40       	sbci	r25, 0x02	; 2
 782:	f8 01       	movw	r30, r16
 784:	81 93       	st	Z+, r24
 786:	91 93       	st	Z+, r25
 788:	8f 01       	movw	r16, r30
 78a:	83 e0       	ldi	r24, 0x03	; 3
 78c:	37 de       	rcall	.-914    	; 0x3fc <analogRead>
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:94
    sineSamples[i] = analogRead(SIN_IN) - 512 - sine_off;
 78e:	8f 52       	subi	r24, 0x2F	; 47
 790:	92 40       	sbci	r25, 0x02	; 2
 792:	f7 01       	movw	r30, r14
 794:	81 93       	st	Z+, r24
 796:	91 93       	st	Z+, r25
 798:	7f 01       	movw	r14, r30
_delay_us():
 79a:	83 ef       	ldi	r24, 0xF3	; 243
 79c:	91 e0       	ldi	r25, 0x01	; 1
 79e:	01 97       	sbiw	r24, 0x01	; 1
c:\users\asus\appdata\local\arduino15\packages\dxcore\tools\avr-gcc\7.3.0-atmel3.6.1-azduino7b1\avr\include\util/delay.h:276
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 7a0:	f1 f7       	brne	.-4      	; 0x79e <main+0x19a>
 7a2:	00 c0       	rjmp	.+0      	; 0x7a4 <main+0x1a0>
 7a4:	00 00       	nop
loop():
 7a6:	98 e3       	ldi	r25, 0x38	; 56
 7a8:	02 39       	cpi	r16, 0x92	; 146
 7aa:	19 07       	cpc	r17, r25
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:92
}

void loop() {

  // Take 10 samples
  for (int i = 0; i < SAMPLE_SIZE; i++) {
 7ac:	31 f7       	brne	.-52     	; 0x77a <main+0x176>
 7ae:	8e e7       	ldi	r24, 0x7E	; 126
 7b0:	98 e3       	ldi	r25, 0x38	; 56
 7b2:	a3 dc       	rcall	.-1722   	; 0xfa <sortArray(int*, int) [clone .constprop.5]>
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:99
    sineSamples[i] = analogRead(SIN_IN) - 512 - sine_off;
    delayMicroseconds(100); // small delay between readings to allow ADC to stabilize
  }

    // Sort the samples to find the median
  sortArray(cosineSamples, SAMPLE_SIZE);
 7b4:	8a e6       	ldi	r24, 0x6A	; 106
 7b6:	98 e3       	ldi	r25, 0x38	; 56
 7b8:	a0 dc       	rcall	.-1728   	; 0xfa <sortArray(int*, int) [clone .constprop.5]>
calculateMedian():
 7ba:	60 91 86 38 	lds	r22, 0x3886	; 0x803886 <cosineSamples+0x8>
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:100
  sortArray(sineSamples, SAMPLE_SIZE);
 7be:	70 91 87 38 	lds	r23, 0x3887	; 0x803887 <cosineSamples+0x9>
 7c2:	80 91 88 38 	lds	r24, 0x3888	; 0x803888 <cosineSamples+0xa>
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:247

int calculateMedian(int arr[], int size) {
  if (size % 2 != 0)
    return arr[size / 2]; // if size is odd, return the middle number
  else
    return (arr[(size - 1) / 2] + arr[size / 2]) / 2; // if size is even, return the average of the two middle numbers
 7c6:	90 91 89 38 	lds	r25, 0x3889	; 0x803889 <cosineSamples+0xb>
 7ca:	86 0f       	add	r24, r22
 7cc:	97 1f       	adc	r25, r23
 7ce:	97 fd       	sbrc	r25, 7
 7d0:	01 96       	adiw	r24, 0x01	; 1
 7d2:	95 95       	asr	r25
 7d4:	87 95       	ror	r24
loop():
 7d6:	80 93 68 38 	sts	0x3868, r24	; 0x803868 <cosine>
 7da:	90 93 69 38 	sts	0x3869, r25	; 0x803869 <cosine+0x1>
calculateMedian():
 7de:	60 91 72 38 	lds	r22, 0x3872	; 0x803872 <sineSamples+0x8>
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:103
    // Sort the samples to find the median
  sortArray(cosineSamples, SAMPLE_SIZE);
  sortArray(sineSamples, SAMPLE_SIZE);

  // Calculate and print the median
  cosine = calculateMedian(cosineSamples, SAMPLE_SIZE);
 7e2:	70 91 73 38 	lds	r23, 0x3873	; 0x803873 <sineSamples+0x9>
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:247

int calculateMedian(int arr[], int size) {
  if (size % 2 != 0)
    return arr[size / 2]; // if size is odd, return the middle number
  else
    return (arr[(size - 1) / 2] + arr[size / 2]) / 2; // if size is even, return the average of the two middle numbers
 7e6:	20 91 74 38 	lds	r18, 0x3874	; 0x803874 <sineSamples+0xa>
 7ea:	30 91 75 38 	lds	r19, 0x3875	; 0x803875 <sineSamples+0xb>
 7ee:	62 0f       	add	r22, r18
 7f0:	73 1f       	adc	r23, r19
 7f2:	77 ff       	sbrs	r23, 7
 7f4:	02 c0       	rjmp	.+4      	; 0x7fa <main+0x1f6>
 7f6:	6f 5f       	subi	r22, 0xFF	; 255
 7f8:	7f 4f       	sbci	r23, 0xFF	; 255
 7fa:	8b 01       	movw	r16, r22
 7fc:	15 95       	asr	r17
 7fe:	07 95       	ror	r16
loop():
 800:	00 93 66 38 	sts	0x3866, r16	; 0x803866 <sine>
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:104
  sortArray(cosineSamples, SAMPLE_SIZE);
  sortArray(sineSamples, SAMPLE_SIZE);

  // Calculate and print the median
  cosine = calculateMedian(cosineSamples, SAMPLE_SIZE);
  sine = calculateMedian(sineSamples, SAMPLE_SIZE);
 804:	10 93 67 38 	sts	0x3867, r17	; 0x803867 <sine+0x1>
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:107

  
  current_distance = atan2(sine,cosine)*180/3.14159*1000/360+500;
 808:	bc 01       	movw	r22, r24
 80a:	99 0f       	add	r25, r25
 80c:	88 0b       	sbc	r24, r24
 80e:	99 0b       	sbc	r25, r25
 810:	e9 d1       	rcall	.+978    	; 0xbe4 <__floatsisf>
 812:	6b 01       	movw	r12, r22
 814:	7c 01       	movw	r14, r24
 816:	b8 01       	movw	r22, r16
 818:	11 0f       	add	r17, r17
 81a:	88 0b       	sbc	r24, r24
 81c:	99 0b       	sbc	r25, r25
 81e:	e2 d1       	rcall	.+964    	; 0xbe4 <__floatsisf>
 820:	a7 01       	movw	r20, r14
 822:	96 01       	movw	r18, r12
 824:	f1 d0       	rcall	.+482    	; 0xa08 <atan2>
 826:	20 e0       	ldi	r18, 0x00	; 0
 828:	30 e0       	ldi	r19, 0x00	; 0
 82a:	44 e3       	ldi	r20, 0x34	; 52
 82c:	53 e4       	ldi	r21, 0x43	; 67
 82e:	92 d2       	rcall	.+1316   	; 0xd54 <__mulsf3>
 830:	20 ed       	ldi	r18, 0xD0	; 208
 832:	3f e0       	ldi	r19, 0x0F	; 15
 834:	49 e4       	ldi	r20, 0x49	; 73
 836:	50 e4       	ldi	r21, 0x40	; 64
 838:	3a d1       	rcall	.+628    	; 0xaae <__divsf3>
 83a:	20 e0       	ldi	r18, 0x00	; 0
 83c:	30 e0       	ldi	r19, 0x00	; 0
 83e:	4a e7       	ldi	r20, 0x7A	; 122
 840:	54 e4       	ldi	r21, 0x44	; 68
 842:	88 d2       	rcall	.+1296   	; 0xd54 <__mulsf3>
 844:	20 e0       	ldi	r18, 0x00	; 0
 846:	30 e0       	ldi	r19, 0x00	; 0
 848:	44 eb       	ldi	r20, 0xB4	; 180
 84a:	53 e4       	ldi	r21, 0x43	; 67
 84c:	30 d1       	rcall	.+608    	; 0xaae <__divsf3>
 84e:	20 e0       	ldi	r18, 0x00	; 0
 850:	30 e0       	ldi	r19, 0x00	; 0
 852:	4a ef       	ldi	r20, 0xFA	; 250
 854:	53 e4       	ldi	r21, 0x43	; 67
 856:	65 d0       	rcall	.+202    	; 0x922 <__addsf3>
 858:	92 d1       	rcall	.+804    	; 0xb7e <__fixsfsi>
 85a:	6b 01       	movw	r12, r22
 85c:	40 91 64 38 	lds	r20, 0x3864	; 0x803864 <previous_distance>
 860:	50 91 65 38 	lds	r21, 0x3865	; 0x803865 <previous_distance+0x1>
 864:	9b 01       	movw	r18, r22
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:108
  difference = current_distance - previous_distance;
 866:	24 1b       	sub	r18, r20
 868:	35 0b       	sbc	r19, r21
 86a:	80 91 62 38 	lds	r24, 0x3862	; 0x803862 <Lower_Bound>
 86e:	90 91 63 38 	lds	r25, 0x3863	; 0x803863 <Lower_Bound+0x1>
 872:	c8 16       	cp	r12, r24
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:109
  if (current_distance < Lower_Bound)
 874:	d9 06       	cpc	r13, r25
 876:	24 f4       	brge	.+8      	; 0x880 <__DATA_REGION_LENGTH__+0x80>
 878:	c0 92 62 38 	sts	0x3862, r12	; 0x803862 <Lower_Bound>
 87c:	d0 92 63 38 	sts	0x3863, r13	; 0x803863 <Lower_Bound+0x1>
 880:	80 91 60 38 	lds	r24, 0x3860	; 0x803860 <absolute_distance>
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:111
  {
    Lower_Bound = current_distance;
 884:	90 91 61 38 	lds	r25, 0x3861	; 0x803861 <absolute_distance+0x1>
 888:	b9 01       	movw	r22, r18
 88a:	37 ff       	sbrs	r19, 7
 88c:	04 c0       	rjmp	.+8      	; 0x896 <__DATA_REGION_LENGTH__+0x96>
 88e:	66 27       	eor	r22, r22
 890:	77 27       	eor	r23, r23
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:115
  }

  // Detect if distance changes abruptly. means a switch has happened
  if (abs(difference) > Switch_Bound)
 892:	62 1b       	sub	r22, r18
 894:	73 0b       	sbc	r23, r19
 896:	65 3f       	cpi	r22, 0xF5	; 245
 898:	71 40       	sbci	r23, 0x01	; 1
 89a:	74 f0       	brlt	.+28     	; 0x8b8 <__DATA_REGION_LENGTH__+0xb8>
 89c:	60 91 62 38 	lds	r22, 0x3862	; 0x803862 <Lower_Bound>
 8a0:	70 91 63 38 	lds	r23, 0x3863	; 0x803863 <Lower_Bound+0x1>
 8a4:	37 ff       	sbrs	r19, 7
 8a6:	0f c0       	rjmp	.+30     	; 0x8c6 <__DATA_REGION_LENGTH__+0xc6>
 8a8:	9e 01       	movw	r18, r28
 8aa:	24 1b       	sub	r18, r20
 8ac:	35 0b       	sbc	r19, r21
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:118
  {
      // Moving Up
      if (difference < 0)
 8ae:	a6 01       	movw	r20, r12
 8b0:	46 1b       	sub	r20, r22
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:120
      {
        absolute_distance += ((Upper_Bound - previous_distance) + (current_distance - Lower_Bound));
 8b2:	57 0b       	sbc	r21, r23
 8b4:	24 0f       	add	r18, r20
 8b6:	35 1f       	adc	r19, r21
 8b8:	82 0f       	add	r24, r18
 8ba:	93 1f       	adc	r25, r19
 8bc:	0d c0       	rjmp	.+26     	; 0x8d8 <__DATA_REGION_LENGTH__+0xd8>
TWI0_ClearPins():
 8be:	83 e0       	ldi	r24, 0x03	; 3
 8c0:	80 93 26 04 	sts	0x0426, r24	; 0x800426 <digital_pin_to_bit_mask+0x7f75ae>
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:130
        absolute_distance -= ((current_distance - Upper_Bound) + (previous_distance - Lower_Bound));
      }
  }
  else
  {
    absolute_distance += difference;
 8c4:	da ce       	rjmp	.-588    	; 0x67a <main+0x76>
loop():
 8c6:	46 1b       	sub	r20, r22
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi_pins.c:145
        } else {
          PORTB.OUTCLR = 0x03;  // else PB0, PB1
 8c8:	57 0b       	sbc	r21, r23
 8ca:	96 01       	movw	r18, r12
 8cc:	28 5e       	subi	r18, 0xE8	; 232
 8ce:	33 40       	sbci	r19, 0x03	; 3
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:125
        absolute_distance += ((Upper_Bound - previous_distance) + (current_distance - Lower_Bound));
      }
     // Moving Down
      else
      {
        absolute_distance -= ((current_distance - Upper_Bound) + (previous_distance - Lower_Bound));
 8d0:	24 0f       	add	r18, r20
 8d2:	35 1f       	adc	r19, r21
 8d4:	82 1b       	sub	r24, r18
 8d6:	93 0b       	sbc	r25, r19
 8d8:	80 93 60 38 	sts	0x3860, r24	; 0x803860 <absolute_distance>
 8dc:	90 93 61 38 	sts	0x3861, r25	; 0x803861 <absolute_distance+0x1>
 8e0:	c0 92 64 38 	sts	0x3864, r12	; 0x803864 <previous_distance>
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:130
      }
  }
  else
  {
    absolute_distance += difference;
 8e4:	d0 92 65 38 	sts	0x3865, r13	; 0x803865 <previous_distance+0x1>
_delay_us():
 8e8:	83 ef       	ldi	r24, 0xF3	; 243
C:\Users\Asus\AppData\Local\Temp\arduino_compiler\LE_Final/LE_Final.cpp:133
  }

  previous_distance = current_distance;
 8ea:	91 e0       	ldi	r25, 0x01	; 1
 8ec:	01 97       	sbiw	r24, 0x01	; 1
 8ee:	f1 f7       	brne	.-4      	; 0x8ec <__DATA_REGION_LENGTH__+0xec>
 8f0:	00 c0       	rjmp	.+0      	; 0x8f2 <__DATA_REGION_LENGTH__+0xf2>
c:\users\asus\appdata\local\arduino15\packages\dxcore\tools\avr-gcc\7.3.0-atmel3.6.1-azduino7b1\avr\include\util/delay.h:276
 8f2:	00 00       	nop
 8f4:	3c cf       	rjmp	.-392    	; 0x76e <main+0x16a>

000008f6 <_GLOBAL__sub_I__ZN7TwoWireC2EP10TWI_struct>:
_ZN5PrintC2Ev():
 8f6:	eb e0       	ldi	r30, 0x0B	; 11
 8f8:	f8 e3       	ldi	r31, 0x38	; 56
 8fa:	12 82       	std	Z+2, r1	; 0x02
 8fc:	13 82       	std	Z+3, r1	; 0x03
_ZN6StreamC2Ev():
 8fe:	88 ee       	ldi	r24, 0xE8	; 232
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/api/Print.h:42
  protected:
    void setWriteError(int err = 1) {
      write_error = err;
    }
  public:
    Print() : write_error(0) {}
 900:	93 e0       	ldi	r25, 0x03	; 3
 902:	a0 e0       	ldi	r26, 0x00	; 0
 904:	b0 e0       	ldi	r27, 0x00	; 0
 906:	84 83       	std	Z+4, r24	; 0x04
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/api/Stream.h:63
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {
      _timeout = 1000;
 908:	95 83       	std	Z+5, r25	; 0x05
 90a:	a6 83       	std	Z+6, r26	; 0x06
 90c:	b7 83       	std	Z+7, r27	; 0x07
_GLOBAL__sub_I__ZN7TwoWireC2EP10TWI_struct():
 90e:	84 e3       	ldi	r24, 0x34	; 52
 910:	9e e8       	ldi	r25, 0x8E	; 142
 912:	80 83       	st	Z, r24
 914:	91 83       	std	Z+1, r25	; 0x01
 916:	80 e1       	ldi	r24, 0x10	; 16
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:52
 *
 *@param      TWI_t *module - the pointer to the TWI module that the Wire object is supposed to use
 *
 *@return     constructor can't return anything
 */
TwoWire::TwoWire(TWI_t *twi_module) {
 918:	98 e0       	ldi	r25, 0x08	; 8
 91a:	80 87       	std	Z+8, r24	; 0x08
 91c:	91 87       	std	Z+9, r25	; 0x09
 91e:	08 95       	ret

00000920 <__subsf3>:
__subsf3():
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:53
  vars._module = twi_module;
 920:	50 58       	subi	r21, 0x80	; 128

00000922 <__addsf3>:
 922:	bb 27       	eor	r27, r27
 924:	aa 27       	eor	r26, r26
 926:	0e d0       	rcall	.+28     	; 0x944 <__addsf3x>
C:\Users\Asus\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:998
 *  Wire object constructors with the default TWI modules.
 *  If there is absolutely no way to swap the pins physically,
 *  here is the best way to do so in software.
 */
#if defined(TWI0)
  TwoWire Wire(&TWI0);
 928:	d4 c1       	rjmp	.+936    	; 0xcd2 <__fp_round>
__addsf3():
 92a:	c5 d1       	rcall	.+906    	; 0xcb6 <__fp_pscA>
 92c:	30 f0       	brcs	.+12     	; 0x93a <__addsf3+0x18>
 92e:	ca d1       	rcall	.+916    	; 0xcc4 <__fp_pscB>
 930:	20 f0       	brcs	.+8      	; 0x93a <__addsf3+0x18>
 932:	31 f4       	brne	.+12     	; 0x940 <__addsf3+0x1e>
 934:	9f 3f       	cpi	r25, 0xFF	; 255
 936:	11 f4       	brne	.+4      	; 0x93c <__addsf3+0x1a>
 938:	1e f4       	brtc	.+6      	; 0x940 <__addsf3+0x1e>
 93a:	95 c1       	rjmp	.+810    	; 0xc66 <__fp_nan>
 93c:	0e f4       	brtc	.+2      	; 0x940 <__addsf3+0x1e>
 93e:	e0 95       	com	r30
 940:	e7 fb       	bst	r30, 7
 942:	8b c1       	rjmp	.+790    	; 0xc5a <__fp_inf>

00000944 <__addsf3x>:
__addsf3x():
 944:	e9 2f       	mov	r30, r25
 946:	d6 d1       	rcall	.+940    	; 0xcf4 <__fp_split3>
 948:	80 f3       	brcs	.-32     	; 0x92a <__addsf3+0x8>
 94a:	ba 17       	cp	r27, r26
 94c:	62 07       	cpc	r22, r18
 94e:	73 07       	cpc	r23, r19
 950:	84 07       	cpc	r24, r20
 952:	95 07       	cpc	r25, r21
 954:	18 f0       	brcs	.+6      	; 0x95c <__addsf3x+0x18>
 956:	71 f4       	brne	.+28     	; 0x974 <__addsf3x+0x30>
 958:	9e f5       	brtc	.+102    	; 0x9c0 <__addsf3x+0x7c>
 95a:	ee c1       	rjmp	.+988    	; 0xd38 <__fp_zero>
 95c:	0e f4       	brtc	.+2      	; 0x960 <__addsf3x+0x1c>
 95e:	e0 95       	com	r30
 960:	0b 2e       	mov	r0, r27
 962:	ba 2f       	mov	r27, r26
 964:	a0 2d       	mov	r26, r0
 966:	0b 01       	movw	r0, r22
 968:	b9 01       	movw	r22, r18
 96a:	90 01       	movw	r18, r0
 96c:	0c 01       	movw	r0, r24
 96e:	ca 01       	movw	r24, r20
 970:	a0 01       	movw	r20, r0
 972:	11 24       	eor	r1, r1
 974:	ff 27       	eor	r31, r31
 976:	59 1b       	sub	r21, r25
 978:	99 f0       	breq	.+38     	; 0x9a0 <__addsf3x+0x5c>
 97a:	59 3f       	cpi	r21, 0xF9	; 249
 97c:	50 f4       	brcc	.+20     	; 0x992 <__addsf3x+0x4e>
 97e:	50 3e       	cpi	r21, 0xE0	; 224
 980:	68 f1       	brcs	.+90     	; 0x9dc <__addsf3x+0x98>
 982:	1a 16       	cp	r1, r26
 984:	f0 40       	sbci	r31, 0x00	; 0
 986:	a2 2f       	mov	r26, r18
 988:	23 2f       	mov	r18, r19
 98a:	34 2f       	mov	r19, r20
 98c:	44 27       	eor	r20, r20
 98e:	58 5f       	subi	r21, 0xF8	; 248
 990:	f3 cf       	rjmp	.-26     	; 0x978 <__addsf3x+0x34>
 992:	46 95       	lsr	r20
 994:	37 95       	ror	r19
 996:	27 95       	ror	r18
 998:	a7 95       	ror	r26
 99a:	f0 40       	sbci	r31, 0x00	; 0
 99c:	53 95       	inc	r21
 99e:	c9 f7       	brne	.-14     	; 0x992 <__addsf3x+0x4e>
 9a0:	7e f4       	brtc	.+30     	; 0x9c0 <__addsf3x+0x7c>
 9a2:	1f 16       	cp	r1, r31
 9a4:	ba 0b       	sbc	r27, r26
 9a6:	62 0b       	sbc	r22, r18
 9a8:	73 0b       	sbc	r23, r19
 9aa:	84 0b       	sbc	r24, r20
 9ac:	ba f0       	brmi	.+46     	; 0x9dc <__addsf3x+0x98>
 9ae:	91 50       	subi	r25, 0x01	; 1
 9b0:	a1 f0       	breq	.+40     	; 0x9da <__addsf3x+0x96>
 9b2:	ff 0f       	add	r31, r31
 9b4:	bb 1f       	adc	r27, r27
 9b6:	66 1f       	adc	r22, r22
 9b8:	77 1f       	adc	r23, r23
 9ba:	88 1f       	adc	r24, r24
 9bc:	c2 f7       	brpl	.-16     	; 0x9ae <__addsf3x+0x6a>
 9be:	0e c0       	rjmp	.+28     	; 0x9dc <__addsf3x+0x98>
 9c0:	ba 0f       	add	r27, r26
 9c2:	62 1f       	adc	r22, r18
 9c4:	73 1f       	adc	r23, r19
 9c6:	84 1f       	adc	r24, r20
 9c8:	48 f4       	brcc	.+18     	; 0x9dc <__addsf3x+0x98>
 9ca:	87 95       	ror	r24
 9cc:	77 95       	ror	r23
 9ce:	67 95       	ror	r22
 9d0:	b7 95       	ror	r27
 9d2:	f7 95       	ror	r31
 9d4:	9e 3f       	cpi	r25, 0xFE	; 254
 9d6:	08 f0       	brcs	.+2      	; 0x9da <__addsf3x+0x96>
 9d8:	b3 cf       	rjmp	.-154    	; 0x940 <__addsf3+0x1e>
 9da:	93 95       	inc	r25
 9dc:	88 0f       	add	r24, r24
 9de:	08 f0       	brcs	.+2      	; 0x9e2 <__addsf3x+0x9e>
 9e0:	99 27       	eor	r25, r25
 9e2:	ee 0f       	add	r30, r30
 9e4:	97 95       	ror	r25
 9e6:	87 95       	ror	r24
 9e8:	08 95       	ret
 9ea:	65 d1       	rcall	.+714    	; 0xcb6 <__fp_pscA>
 9ec:	58 f0       	brcs	.+22     	; 0xa04 <__addsf3x+0xc0>
 9ee:	80 e8       	ldi	r24, 0x80	; 128
 9f0:	91 e0       	ldi	r25, 0x01	; 1
 9f2:	09 f4       	brne	.+2      	; 0x9f6 <__addsf3x+0xb2>
 9f4:	9e ef       	ldi	r25, 0xFE	; 254
 9f6:	66 d1       	rcall	.+716    	; 0xcc4 <__fp_pscB>
 9f8:	28 f0       	brcs	.+10     	; 0xa04 <__addsf3x+0xc0>
 9fa:	40 e8       	ldi	r20, 0x80	; 128
 9fc:	51 e0       	ldi	r21, 0x01	; 1
 9fe:	59 f4       	brne	.+22     	; 0xa16 <atan2+0xe>
 a00:	5e ef       	ldi	r21, 0xFE	; 254
 a02:	09 c0       	rjmp	.+18     	; 0xa16 <atan2+0xe>
 a04:	30 c1       	rjmp	.+608    	; 0xc66 <__fp_nan>
 a06:	98 c1       	rjmp	.+816    	; 0xd38 <__fp_zero>

00000a08 <atan2>:
 a08:	e9 2f       	mov	r30, r25
 a0a:	e0 78       	andi	r30, 0x80	; 128
 a0c:	73 d1       	rcall	.+742    	; 0xcf4 <__fp_split3>
 a0e:	68 f3       	brcs	.-38     	; 0x9ea <__addsf3x+0xa6>
atan2():
 a10:	09 2e       	mov	r0, r25
 a12:	05 2a       	or	r0, r21
 a14:	c1 f3       	breq	.-16     	; 0xa06 <__addsf3x+0xc2>
 a16:	26 17       	cp	r18, r22
 a18:	37 07       	cpc	r19, r23
 a1a:	48 07       	cpc	r20, r24
 a1c:	59 07       	cpc	r21, r25
 a1e:	38 f0       	brcs	.+14     	; 0xa2e <atan2+0x26>
 a20:	0e 2e       	mov	r0, r30
 a22:	07 f8       	bld	r0, 7
 a24:	e0 25       	eor	r30, r0
 a26:	69 f0       	breq	.+26     	; 0xa42 <atan2+0x3a>
 a28:	e0 25       	eor	r30, r0
 a2a:	e0 64       	ori	r30, 0x40	; 64
 a2c:	0a c0       	rjmp	.+20     	; 0xa42 <atan2+0x3a>
 a2e:	ef 63       	ori	r30, 0x3F	; 63
 a30:	07 f8       	bld	r0, 7
 a32:	00 94       	com	r0
 a34:	07 fa       	bst	r0, 7
 a36:	db 01       	movw	r26, r22
 a38:	b9 01       	movw	r22, r18
 a3a:	9d 01       	movw	r18, r26
 a3c:	dc 01       	movw	r26, r24
 a3e:	ca 01       	movw	r24, r20
 a40:	ad 01       	movw	r20, r26
 a42:	ef 93       	push	r30
 a44:	43 d0       	rcall	.+134    	; 0xacc <__divsf3_pse>
 a46:	45 d1       	rcall	.+650    	; 0xcd2 <__fp_round>
 a48:	0a d0       	rcall	.+20     	; 0xa5e <atan>
 a4a:	5f 91       	pop	r21
 a4c:	55 23       	and	r21, r21
 a4e:	31 f0       	breq	.+12     	; 0xa5c <atan2+0x54>
 a50:	2b ed       	ldi	r18, 0xDB	; 219
 a52:	3f e0       	ldi	r19, 0x0F	; 15
 a54:	49 e4       	ldi	r20, 0x49	; 73
 a56:	50 fd       	sbrc	r21, 0
 a58:	49 ec       	ldi	r20, 0xC9	; 201
 a5a:	63 cf       	rjmp	.-314    	; 0x922 <__addsf3>
 a5c:	08 95       	ret

00000a5e <atan>:
 a5e:	df 93       	push	r29
 a60:	dd 27       	eor	r29, r29
 a62:	b9 2f       	mov	r27, r25
 a64:	bf 77       	andi	r27, 0x7F	; 127
 a66:	40 e8       	ldi	r20, 0x80	; 128
 a68:	5f e3       	ldi	r21, 0x3F	; 63
 a6a:	16 16       	cp	r1, r22
 a6c:	17 06       	cpc	r1, r23
 a6e:	48 07       	cpc	r20, r24
 a70:	5b 07       	cpc	r21, r27
 a72:	10 f4       	brcc	.+4      	; 0xa78 <atan+0x1a>
 a74:	d9 2f       	mov	r29, r25
 a76:	67 d1       	rcall	.+718    	; 0xd46 <inverse>
 a78:	9f 93       	push	r25
 a7a:	8f 93       	push	r24
 a7c:	7f 93       	push	r23
 a7e:	6f 93       	push	r22
 a80:	cc d1       	rcall	.+920    	; 0xe1a <square>
 a82:	ec e7       	ldi	r30, 0x7C	; 124
 a84:	f0 e0       	ldi	r31, 0x00	; 0
 a86:	f2 d0       	rcall	.+484    	; 0xc6c <__fp_powser>
 a88:	24 d1       	rcall	.+584    	; 0xcd2 <__fp_round>
 a8a:	2f 91       	pop	r18
 a8c:	3f 91       	pop	r19
atan():
 a8e:	4f 91       	pop	r20
 a90:	5f 91       	pop	r21
 a92:	6c d1       	rcall	.+728    	; 0xd6c <__mulsf3x>
 a94:	dd 23       	and	r29, r29
 a96:	49 f0       	breq	.+18     	; 0xaaa <atan+0x4c>
 a98:	90 58       	subi	r25, 0x80	; 128
 a9a:	a2 ea       	ldi	r26, 0xA2	; 162
 a9c:	2a ed       	ldi	r18, 0xDA	; 218
 a9e:	3f e0       	ldi	r19, 0x0F	; 15
 aa0:	49 ec       	ldi	r20, 0xC9	; 201
 aa2:	5f e3       	ldi	r21, 0x3F	; 63
 aa4:	d0 78       	andi	r29, 0x80	; 128
 aa6:	5d 27       	eor	r21, r29
 aa8:	4d df       	rcall	.-358    	; 0x944 <__addsf3x>
 aaa:	df 91       	pop	r29
 aac:	12 c1       	rjmp	.+548    	; 0xcd2 <__fp_round>

00000aae <__divsf3>:
__divsf3():
 aae:	0c d0       	rcall	.+24     	; 0xac8 <__divsf3x>
 ab0:	10 c1       	rjmp	.+544    	; 0xcd2 <__fp_round>
 ab2:	08 d1       	rcall	.+528    	; 0xcc4 <__fp_pscB>
 ab4:	40 f0       	brcs	.+16     	; 0xac6 <__divsf3+0x18>
 ab6:	ff d0       	rcall	.+510    	; 0xcb6 <__fp_pscA>
 ab8:	30 f0       	brcs	.+12     	; 0xac6 <__divsf3+0x18>
 aba:	21 f4       	brne	.+8      	; 0xac4 <__divsf3+0x16>
 abc:	5f 3f       	cpi	r21, 0xFF	; 255
 abe:	19 f0       	breq	.+6      	; 0xac6 <__divsf3+0x18>
 ac0:	cc c0       	rjmp	.+408    	; 0xc5a <__fp_inf>
 ac2:	51 11       	cpse	r21, r1
 ac4:	3a c1       	rjmp	.+628    	; 0xd3a <__fp_szero>
 ac6:	cf c0       	rjmp	.+414    	; 0xc66 <__fp_nan>

00000ac8 <__divsf3x>:
__divsf3x():
 ac8:	15 d1       	rcall	.+554    	; 0xcf4 <__fp_split3>
 aca:	98 f3       	brcs	.-26     	; 0xab2 <__divsf3+0x4>

00000acc <__divsf3_pse>:
 acc:	99 23       	and	r25, r25
 ace:	c9 f3       	breq	.-14     	; 0xac2 <__divsf3+0x14>
 ad0:	55 23       	and	r21, r21
 ad2:	b1 f3       	breq	.-20     	; 0xac0 <__divsf3+0x12>
 ad4:	95 1b       	sub	r25, r21
 ad6:	55 0b       	sbc	r21, r21
 ad8:	bb 27       	eor	r27, r27
 ada:	aa 27       	eor	r26, r26
 adc:	62 17       	cp	r22, r18
 ade:	73 07       	cpc	r23, r19
 ae0:	84 07       	cpc	r24, r20
 ae2:	38 f0       	brcs	.+14     	; 0xaf2 <__divsf3_pse+0x26>
 ae4:	9f 5f       	subi	r25, 0xFF	; 255
 ae6:	5f 4f       	sbci	r21, 0xFF	; 255
 ae8:	22 0f       	add	r18, r18
 aea:	33 1f       	adc	r19, r19
 aec:	44 1f       	adc	r20, r20
 aee:	aa 1f       	adc	r26, r26
 af0:	a9 f3       	breq	.-22     	; 0xadc <__divsf3_pse+0x10>
 af2:	33 d0       	rcall	.+102    	; 0xb5a <__divsf3_pse+0x8e>
 af4:	0e 2e       	mov	r0, r30
 af6:	3a f0       	brmi	.+14     	; 0xb06 <__divsf3_pse+0x3a>
 af8:	e0 e8       	ldi	r30, 0x80	; 128
 afa:	30 d0       	rcall	.+96     	; 0xb5c <__divsf3_pse+0x90>
 afc:	91 50       	subi	r25, 0x01	; 1
 afe:	50 40       	sbci	r21, 0x00	; 0
 b00:	e6 95       	lsr	r30
 b02:	00 1c       	adc	r0, r0
 b04:	ca f7       	brpl	.-14     	; 0xaf8 <__divsf3_pse+0x2c>
 b06:	29 d0       	rcall	.+82     	; 0xb5a <__divsf3_pse+0x8e>
 b08:	fe 2f       	mov	r31, r30
 b0a:	27 d0       	rcall	.+78     	; 0xb5a <__divsf3_pse+0x8e>
 b0c:	66 0f       	add	r22, r22
 b0e:	77 1f       	adc	r23, r23
 b10:	88 1f       	adc	r24, r24
 b12:	bb 1f       	adc	r27, r27
 b14:	26 17       	cp	r18, r22
 b16:	37 07       	cpc	r19, r23
 b18:	48 07       	cpc	r20, r24
 b1a:	ab 07       	cpc	r26, r27
 b1c:	b0 e8       	ldi	r27, 0x80	; 128
 b1e:	09 f0       	breq	.+2      	; 0xb22 <__divsf3_pse+0x56>
 b20:	bb 0b       	sbc	r27, r27
 b22:	80 2d       	mov	r24, r0
 b24:	bf 01       	movw	r22, r30
 b26:	ff 27       	eor	r31, r31
 b28:	93 58       	subi	r25, 0x83	; 131
 b2a:	5f 4f       	sbci	r21, 0xFF	; 255
 b2c:	2a f0       	brmi	.+10     	; 0xb38 <__divsf3_pse+0x6c>
 b2e:	9e 3f       	cpi	r25, 0xFE	; 254
 b30:	51 05       	cpc	r21, r1
 b32:	68 f0       	brcs	.+26     	; 0xb4e <__divsf3_pse+0x82>
 b34:	92 c0       	rjmp	.+292    	; 0xc5a <__fp_inf>
 b36:	01 c1       	rjmp	.+514    	; 0xd3a <__fp_szero>
 b38:	5f 3f       	cpi	r21, 0xFF	; 255
 b3a:	ec f3       	brlt	.-6      	; 0xb36 <__divsf3_pse+0x6a>
 b3c:	98 3e       	cpi	r25, 0xE8	; 232
 b3e:	dc f3       	brlt	.-10     	; 0xb36 <__divsf3_pse+0x6a>
 b40:	86 95       	lsr	r24
 b42:	77 95       	ror	r23
 b44:	67 95       	ror	r22
 b46:	b7 95       	ror	r27
 b48:	f7 95       	ror	r31
 b4a:	9f 5f       	subi	r25, 0xFF	; 255
 b4c:	c9 f7       	brne	.-14     	; 0xb40 <__divsf3_pse+0x74>
 b4e:	88 0f       	add	r24, r24
 b50:	91 1d       	adc	r25, r1
 b52:	96 95       	lsr	r25
 b54:	87 95       	ror	r24
 b56:	97 f9       	bld	r25, 7
 b58:	08 95       	ret
 b5a:	e1 e0       	ldi	r30, 0x01	; 1
 b5c:	66 0f       	add	r22, r22
 b5e:	77 1f       	adc	r23, r23
 b60:	88 1f       	adc	r24, r24
 b62:	bb 1f       	adc	r27, r27
 b64:	62 17       	cp	r22, r18
 b66:	73 07       	cpc	r23, r19
 b68:	84 07       	cpc	r24, r20
 b6a:	ba 07       	cpc	r27, r26
 b6c:	20 f0       	brcs	.+8      	; 0xb76 <__divsf3_pse+0xaa>
 b6e:	62 1b       	sub	r22, r18
 b70:	73 0b       	sbc	r23, r19
 b72:	84 0b       	sbc	r24, r20
 b74:	ba 0b       	sbc	r27, r26
 b76:	ee 1f       	adc	r30, r30
 b78:	88 f7       	brcc	.-30     	; 0xb5c <__divsf3_pse+0x90>
 b7a:	e0 95       	com	r30
 b7c:	08 95       	ret

00000b7e <__fixsfsi>:
 b7e:	04 d0       	rcall	.+8      	; 0xb88 <__fixunssfsi>
 b80:	68 94       	set
 b82:	b1 11       	cpse	r27, r1
 b84:	da c0       	rjmp	.+436    	; 0xd3a <__fp_szero>
 b86:	08 95       	ret

00000b88 <__fixunssfsi>:
 b88:	bd d0       	rcall	.+378    	; 0xd04 <__fp_splitA>
 b8a:	88 f0       	brcs	.+34     	; 0xbae <__fixunssfsi+0x26>
 b8c:	9f 57       	subi	r25, 0x7F	; 127
 b8e:	90 f0       	brcs	.+36     	; 0xbb4 <__fixunssfsi+0x2c>
 b90:	b9 2f       	mov	r27, r25
 b92:	99 27       	eor	r25, r25
 b94:	b7 51       	subi	r27, 0x17	; 23
 b96:	a0 f0       	brcs	.+40     	; 0xbc0 <__fixunssfsi+0x38>
 b98:	d1 f0       	breq	.+52     	; 0xbce <__fixunssfsi+0x46>
 b9a:	66 0f       	add	r22, r22
 b9c:	77 1f       	adc	r23, r23
 b9e:	88 1f       	adc	r24, r24
 ba0:	99 1f       	adc	r25, r25
 ba2:	1a f0       	brmi	.+6      	; 0xbaa <__fixunssfsi+0x22>
__fixunssfsi():
 ba4:	ba 95       	dec	r27
 ba6:	c9 f7       	brne	.-14     	; 0xb9a <__fixunssfsi+0x12>
 ba8:	12 c0       	rjmp	.+36     	; 0xbce <__fixunssfsi+0x46>
 baa:	b1 30       	cpi	r27, 0x01	; 1
 bac:	81 f0       	breq	.+32     	; 0xbce <__fixunssfsi+0x46>
 bae:	c4 d0       	rcall	.+392    	; 0xd38 <__fp_zero>
 bb0:	b1 e0       	ldi	r27, 0x01	; 1
 bb2:	08 95       	ret
 bb4:	c1 c0       	rjmp	.+386    	; 0xd38 <__fp_zero>
 bb6:	67 2f       	mov	r22, r23
 bb8:	78 2f       	mov	r23, r24
 bba:	88 27       	eor	r24, r24
 bbc:	b8 5f       	subi	r27, 0xF8	; 248
 bbe:	39 f0       	breq	.+14     	; 0xbce <__fixunssfsi+0x46>
 bc0:	b9 3f       	cpi	r27, 0xF9	; 249
 bc2:	cc f3       	brlt	.-14     	; 0xbb6 <__fixunssfsi+0x2e>
 bc4:	86 95       	lsr	r24
 bc6:	77 95       	ror	r23
 bc8:	67 95       	ror	r22
 bca:	b3 95       	inc	r27
 bcc:	d9 f7       	brne	.-10     	; 0xbc4 <__fixunssfsi+0x3c>
 bce:	3e f4       	brtc	.+14     	; 0xbde <__fixunssfsi+0x56>
 bd0:	90 95       	com	r25
 bd2:	80 95       	com	r24
 bd4:	70 95       	com	r23
 bd6:	61 95       	neg	r22
 bd8:	7f 4f       	sbci	r23, 0xFF	; 255
 bda:	8f 4f       	sbci	r24, 0xFF	; 255
 bdc:	9f 4f       	sbci	r25, 0xFF	; 255
 bde:	08 95       	ret

00000be0 <__floatunsisf>:
__floatunsisf():
 be0:	e8 94       	clt
 be2:	09 c0       	rjmp	.+18     	; 0xbf6 <__floatsisf+0x12>

00000be4 <__floatsisf>:
 be4:	97 fb       	bst	r25, 7
 be6:	3e f4       	brtc	.+14     	; 0xbf6 <__floatsisf+0x12>
 be8:	90 95       	com	r25
 bea:	80 95       	com	r24
 bec:	70 95       	com	r23
 bee:	61 95       	neg	r22
 bf0:	7f 4f       	sbci	r23, 0xFF	; 255
 bf2:	8f 4f       	sbci	r24, 0xFF	; 255
 bf4:	9f 4f       	sbci	r25, 0xFF	; 255
 bf6:	99 23       	and	r25, r25
 bf8:	a9 f0       	breq	.+42     	; 0xc24 <__floatsisf+0x40>
 bfa:	f9 2f       	mov	r31, r25
 bfc:	96 e9       	ldi	r25, 0x96	; 150
 bfe:	bb 27       	eor	r27, r27
 c00:	93 95       	inc	r25
 c02:	f6 95       	lsr	r31
 c04:	87 95       	ror	r24
 c06:	77 95       	ror	r23
 c08:	67 95       	ror	r22
 c0a:	b7 95       	ror	r27
 c0c:	f1 11       	cpse	r31, r1
 c0e:	f8 cf       	rjmp	.-16     	; 0xc00 <__floatsisf+0x1c>
 c10:	fa f4       	brpl	.+62     	; 0xc50 <__floatsisf+0x6c>
 c12:	bb 0f       	add	r27, r27
 c14:	11 f4       	brne	.+4      	; 0xc1a <__floatsisf+0x36>
 c16:	60 ff       	sbrs	r22, 0
 c18:	1b c0       	rjmp	.+54     	; 0xc50 <__floatsisf+0x6c>
 c1a:	6f 5f       	subi	r22, 0xFF	; 255
 c1c:	7f 4f       	sbci	r23, 0xFF	; 255
 c1e:	8f 4f       	sbci	r24, 0xFF	; 255
 c20:	9f 4f       	sbci	r25, 0xFF	; 255
 c22:	16 c0       	rjmp	.+44     	; 0xc50 <__floatsisf+0x6c>
 c24:	88 23       	and	r24, r24
 c26:	11 f0       	breq	.+4      	; 0xc2c <__floatsisf+0x48>
 c28:	96 e9       	ldi	r25, 0x96	; 150
 c2a:	11 c0       	rjmp	.+34     	; 0xc4e <__floatsisf+0x6a>
 c2c:	77 23       	and	r23, r23
 c2e:	21 f0       	breq	.+8      	; 0xc38 <__floatsisf+0x54>
 c30:	9e e8       	ldi	r25, 0x8E	; 142
 c32:	87 2f       	mov	r24, r23
 c34:	76 2f       	mov	r23, r22
 c36:	05 c0       	rjmp	.+10     	; 0xc42 <__floatsisf+0x5e>
 c38:	66 23       	and	r22, r22
 c3a:	71 f0       	breq	.+28     	; 0xc58 <__floatsisf+0x74>
 c3c:	96 e8       	ldi	r25, 0x86	; 134
 c3e:	86 2f       	mov	r24, r22
 c40:	70 e0       	ldi	r23, 0x00	; 0
 c42:	60 e0       	ldi	r22, 0x00	; 0
 c44:	2a f0       	brmi	.+10     	; 0xc50 <__floatsisf+0x6c>
 c46:	9a 95       	dec	r25
 c48:	66 0f       	add	r22, r22
 c4a:	77 1f       	adc	r23, r23
 c4c:	88 1f       	adc	r24, r24
 c4e:	da f7       	brpl	.-10     	; 0xc46 <__floatsisf+0x62>
 c50:	88 0f       	add	r24, r24
 c52:	96 95       	lsr	r25
 c54:	87 95       	ror	r24
 c56:	97 f9       	bld	r25, 7
 c58:	08 95       	ret

00000c5a <__fp_inf>:
__fp_inf():
 c5a:	97 f9       	bld	r25, 7
 c5c:	9f 67       	ori	r25, 0x7F	; 127
 c5e:	80 e8       	ldi	r24, 0x80	; 128
 c60:	70 e0       	ldi	r23, 0x00	; 0
 c62:	60 e0       	ldi	r22, 0x00	; 0
 c64:	08 95       	ret

00000c66 <__fp_nan>:
__fp_nan():
 c66:	9f ef       	ldi	r25, 0xFF	; 255
 c68:	80 ec       	ldi	r24, 0xC0	; 192
 c6a:	08 95       	ret

00000c6c <__fp_powser>:
__fp_powser():
 c6c:	df 93       	push	r29
 c6e:	cf 93       	push	r28
 c70:	1f 93       	push	r17
 c72:	0f 93       	push	r16
 c74:	ff 92       	push	r15
 c76:	ef 92       	push	r14
 c78:	df 92       	push	r13
 c7a:	7b 01       	movw	r14, r22
 c7c:	8c 01       	movw	r16, r24
 c7e:	68 94       	set
 c80:	05 c0       	rjmp	.+10     	; 0xc8c <__fp_powser+0x20>
 c82:	da 2e       	mov	r13, r26
 c84:	ef 01       	movw	r28, r30
 c86:	72 d0       	rcall	.+228    	; 0xd6c <__mulsf3x>
 c88:	fe 01       	movw	r30, r28
 c8a:	e8 94       	clt
 c8c:	a5 91       	lpm	r26, Z+
 c8e:	25 91       	lpm	r18, Z+
 c90:	35 91       	lpm	r19, Z+
 c92:	45 91       	lpm	r20, Z+
 c94:	55 91       	lpm	r21, Z+
 c96:	ae f3       	brts	.-22     	; 0xc82 <__fp_powser+0x16>
 c98:	ef 01       	movw	r28, r30
 c9a:	54 de       	rcall	.-856    	; 0x944 <__addsf3x>
 c9c:	fe 01       	movw	r30, r28
 c9e:	97 01       	movw	r18, r14
 ca0:	a8 01       	movw	r20, r16
 ca2:	da 94       	dec	r13
 ca4:	79 f7       	brne	.-34     	; 0xc84 <__fp_powser+0x18>
 ca6:	df 90       	pop	r13
 ca8:	ef 90       	pop	r14
 caa:	ff 90       	pop	r15
 cac:	0f 91       	pop	r16
 cae:	1f 91       	pop	r17
 cb0:	cf 91       	pop	r28
 cb2:	df 91       	pop	r29
 cb4:	08 95       	ret

00000cb6 <__fp_pscA>:
__fp_pscA():
 cb6:	00 24       	eor	r0, r0
 cb8:	0a 94       	dec	r0
 cba:	16 16       	cp	r1, r22
 cbc:	17 06       	cpc	r1, r23
 cbe:	18 06       	cpc	r1, r24
 cc0:	09 06       	cpc	r0, r25
 cc2:	08 95       	ret

00000cc4 <__fp_pscB>:
__fp_pscB():
 cc4:	00 24       	eor	r0, r0
 cc6:	0a 94       	dec	r0
 cc8:	12 16       	cp	r1, r18
 cca:	13 06       	cpc	r1, r19
 ccc:	14 06       	cpc	r1, r20
 cce:	05 06       	cpc	r0, r21
 cd0:	08 95       	ret

00000cd2 <__fp_round>:
__fp_round():
 cd2:	09 2e       	mov	r0, r25
 cd4:	03 94       	inc	r0
 cd6:	00 0c       	add	r0, r0
 cd8:	11 f4       	brne	.+4      	; 0xcde <__fp_round+0xc>
 cda:	88 23       	and	r24, r24
 cdc:	52 f0       	brmi	.+20     	; 0xcf2 <__fp_round+0x20>
 cde:	bb 0f       	add	r27, r27
 ce0:	40 f4       	brcc	.+16     	; 0xcf2 <__fp_round+0x20>
 ce2:	bf 2b       	or	r27, r31
 ce4:	11 f4       	brne	.+4      	; 0xcea <__fp_round+0x18>
 ce6:	60 ff       	sbrs	r22, 0
 ce8:	04 c0       	rjmp	.+8      	; 0xcf2 <__fp_round+0x20>
 cea:	6f 5f       	subi	r22, 0xFF	; 255
 cec:	7f 4f       	sbci	r23, 0xFF	; 255
 cee:	8f 4f       	sbci	r24, 0xFF	; 255
 cf0:	9f 4f       	sbci	r25, 0xFF	; 255
 cf2:	08 95       	ret

00000cf4 <__fp_split3>:
__fp_split3():
 cf4:	57 fd       	sbrc	r21, 7
 cf6:	90 58       	subi	r25, 0x80	; 128
 cf8:	44 0f       	add	r20, r20
 cfa:	55 1f       	adc	r21, r21
 cfc:	59 f0       	breq	.+22     	; 0xd14 <__fp_splitA+0x10>
 cfe:	5f 3f       	cpi	r21, 0xFF	; 255
 d00:	71 f0       	breq	.+28     	; 0xd1e <__fp_splitA+0x1a>
 d02:	47 95       	ror	r20

00000d04 <__fp_splitA>:
 d04:	88 0f       	add	r24, r24
 d06:	97 fb       	bst	r25, 7
 d08:	99 1f       	adc	r25, r25
 d0a:	61 f0       	breq	.+24     	; 0xd24 <__fp_splitA+0x20>
 d0c:	9f 3f       	cpi	r25, 0xFF	; 255
 d0e:	79 f0       	breq	.+30     	; 0xd2e <__fp_splitA+0x2a>
 d10:	87 95       	ror	r24
 d12:	08 95       	ret
 d14:	12 16       	cp	r1, r18
 d16:	13 06       	cpc	r1, r19
 d18:	14 06       	cpc	r1, r20
 d1a:	55 1f       	adc	r21, r21
 d1c:	f2 cf       	rjmp	.-28     	; 0xd02 <__fp_split3+0xe>
 d1e:	46 95       	lsr	r20
 d20:	f1 df       	rcall	.-30     	; 0xd04 <__fp_splitA>
 d22:	08 c0       	rjmp	.+16     	; 0xd34 <__fp_splitA+0x30>
 d24:	16 16       	cp	r1, r22
 d26:	17 06       	cpc	r1, r23
 d28:	18 06       	cpc	r1, r24
 d2a:	99 1f       	adc	r25, r25
 d2c:	f1 cf       	rjmp	.-30     	; 0xd10 <__fp_splitA+0xc>
 d2e:	86 95       	lsr	r24
 d30:	71 05       	cpc	r23, r1
 d32:	61 05       	cpc	r22, r1
 d34:	08 94       	sec
 d36:	08 95       	ret

00000d38 <__fp_zero>:
__fp_zero():
 d38:	e8 94       	clt

00000d3a <__fp_szero>:
 d3a:	bb 27       	eor	r27, r27
 d3c:	66 27       	eor	r22, r22
 d3e:	77 27       	eor	r23, r23
 d40:	cb 01       	movw	r24, r22
 d42:	97 f9       	bld	r25, 7
 d44:	08 95       	ret

00000d46 <inverse>:
inverse():
 d46:	9b 01       	movw	r18, r22
 d48:	ac 01       	movw	r20, r24
 d4a:	60 e0       	ldi	r22, 0x00	; 0
 d4c:	70 e0       	ldi	r23, 0x00	; 0
 d4e:	80 e8       	ldi	r24, 0x80	; 128
 d50:	9f e3       	ldi	r25, 0x3F	; 63
 d52:	ad ce       	rjmp	.-678    	; 0xaae <__divsf3>

00000d54 <__mulsf3>:
__mulsf3():
 d54:	0b d0       	rcall	.+22     	; 0xd6c <__mulsf3x>
 d56:	bd cf       	rjmp	.-134    	; 0xcd2 <__fp_round>
 d58:	ae df       	rcall	.-164    	; 0xcb6 <__fp_pscA>
 d5a:	28 f0       	brcs	.+10     	; 0xd66 <__mulsf3+0x12>
 d5c:	b3 df       	rcall	.-154    	; 0xcc4 <__fp_pscB>
 d5e:	18 f0       	brcs	.+6      	; 0xd66 <__mulsf3+0x12>
 d60:	95 23       	and	r25, r21
 d62:	09 f0       	breq	.+2      	; 0xd66 <__mulsf3+0x12>
 d64:	7a cf       	rjmp	.-268    	; 0xc5a <__fp_inf>
 d66:	7f cf       	rjmp	.-258    	; 0xc66 <__fp_nan>
 d68:	11 24       	eor	r1, r1
 d6a:	e7 cf       	rjmp	.-50     	; 0xd3a <__fp_szero>

00000d6c <__mulsf3x>:
__mulsf3x():
 d6c:	c3 df       	rcall	.-122    	; 0xcf4 <__fp_split3>
 d6e:	a0 f3       	brcs	.-24     	; 0xd58 <__mulsf3+0x4>

00000d70 <__mulsf3_pse>:
 d70:	95 9f       	mul	r25, r21
 d72:	d1 f3       	breq	.-12     	; 0xd68 <__mulsf3+0x14>
 d74:	95 0f       	add	r25, r21
 d76:	50 e0       	ldi	r21, 0x00	; 0
 d78:	55 1f       	adc	r21, r21
 d7a:	62 9f       	mul	r22, r18
 d7c:	f0 01       	movw	r30, r0
 d7e:	72 9f       	mul	r23, r18
 d80:	bb 27       	eor	r27, r27
 d82:	f0 0d       	add	r31, r0
 d84:	b1 1d       	adc	r27, r1
 d86:	63 9f       	mul	r22, r19
 d88:	aa 27       	eor	r26, r26
 d8a:	f0 0d       	add	r31, r0
 d8c:	b1 1d       	adc	r27, r1
 d8e:	aa 1f       	adc	r26, r26
 d90:	64 9f       	mul	r22, r20
 d92:	66 27       	eor	r22, r22
 d94:	b0 0d       	add	r27, r0
 d96:	a1 1d       	adc	r26, r1
 d98:	66 1f       	adc	r22, r22
 d9a:	82 9f       	mul	r24, r18
 d9c:	22 27       	eor	r18, r18
 d9e:	b0 0d       	add	r27, r0
 da0:	a1 1d       	adc	r26, r1
 da2:	62 1f       	adc	r22, r18
 da4:	73 9f       	mul	r23, r19
 da6:	b0 0d       	add	r27, r0
 da8:	a1 1d       	adc	r26, r1
 daa:	62 1f       	adc	r22, r18
 dac:	83 9f       	mul	r24, r19
 dae:	a0 0d       	add	r26, r0
 db0:	61 1d       	adc	r22, r1
 db2:	22 1f       	adc	r18, r18
 db4:	74 9f       	mul	r23, r20
 db6:	33 27       	eor	r19, r19
 db8:	a0 0d       	add	r26, r0
 dba:	61 1d       	adc	r22, r1
 dbc:	23 1f       	adc	r18, r19
 dbe:	84 9f       	mul	r24, r20
 dc0:	60 0d       	add	r22, r0
 dc2:	21 1d       	adc	r18, r1
 dc4:	82 2f       	mov	r24, r18
 dc6:	76 2f       	mov	r23, r22
 dc8:	6a 2f       	mov	r22, r26
 dca:	11 24       	eor	r1, r1
 dcc:	9f 57       	subi	r25, 0x7F	; 127
 dce:	50 40       	sbci	r21, 0x00	; 0
 dd0:	8a f0       	brmi	.+34     	; 0xdf4 <__mulsf3_pse+0x84>
 dd2:	e1 f0       	breq	.+56     	; 0xe0c <__mulsf3_pse+0x9c>
 dd4:	88 23       	and	r24, r24
 dd6:	4a f0       	brmi	.+18     	; 0xdea <__mulsf3_pse+0x7a>
 dd8:	ee 0f       	add	r30, r30
 dda:	ff 1f       	adc	r31, r31
 ddc:	bb 1f       	adc	r27, r27
 dde:	66 1f       	adc	r22, r22
 de0:	77 1f       	adc	r23, r23
 de2:	88 1f       	adc	r24, r24
 de4:	91 50       	subi	r25, 0x01	; 1
 de6:	50 40       	sbci	r21, 0x00	; 0
 de8:	a9 f7       	brne	.-22     	; 0xdd4 <__mulsf3_pse+0x64>
 dea:	9e 3f       	cpi	r25, 0xFE	; 254
 dec:	51 05       	cpc	r21, r1
 dee:	70 f0       	brcs	.+28     	; 0xe0c <__mulsf3_pse+0x9c>
 df0:	34 cf       	rjmp	.-408    	; 0xc5a <__fp_inf>
 df2:	a3 cf       	rjmp	.-186    	; 0xd3a <__fp_szero>
 df4:	5f 3f       	cpi	r21, 0xFF	; 255
 df6:	ec f3       	brlt	.-6      	; 0xdf2 <__mulsf3_pse+0x82>
 df8:	98 3e       	cpi	r25, 0xE8	; 232
 dfa:	dc f3       	brlt	.-10     	; 0xdf2 <__mulsf3_pse+0x82>
 dfc:	86 95       	lsr	r24
 dfe:	77 95       	ror	r23
 e00:	67 95       	ror	r22
 e02:	b7 95       	ror	r27
 e04:	f7 95       	ror	r31
 e06:	e7 95       	ror	r30
 e08:	9f 5f       	subi	r25, 0xFF	; 255
 e0a:	c1 f7       	brne	.-16     	; 0xdfc <__mulsf3_pse+0x8c>
 e0c:	fe 2b       	or	r31, r30
 e0e:	88 0f       	add	r24, r24
 e10:	91 1d       	adc	r25, r1
 e12:	96 95       	lsr	r25
 e14:	87 95       	ror	r24
 e16:	97 f9       	bld	r25, 7
 e18:	08 95       	ret

00000e1a <square>:
 e1a:	9b 01       	movw	r18, r22
 e1c:	ac 01       	movw	r20, r24
 e1e:	9a cf       	rjmp	.-204    	; 0xd54 <__mulsf3>

00000e20 <__tablejump2__>:
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2296
 e20:	ee 0f       	add	r30, r30
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2297
 e22:	ff 1f       	adc	r31, r31
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2328
 e24:	05 90       	lpm	r0, Z+
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2329
 e26:	f4 91       	lpm	r31, Z
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2330
 e28:	e0 2d       	mov	r30, r0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2331
 e2a:	09 94       	ijmp

00000e2c <_exit>:
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
 e2c:	f8 94       	cli

00000e2e <__stop_program>:
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
 e2e:	ff cf       	rjmp	.-2      	; 0xe2e <__stop_program>
