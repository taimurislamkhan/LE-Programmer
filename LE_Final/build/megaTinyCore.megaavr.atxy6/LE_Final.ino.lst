
C:\Users\taimu\AppData\Local\Temp\arduino\sketches\39D7011E97487CFC5F1A58525AF8CEC2/LE_Final.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
../../../../crt1/gcrt1.S:61
   0:	55 c0       	rjmp	.+170    	; 0xac <__ctors_end>
   2:	00 00       	nop
../../../../crt1/gcrt1.S:67
   4:	79 c0       	rjmp	.+242    	; 0xf8 <__bad_interrupt>
   6:	00 00       	nop
../../../../crt1/gcrt1.S:68
   8:	77 c0       	rjmp	.+238    	; 0xf8 <__bad_interrupt>
   a:	00 00       	nop
../../../../crt1/gcrt1.S:69
   c:	75 c0       	rjmp	.+234    	; 0xf8 <__bad_interrupt>
   e:	00 00       	nop
../../../../crt1/gcrt1.S:70
  10:	73 c0       	rjmp	.+230    	; 0xf8 <__bad_interrupt>
  12:	00 00       	nop
../../../../crt1/gcrt1.S:71
  14:	71 c0       	rjmp	.+226    	; 0xf8 <__bad_interrupt>
  16:	00 00       	nop
../../../../crt1/gcrt1.S:72
  18:	6f c0       	rjmp	.+222    	; 0xf8 <__bad_interrupt>
  1a:	00 00       	nop
../../../../crt1/gcrt1.S:73
  1c:	6d c0       	rjmp	.+218    	; 0xf8 <__bad_interrupt>
  1e:	00 00       	nop
../../../../crt1/gcrt1.S:74
  20:	6b c0       	rjmp	.+214    	; 0xf8 <__bad_interrupt>
  22:	00 00       	nop
../../../../crt1/gcrt1.S:75
  24:	69 c0       	rjmp	.+210    	; 0xf8 <__bad_interrupt>
  26:	00 00       	nop
../../../../crt1/gcrt1.S:76
  28:	67 c0       	rjmp	.+206    	; 0xf8 <__bad_interrupt>
  2a:	00 00       	nop
../../../../crt1/gcrt1.S:77
  2c:	65 c0       	rjmp	.+202    	; 0xf8 <__bad_interrupt>
  2e:	00 00       	nop
../../../../crt1/gcrt1.S:78
  30:	63 c0       	rjmp	.+198    	; 0xf8 <__bad_interrupt>
  32:	00 00       	nop
../../../../crt1/gcrt1.S:79
  34:	61 c0       	rjmp	.+194    	; 0xf8 <__bad_interrupt>
  36:	00 00       	nop
../../../../crt1/gcrt1.S:80
  38:	5f c0       	rjmp	.+190    	; 0xf8 <__bad_interrupt>
  3a:	00 00       	nop
../../../../crt1/gcrt1.S:81
  3c:	10 c2       	rjmp	.+1056   	; 0x45e <__vector_15>
  3e:	00 00       	nop
../../../../crt1/gcrt1.S:82
  40:	5b c0       	rjmp	.+182    	; 0xf8 <__bad_interrupt>
  42:	00 00       	nop
../../../../crt1/gcrt1.S:83
  44:	59 c0       	rjmp	.+178    	; 0xf8 <__bad_interrupt>
  46:	00 00       	nop
../../../../crt1/gcrt1.S:84
  48:	57 c0       	rjmp	.+174    	; 0xf8 <__bad_interrupt>
  4a:	00 00       	nop
../../../../crt1/gcrt1.S:85
  4c:	55 c0       	rjmp	.+170    	; 0xf8 <__bad_interrupt>
  4e:	00 00       	nop
../../../../crt1/gcrt1.S:86
  50:	53 c0       	rjmp	.+166    	; 0xf8 <__bad_interrupt>
  52:	00 00       	nop
../../../../crt1/gcrt1.S:87
  54:	51 c0       	rjmp	.+162    	; 0xf8 <__bad_interrupt>
  56:	00 00       	nop
../../../../crt1/gcrt1.S:88
  58:	4f c0       	rjmp	.+158    	; 0xf8 <__bad_interrupt>
  5a:	00 00       	nop
../../../../crt1/gcrt1.S:89
  5c:	4d c0       	rjmp	.+154    	; 0xf8 <__bad_interrupt>
  5e:	00 00       	nop
../../../../crt1/gcrt1.S:90
  60:	2d c2       	rjmp	.+1114   	; 0x4bc <__vector_24>
  62:	00 00       	nop
../../../../crt1/gcrt1.S:91
  64:	49 c0       	rjmp	.+146    	; 0xf8 <__bad_interrupt>
  66:	00 00       	nop
../../../../crt1/gcrt1.S:92
  68:	47 c0       	rjmp	.+142    	; 0xf8 <__bad_interrupt>
  6a:	00 00       	nop
../../../../crt1/gcrt1.S:93
  6c:	45 c0       	rjmp	.+138    	; 0xf8 <__bad_interrupt>
  6e:	00 00       	nop
../../../../crt1/gcrt1.S:94
  70:	43 c0       	rjmp	.+134    	; 0xf8 <__bad_interrupt>
  72:	00 00       	nop
../../../../crt1/gcrt1.S:95
  74:	41 c0       	rjmp	.+130    	; 0xf8 <__bad_interrupt>
  76:	00 00       	nop
../../../../crt1/gcrt1.S:96
  78:	3f c0       	rjmp	.+126    	; 0xf8 <__bad_interrupt>
  7a:	00 00       	nop
  7c:	08 4a       	sbci	r16, 0xA8	; 168
  7e:	d7 3b       	cpi	r29, 0xB7	; 183
  80:	3b ce       	rjmp	.-906    	; 0xfffffcf8 <__eeprom_end+0xff7efcf8>
  82:	01 6e       	ori	r16, 0xE1	; 225
  84:	84 bc       	out	0x24, r8	; 36
  86:	bf fd       	.word	0xfdbf	; ????
  88:	c1 2f       	mov	r28, r17
  8a:	3d 6c       	ori	r19, 0xCD	; 205
  8c:	74 31       	cpi	r23, 0x14	; 20
  8e:	9a bd       	out	0x2a, r25	; 42
  90:	56 83       	std	Z+6, r21	; 0x06
  92:	3d da       	rcall	.-2950   	; 0xfffff50e <__eeprom_end+0xff7ef50e>
  94:	3d 00       	.word	0x003d	; ????
  96:	c7 7f       	andi	r28, 0xF7	; 247
  98:	11 be       	out	0x31, r1	; 49
  9a:	d9 e4       	ldi	r29, 0x49	; 73
  9c:	bb 4c       	sbci	r27, 0xCB	; 203
  9e:	3e 91       	ld	r19, -X
  a0:	6b aa       	std	Y+51, r6	; 0x33
  a2:	aa be       	out	0x3a, r10	; 58
  a4:	00 00       	nop
  a6:	00 80       	ld	r0, Z
  a8:	3f 00       	.word	0x003f	; ????

000000aa <__ctors_start>:
__trampolines_start():
  aa:	77 04       	cpc	r7, r7

000000ac <__ctors_end>:
__dtors_end():
../../../../crt1/gcrt1.S:230
  ac:	11 24       	eor	r1, r1
../../../../crt1/gcrt1.S:231
  ae:	1f be       	out	0x3f, r1	; 63
../../../../crt1/gcrt1.S:232
  b0:	cf ef       	ldi	r28, 0xFF	; 255
../../../../crt1/gcrt1.S:234
  b2:	cd bf       	out	0x3d, r28	; 61
../../../../crt1/gcrt1.S:236
  b4:	df e3       	ldi	r29, 0x3F	; 63
../../../../crt1/gcrt1.S:237
  b6:	de bf       	out	0x3e, r29	; 62

000000b8 <_initThreeStuff()>:
_Z15_initThreeStuffv():
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/main.cpp:104

  /* Minimum: Reset if we wound up here through malfunction - this relies on user clearing the  *
   * register on startup, which is rarely done in Arduino land.                                 */
  void __attribute__((weak)) init_reset_flags() ;
  void __attribute__((weak)) init_reset_flags() {
    uint8_t flags = RSTCTRL.RSTFR;
  b8:	80 91 40 00 	lds	r24, 0x0040	; 0x800040 <digital_pin_to_bit_mask+0x7f71d0>
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/main.cpp:105
    RSTCTRL.RSTFR = flags;
  bc:	80 93 40 00 	sts	0x0040, r24	; 0x800040 <digital_pin_to_bit_mask+0x7f71d0>
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/main.cpp:106
    if (flags == 0) {
  c0:	81 11       	cpse	r24, r1
  c2:	05 c0       	rjmp	.+10     	; 0xce <_initThreeStuff()+0x16>
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/main.cpp:107
      _PROTECTED_WRITE(RSTCTRL.SWRR, 1);
  c4:	98 ed       	ldi	r25, 0xD8	; 216
  c6:	21 e0       	ldi	r18, 0x01	; 1
  c8:	94 bf       	out	0x34, r25	; 52
  ca:	20 93 41 00 	sts	0x0041, r18	; 0x800041 <digital_pin_to_bit_mask+0x7f71d1>
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/main.cpp:109
    }
    GPIOR0 = flags;
  ce:	8c bb       	out	0x1c, r24	; 28

000000d0 <__do_clear_bss>:
__do_clear_bss():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
  d0:	28 e3       	ldi	r18, 0x38	; 56
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
  d2:	a0 e0       	ldi	r26, 0x00	; 0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
  d4:	b8 e3       	ldi	r27, 0x38	; 56
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
  d6:	01 c0       	rjmp	.+2      	; 0xda <.do_clear_bss_start>

000000d8 <.do_clear_bss_loop>:
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
  d8:	1d 92       	st	X+, r1

000000da <.do_clear_bss_start>:
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
  da:	ac 39       	cpi	r26, 0x9C	; 156
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
  dc:	b2 07       	cpc	r27, r18
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
  de:	e1 f7       	brne	.-8      	; 0xd8 <.do_clear_bss_loop>

000000e0 <__do_global_ctors>:
__do_global_ctors():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2466
  e0:	10 e0       	ldi	r17, 0x00	; 0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2467
  e2:	c6 e5       	ldi	r28, 0x56	; 86
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2468
  e4:	d0 e0       	ldi	r29, 0x00	; 0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2472
  e6:	03 c0       	rjmp	.+6      	; 0xee <__do_global_ctors+0xe>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2474
  e8:	21 97       	sbiw	r28, 0x01	; 1
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2480
  ea:	fe 01       	movw	r30, r28
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2481
  ec:	95 d6       	rcall	.+3370   	; 0xe18 <__tablejump2__>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2483
  ee:	c5 35       	cpi	r28, 0x55	; 85
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2484
  f0:	d1 07       	cpc	r29, r17
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2489
  f2:	d1 f7       	brne	.-12     	; 0xe8 <__do_global_ctors+0x8>
../../../../crt1/gcrt1.S:314
  f4:	87 d2       	rcall	.+1294   	; 0x604 <main>
../../../../crt1/gcrt1.S:315
  f6:	96 c6       	rjmp	.+3372   	; 0xe24 <_exit>

000000f8 <__bad_interrupt>:
__vector_22():
  f8:	83 cf       	rjmp	.-250    	; 0x0 <__vectors>

000000fa <sortArray(int*, int) [clone .constprop.5]>:
_Z9sortArrayPii.constprop.5():
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:218
      set_RGB(c);
    }
  }
}

void sortArray(int arr[], int size) {
  fa:	29 e0       	ldi	r18, 0x09	; 9
  fc:	30 e0       	ldi	r19, 0x00	; 0
  fe:	fc 01       	movw	r30, r24
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:220
  for (int i = 0; i < size - 1; i++) {
    for (int j = 0; j < size - i - 1; j++) {
 100:	50 e0       	ldi	r21, 0x00	; 0
 102:	40 e0       	ldi	r20, 0x00	; 0
 104:	42 17       	cp	r20, r18
 106:	53 07       	cpc	r21, r19
 108:	7c f4       	brge	.+30     	; 0x128 <__EEPROM_REGION_LENGTH__+0x28>
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:221
      if (arr[j] > arr[j + 1]) {
 10a:	60 81       	ld	r22, Z
 10c:	71 81       	ldd	r23, Z+1	; 0x01
 10e:	a2 81       	ldd	r26, Z+2	; 0x02
 110:	b3 81       	ldd	r27, Z+3	; 0x03
 112:	a6 17       	cp	r26, r22
 114:	b7 07       	cpc	r27, r23
 116:	24 f4       	brge	.+8      	; 0x120 <__EEPROM_REGION_LENGTH__+0x20>
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:223
        int temp = arr[j];
        arr[j] = arr[j + 1];
 118:	a0 83       	st	Z, r26
 11a:	b1 83       	std	Z+1, r27	; 0x01
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:224
        arr[j + 1] = temp;
 11c:	62 83       	std	Z+2, r22	; 0x02
 11e:	73 83       	std	Z+3, r23	; 0x03
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:220
  }
}

void sortArray(int arr[], int size) {
  for (int i = 0; i < size - 1; i++) {
    for (int j = 0; j < size - i - 1; j++) {
 120:	4f 5f       	subi	r20, 0xFF	; 255
 122:	5f 4f       	sbci	r21, 0xFF	; 255
 124:	32 96       	adiw	r30, 0x02	; 2
 126:	ee cf       	rjmp	.-36     	; 0x104 <__EEPROM_REGION_LENGTH__+0x4>
 128:	21 50       	subi	r18, 0x01	; 1
 12a:	31 09       	sbc	r19, r1
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:219
    }
  }
}

void sortArray(int arr[], int size) {
  for (int i = 0; i < size - 1; i++) {
 12c:	41 f7       	brne	.-48     	; 0xfe <sortArray(int*, int) [clone .constprop.5]+0x4>
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:228
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
      }
    }
  }
}
 12e:	08 95       	ret

00000130 <TwoWire::flush()>:
_ZN7TwoWire5flushEv():
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:139
    _data->_module->SCTRLA  = 0x00;
    _data->_module->MCTRLA  = temp_MCTRLA;
    _data->_module->MSTATUS = 0x01;  // force TWI state machine into idle state
    _data->_module->SCTRLA  = temp_SCTRLA;
  #else
  _data->_module->MCTRLB |= TWI_FLUSH_bm;
 130:	dc 01       	movw	r26, r24
 132:	18 96       	adiw	r26, 0x08	; 8
 134:	ed 91       	ld	r30, X+
 136:	fc 91       	ld	r31, X
 138:	84 81       	ldd	r24, Z+4	; 0x04
 13a:	88 60       	ori	r24, 0x08	; 8
 13c:	84 83       	std	Z+4, r24	; 0x04
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:748
 *@return     void
 */
void TwoWire::flush(void) {
  /* Turn off and on TWI module */
  TWI_Flush(&vars);
}
 13e:	08 95       	ret

00000140 <TwoWire::peek()>:
_ZN7TwoWire4peekEv():
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:726
      rxTail   = &(vars._bytesReadWritten);
      rxBuffer =   vars._trBuffer;
    #else                                        // Separate tx/rx Buffers
      rxHead   = &(vars._bytesToRead);
      rxTail   = &(vars._bytesRead);
      rxBuffer =   vars._rxBuffer;
 140:	9c 01       	movw	r18, r24
 142:	2b 5c       	subi	r18, 0xCB	; 203
 144:	3f 4f       	sbci	r19, 0xFF	; 255
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:730
    #endif
  }

  if ((*rxTail) < (*rxHead)) {   // if there are bytes to read
 146:	dc 01       	movw	r26, r24
 148:	1f 96       	adiw	r26, 0x0f	; 15
 14a:	ec 91       	ld	r30, X
 14c:	1f 97       	sbiw	r26, 0x0f	; 15
 14e:	1e 96       	adiw	r26, 0x0e	; 14
 150:	8c 91       	ld	r24, X
 152:	e8 17       	cp	r30, r24
 154:	30 f4       	brcc	.+12     	; 0x162 <TwoWire::peek()+0x22>
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:731
    return rxBuffer[(*rxTail)];
 156:	e2 0f       	add	r30, r18
 158:	f3 2f       	mov	r31, r19
 15a:	f1 1d       	adc	r31, r1
 15c:	80 81       	ld	r24, Z
 15e:	90 e0       	ldi	r25, 0x00	; 0
 160:	08 95       	ret
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:733
  } else {      // No bytes to read
    return -1;
 162:	8f ef       	ldi	r24, 0xFF	; 255
 164:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:735
  }
}
 166:	08 95       	ret

00000168 <TwoWire::read()>:
_ZN7TwoWire4readEv():
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:635
 *@param      void
 *
 *@return     int
 *@retval     byte in the buffer or -1 if buffer is empty
 */
int TwoWire::read(void) {
 168:	fc 01       	movw	r30, r24
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:653
      rxTail   = &(vars._bytesReadWritten);
      rxBuffer =   vars._trBuffer;
    #else                                        // Separate tx/rx Buffers
      rxHead   = &(vars._bytesToRead);
      rxTail   = &(vars._bytesRead);
      rxBuffer =   vars._rxBuffer;
 16a:	dc 01       	movw	r26, r24
 16c:	d5 96       	adiw	r26, 0x35	; 53
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:658
    #endif
  }


  if ((*rxTail) < (*rxHead)) {   // if there are bytes to read
 16e:	97 85       	ldd	r25, Z+15	; 0x0f
 170:	86 85       	ldd	r24, Z+14	; 0x0e
 172:	98 17       	cp	r25, r24
 174:	40 f4       	brcc	.+16     	; 0x186 <TwoWire::read()+0x1e>
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:659
    uint8_t c = rxBuffer[(*rxTail)];
 176:	a9 0f       	add	r26, r25
 178:	b1 1d       	adc	r27, r1
 17a:	2c 91       	ld	r18, X
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:660
    (*rxTail)++;
 17c:	9f 5f       	subi	r25, 0xFF	; 255
 17e:	97 87       	std	Z+15, r25	; 0x0f
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:661
    return c;
 180:	82 2f       	mov	r24, r18
 182:	90 e0       	ldi	r25, 0x00	; 0
 184:	08 95       	ret
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:663
  } else {                      // No bytes to read. At this point, rxTail moved up to
    return -1;                  // rxHead. To reset both to 0, a MasterRead or AddrWrite has to be called
 186:	8f ef       	ldi	r24, 0xFF	; 255
 188:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:665
  }
}
 18a:	08 95       	ret

0000018c <TwoWire::available()>:
_ZN7TwoWire9availableEv():
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:603
 *@param      void
 *
 *@return     int
 *@retval     amount of bytes available to read from the host buffer
 */
int TwoWire::available(void) {
 18c:	fc 01       	movw	r30, r24
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:614
  #endif
  {
    #if defined(TWI_MERGE_BUFFERS)                // Same Buffers for tx/rx
      rxHead  = vars._bytesToReadWrite - vars._bytesReadWritten;
    #else                                         // Separate tx/rx Buffers
      rxHead  = vars._bytesToRead - vars._bytesRead;
 18e:	86 85       	ldd	r24, Z+14	; 0x0e
 190:	97 85       	ldd	r25, Z+15	; 0x0f
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:618
    #endif
  }
  return rxHead;
}
 192:	89 1b       	sub	r24, r25
 194:	99 0b       	sbc	r25, r25
 196:	08 95       	ret

00000198 <TwoWire::write(unsigned char)>:
_ZN7TwoWire5writeEh():
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:536
 *
 *
 *@return     uint8_t
 *@retval     1 if successful, 0 if the buffer is full
 */
size_t TwoWire::write(uint8_t data) {
 198:	fc 01       	movw	r30, r24
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:557
    #endif
  }

  /* Put byte in txBuffer */

  if ((*txHead) < BUFFER_LENGTH) {      // while buffer not full, write to it
 19a:	a5 85       	ldd	r26, Z+13	; 0x0d
 19c:	a0 32       	cpi	r26, 0x20	; 32
 19e:	58 f4       	brcc	.+22     	; 0x1b6 <TwoWire::write(unsigned char)+0x1e>
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:558
    txBuffer[(*txHead)] = data;             // Load data into the buffer
 1a0:	a8 0f       	add	r26, r24
 1a2:	b9 2f       	mov	r27, r25
 1a4:	b1 1d       	adc	r27, r1
 1a6:	55 96       	adiw	r26, 0x15	; 21
 1a8:	6c 93       	st	X, r22
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:559
    (*txHead)++;                            // advancing the head
 1aa:	85 85       	ldd	r24, Z+13	; 0x0d
 1ac:	8f 5f       	subi	r24, 0xFF	; 255
 1ae:	85 87       	std	Z+13, r24	; 0x0d
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:560
    return 1;
 1b0:	81 e0       	ldi	r24, 0x01	; 1
 1b2:	90 e0       	ldi	r25, 0x00	; 0
 1b4:	08 95       	ret
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:562
  } else {
    return 0;
 1b6:	90 e0       	ldi	r25, 0x00	; 0
 1b8:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:564
  }
}
 1ba:	08 95       	ret

000001bc <TwoWire::write(unsigned char const*, unsigned int)>:
_ZN7TwoWire5writeEPKhj():
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:579
 *
 *
 *@return     uint8_t
 *@retval     amount of bytes copied
 */
size_t TwoWire::write(const uint8_t *data, size_t quantity) {
 1bc:	bf 92       	push	r11
 1be:	cf 92       	push	r12
 1c0:	df 92       	push	r13
 1c2:	ef 92       	push	r14
 1c4:	ff 92       	push	r15
 1c6:	0f 93       	push	r16
 1c8:	1f 93       	push	r17
 1ca:	cf 93       	push	r28
 1cc:	df 93       	push	r29
 1ce:	7c 01       	movw	r14, r24
 1d0:	6a 01       	movw	r12, r20
 1d2:	b6 2e       	mov	r11, r22
 1d4:	eb 01       	movw	r28, r22
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:581
  twi_buffer_index_t i = 0;
  for (; i < quantity; i++) {
 1d6:	0c 2f       	mov	r16, r28
 1d8:	0b 19       	sub	r16, r11
 1da:	10 e0       	ldi	r17, 0x00	; 0
 1dc:	0c 15       	cp	r16, r12
 1de:	1d 05       	cpc	r17, r13
 1e0:	28 f4       	brcc	.+10     	; 0x1ec <TwoWire::write(unsigned char const*, unsigned int)+0x30>
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:582
    if (TwoWire::write(*(data++)) == 0)
 1e2:	69 91       	ld	r22, Y+
 1e4:	c7 01       	movw	r24, r14
 1e6:	d8 df       	rcall	.-80     	; 0x198 <TwoWire::write(unsigned char)>
 1e8:	89 2b       	or	r24, r25
 1ea:	a9 f7       	brne	.-22     	; 0x1d6 <TwoWire::write(unsigned char const*, unsigned int)+0x1a>
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:587
      break;   // break if buffer full
  }

  return i;
}
 1ec:	c8 01       	movw	r24, r16
 1ee:	df 91       	pop	r29
 1f0:	cf 91       	pop	r28
 1f2:	1f 91       	pop	r17
 1f4:	0f 91       	pop	r16
 1f6:	ff 90       	pop	r15
 1f8:	ef 90       	pop	r14
 1fa:	df 90       	pop	r13
 1fc:	cf 90       	pop	r12
 1fe:	bf 90       	pop	r11
 200:	08 95       	ret

00000202 <Print::availableForWrite()>:
_ZN5Print17availableForWriteEv():
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/api/Print.h:65
      return write((const uint8_t *)buffer, size);
    }

    // default to zero, meaning "a single write may block"
    // should be overridden by subclasses with buffering
    virtual int availableForWrite() { return 0; }
 202:	90 e0       	ldi	r25, 0x00	; 0
 204:	80 e0       	ldi	r24, 0x00	; 0
 206:	08 95       	ret

00000208 <transmitDataWire()>:
_Z16transmitDataWirev():
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:189
      set_RGB_off();
    default:
      set_RGB_off();      
  }
}
void transmitDataWire() {
 208:	cf 93       	push	r28
 20a:	df 93       	push	r29
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:191
  
  temp[0] = (absolute_distance >> 8) & 0xFF;
 20c:	80 91 60 38 	lds	r24, 0x3860	; 0x803860 <absolute_distance>
 210:	90 91 61 38 	lds	r25, 0x3861	; 0x803861 <absolute_distance+0x1>
 214:	90 93 00 38 	sts	0x3800, r25	; 0x803800 <__DATA_REGION_ORIGIN__>
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:192
  temp[1] = absolute_distance & 0xFF;
 218:	80 93 01 38 	sts	0x3801, r24	; 0x803801 <__DATA_REGION_ORIGIN__+0x1>
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:193
  temp[2] = (cosine >> 8) & 0xFF;
 21c:	80 91 68 38 	lds	r24, 0x3868	; 0x803868 <cosine>
 220:	90 91 69 38 	lds	r25, 0x3869	; 0x803869 <cosine+0x1>
 224:	90 93 02 38 	sts	0x3802, r25	; 0x803802 <__DATA_REGION_ORIGIN__+0x2>
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:194
  temp[3] = cosine & 0xFF;
 228:	80 93 03 38 	sts	0x3803, r24	; 0x803803 <__DATA_REGION_ORIGIN__+0x3>
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:195
  temp[4] = (sine >> 8) & 0xFF;
 22c:	80 91 66 38 	lds	r24, 0x3866	; 0x803866 <sine>
 230:	90 91 67 38 	lds	r25, 0x3867	; 0x803867 <sine+0x1>
 234:	90 93 04 38 	sts	0x3804, r25	; 0x803804 <__DATA_REGION_ORIGIN__+0x4>
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:196
  temp[5] = sine & 0xFF;
 238:	80 93 05 38 	sts	0x3805, r24	; 0x803805 <__DATA_REGION_ORIGIN__+0x5>
 23c:	c0 e0       	ldi	r28, 0x00	; 0
 23e:	d8 e3       	ldi	r29, 0x38	; 56
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:200
  
  for(int i=0;i<6;i++)
  {
    Wire.write(temp[i]);
 240:	69 91       	ld	r22, Y+
write():
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.h:130
    }
    inline size_t write(unsigned int  n) {
      return      write((uint8_t)     n);
    }
    inline size_t write(int           n) {
      return      write((uint8_t)     n);
 242:	8b e0       	ldi	r24, 0x0B	; 11
 244:	98 e3       	ldi	r25, 0x38	; 56
 246:	a8 df       	rcall	.-176    	; 0x198 <TwoWire::write(unsigned char)>
_Z16transmitDataWirev():
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:198
  temp[2] = (cosine >> 8) & 0xFF;
  temp[3] = cosine & 0xFF;
  temp[4] = (sine >> 8) & 0xFF;
  temp[5] = sine & 0xFF;
  
  for(int i=0;i<6;i++)
 248:	88 e3       	ldi	r24, 0x38	; 56
 24a:	c6 30       	cpi	r28, 0x06	; 6
 24c:	d8 07       	cpc	r29, r24
 24e:	c1 f7       	brne	.-16     	; 0x240 <transmitDataWire()+0x38>
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:202
  {
    Wire.write(temp[i]);
  }
}
 250:	df 91       	pop	r29
 252:	cf 91       	pop	r28
 254:	08 95       	ret

00000256 <digitalWrite>:
digitalWrite():
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:240
    default:
      break;
  }
}

void digitalWrite(uint8_t pin, uint8_t val) {
 256:	cf 93       	push	r28
 258:	df 93       	push	r29
check_valid_digital_pin():
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/Arduino.h:873
#if !defined(NUM_TOTAL_PINS)
  #define NUM_TOTAL_PINS                (NUM_DIGITAL_PINS) /* Used the same way as NUM_DIGITAL_PINS. so it doesn't mean what it's named  - I didn't make the convention*/
#endif

inline __attribute__((always_inline)) void check_valid_digital_pin(pin_size_t pin) {
  if (__builtin_constant_p(pin)) {
 25a:	28 2f       	mov	r18, r24
 25c:	30 e0       	ldi	r19, 0x00	; 0
digitalWrite():
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:243
  check_valid_digital_pin(pin);
  /* Get bit mask for pin */
  uint8_t bit_mask = digitalPinToBitMask(pin);
 25e:	e9 01       	movw	r28, r18
 260:	c0 59       	subi	r28, 0x90	; 144
 262:	d1 47       	sbci	r29, 0x71	; 113
 264:	88 81       	ld	r24, Y
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:244
  if (bit_mask == NOT_A_PIN) {
 266:	8f 3f       	cpi	r24, 0xFF	; 255
 268:	09 f4       	brne	.+2      	; 0x26c <digitalWrite+0x16>
 26a:	3f c0       	rjmp	.+126    	; 0x2ea <digitalWrite+0x94>
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:249
    return;
  }

  /* Get port */
  PORT_t *port = digitalPinToPortStruct(pin);
 26c:	a9 01       	movw	r20, r18
 26e:	42 5a       	subi	r20, 0xA2	; 162
 270:	51 47       	sbci	r21, 0x71	; 113
 272:	da 01       	movw	r26, r20
 274:	ec 91       	ld	r30, X
 276:	b0 e2       	ldi	r27, 0x20	; 32
 278:	eb 9f       	mul	r30, r27
 27a:	f0 01       	movw	r30, r0
 27c:	11 24       	eor	r1, r1
 27e:	fc 5f       	subi	r31, 0xFC	; 252
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:257
  the behavior of digitalWrite() on classic AVR devices, where
  you could digitalWrite() a pin while it's an input, to ensure
  that the value of the port was set correctly when it was
  changed to an output. Code in the wild relies on this behavior. */

  if (val == LOW) { /* If LOW */
 280:	61 11       	cpse	r22, r1
 282:	36 c0       	rjmp	.+108    	; 0x2f0 <digitalWrite+0x9a>
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:258
    port->OUTCLR = bit_mask;
 284:	86 83       	std	Z+6, r24	; 0x06
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:282
  } else {
    port->OUTSET = bit_mask;
  }

  /* Input direction */
  if (!(port->DIR & bit_mask)) {
 286:	90 81       	ld	r25, Z
 288:	89 23       	and	r24, r25
 28a:	a1 f4       	brne	.+40     	; 0x2b4 <digitalWrite+0x5e>
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:289
      pull up is enabled if this function is called.
      Should we purposely implement this side effect?
    */

    /* Get bit position for getting pin ctrl reg */
    uint8_t bit_pos = digitalPinToBitPosition(pin);
 28c:	c9 01       	movw	r24, r18
 28e:	84 5b       	subi	r24, 0xB4	; 180
 290:	91 47       	sbci	r25, 0x71	; 113
 292:	dc 01       	movw	r26, r24
 294:	9c 91       	ld	r25, X
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:292

    /* Calculate where pin control register is */
    volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);
 296:	30 97       	sbiw	r30, 0x00	; 0
 298:	69 f1       	breq	.+90     	; 0x2f4 <digitalWrite+0x9e>
 29a:	98 30       	cpi	r25, 0x08	; 8
 29c:	58 f5       	brcc	.+86     	; 0x2f4 <digitalWrite+0x9e>
 29e:	70 96       	adiw	r30, 0x10	; 16
 2a0:	e9 0f       	add	r30, r25
 2a2:	f1 1d       	adc	r31, r1
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:295

    /* Save system status and disable interrupts */
    uint8_t status = SREG;
 2a4:	9f b7       	in	r25, 0x3f	; 63
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:296
    cli();
 2a6:	f8 94       	cli
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:300

    if (val == LOW) {
      /* Disable pullup */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
 2a8:	80 81       	ld	r24, Z
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:298

    /* Save system status and disable interrupts */
    uint8_t status = SREG;
    cli();

    if (val == LOW) {
 2aa:	61 11       	cpse	r22, r1
 2ac:	26 c0       	rjmp	.+76     	; 0x2fa <digitalWrite+0xa4>
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:300
      /* Disable pullup */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
 2ae:	87 7f       	andi	r24, 0xF7	; 247
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:303
    } else {
      /* Enable pull-up */
      *pin_ctrl_reg |= PORT_PULLUPEN_bm;
 2b0:	80 83       	st	Z, r24
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:307
    }

    /* Restore system status */
    SREG = status;
 2b2:	9f bf       	out	0x3f, r25	; 63
turnOffPWM():
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:107
   * any timers with minimum overhead - critical on these parts
   * Since nothing that will show up here can have more than one
   * one bit set, binary and will give 0x00 if that bit is cleared
   * which is NOT_ON_TIMER.
   */
  uint8_t digital_pin_timer =  digitalPinToTimer(pin) & __PeripheralControl;
 2b4:	26 5c       	subi	r18, 0xC6	; 198
 2b6:	31 47       	sbci	r19, 0x71	; 113
 2b8:	f9 01       	movw	r30, r18
 2ba:	90 81       	ld	r25, Z
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:109
  /* end megaTinyCore-specific section */
  if (digital_pin_timer== NOT_ON_TIMER) {
 2bc:	99 23       	and	r25, r25
 2be:	a9 f0       	breq	.+42     	; 0x2ea <digitalWrite+0x94>
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:113
    return;
  }

  uint8_t bit_mask = digitalPinToBitMask(pin);
 2c0:	88 81       	ld	r24, Y
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:116
  // TCB_t *timerB;

  switch (digital_pin_timer) {
 2c2:	90 34       	cpi	r25, 0x40	; 64
 2c4:	09 f1       	breq	.+66     	; 0x308 <digitalWrite+0xb2>
 2c6:	90 38       	cpi	r25, 0x80	; 128
 2c8:	e1 f0       	breq	.+56     	; 0x302 <digitalWrite+0xac>
 2ca:	90 31       	cpi	r25, 0x10	; 16
 2cc:	71 f4       	brne	.+28     	; 0x2ea <digitalWrite+0x94>
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:132
          }
          if (bit_mask > 0x04) {  // -> bit_pos > 2 -> output channel controlled by HCMP
            bit_mask <<= 1;       // mind the gap (between LCMP and HCMP)
          }
        #else
          if (digitalPinToPort(pin) == PB) {        // WO0-WO2, Bitmask has one of these bits 1: 0b00hhhlll.
 2ce:	da 01       	movw	r26, r20
 2d0:	9c 91       	ld	r25, X
 2d2:	91 30       	cpi	r25, 0x01	; 1
 2d4:	a1 f4       	brne	.+40     	; 0x2fe <digitalWrite+0xa8>
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:133
            if (bit_mask > 0x04) { // Is it one of the three high ones? If so
 2d6:	85 30       	cpi	r24, 0x05	; 5
 2d8:	10 f0       	brcs	.+4      	; 0x2de <digitalWrite+0x88>
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:134
              bit_mask <<= 1;      // nudge it 1 place left swap nybbles since that's 1 clock faster than 3 rightshifts.
 2da:	88 0f       	add	r24, r24
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:135
              _SWAP(bit_mask);     // swap nybbles since that's 1 clock faster than 3 rightshifts.
 2dc:	82 95       	swap	r24
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:142
          } else {
            // Otherwise, it's WO3-5. These will always be on 0b00hhh000,. Here since we ARE working with a high half timer, we need to just leftshift it once.
            bit_mask <<= 1;
          }
        #endif
        TCA0.SPLIT.CTRLB &= ~bit_mask;
 2de:	90 91 01 0a 	lds	r25, 0x0A01	; 0x800a01 <digital_pin_to_bit_mask+0x7f7b91>
 2e2:	80 95       	com	r24
 2e4:	89 23       	and	r24, r25
 2e6:	80 93 01 0a 	sts	0x0A01, r24	; 0x800a01 <digital_pin_to_bit_mask+0x7f7b91>
digitalWrite():
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:320
   * analogWritten() 255, then digitallyWritten() to HIGH, which
   * would turn it off for the time between turnOffPWM() and
   * PORT->OUTCLR)
   * Since there's no penalty, why make a glitch we don't have to? */
  turnOffPWM(pin);
}
 2ea:	df 91       	pop	r29
 2ec:	cf 91       	pop	r28
 2ee:	08 95       	ret
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:278
    // val will now be 0 (LOW) if the toggling made it LOW
    // or bit_mask if not. And further down, we only need to
    // know if it's
  /* If HIGH OR  > TOGGLE  */
  } else {
    port->OUTSET = bit_mask;
 2f0:	85 83       	std	Z+5, r24	; 0x05
 2f2:	c9 cf       	rjmp	.-110    	; 0x286 <digitalWrite+0x30>
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:292

    /* Get bit position for getting pin ctrl reg */
    uint8_t bit_pos = digitalPinToBitPosition(pin);

    /* Calculate where pin control register is */
    volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);
 2f4:	f0 e0       	ldi	r31, 0x00	; 0
 2f6:	e0 e0       	ldi	r30, 0x00	; 0
 2f8:	d5 cf       	rjmp	.-86     	; 0x2a4 <digitalWrite+0x4e>
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:303
    if (val == LOW) {
      /* Disable pullup */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
    } else {
      /* Enable pull-up */
      *pin_ctrl_reg |= PORT_PULLUPEN_bm;
 2fa:	88 60       	ori	r24, 0x08	; 8
 2fc:	d9 cf       	rjmp	.-78     	; 0x2b0 <digitalWrite+0x5a>
turnOffPWM():
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:139
              bit_mask <<= 1;      // nudge it 1 place left swap nybbles since that's 1 clock faster than 3 rightshifts.
              _SWAP(bit_mask);     // swap nybbles since that's 1 clock faster than 3 rightshifts.
            }
          } else {
            // Otherwise, it's WO3-5. These will always be on 0b00hhh000,. Here since we ARE working with a high half timer, we need to just leftshift it once.
            bit_mask <<= 1;
 2fe:	88 0f       	add	r24, r24
 300:	ee cf       	rjmp	.-36     	; 0x2de <digitalWrite+0x88>
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:157
    /* We don't need the type b timers as this core does not use them for PWM      */

    // 1-series parts have a DAC that we can use...
    #if defined(DAC0)
      case DACOUT:
        DAC0.CTRLA = 0x00;
 302:	10 92 a0 06 	sts	0x06A0, r1	; 0x8006a0 <digital_pin_to_bit_mask+0x7f7830>
 306:	f1 cf       	rjmp	.-30     	; 0x2ea <digitalWrite+0x94>
digitalWrite():
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:194
            #endif

            SREG = oldSREG;
          }
        #else
          uint8_t fc_mask = (bit_mask == 0x02 ? 0x80 : 0x40);
 308:	20 e4       	ldi	r18, 0x40	; 64
turnOffPWM():
 30a:	82 30       	cpi	r24, 0x02	; 2
 30c:	09 f4       	brne	.+2      	; 0x310 <digitalWrite+0xba>
digitalWrite():
 30e:	20 e8       	ldi	r18, 0x80	; 128
turnOffPWM():
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:195
          if (TCD0.FAULTCTRL & fc_mask) {
 310:	90 91 92 0a 	lds	r25, 0x0A92	; 0x800a92 <digital_pin_to_bit_mask+0x7f7c22>
 314:	92 23       	and	r25, r18
 316:	49 f3       	breq	.-46     	; 0x2ea <digitalWrite+0x94>
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:196
            uint8_t oldSREG = SREG;
 318:	6f b7       	in	r22, 0x3f	; 63
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:197
            cli();
 31a:	f8 94       	cli
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:200
            // uint8_t TCD0_prescaler=TCD0.CTRLA&(~TCD_ENABLE_bm);
            //
            TCD0.CTRLA &= ~TCD_ENABLE_bm;
 31c:	90 91 80 0a 	lds	r25, 0x0A80	; 0x800a80 <digital_pin_to_bit_mask+0x7f7c10>
 320:	9e 7f       	andi	r25, 0xFE	; 254
 322:	90 93 80 0a 	sts	0x0A80, r25	; 0x800a80 <digital_pin_to_bit_mask+0x7f7c10>
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:201
            _PROTECTED_WRITE(TCD0.FAULTCTRL, TCD0.FAULTCTRL & (~fc_mask));
 326:	40 91 92 0a 	lds	r20, 0x0A92	; 0x800a92 <digital_pin_to_bit_mask+0x7f7c22>
 32a:	30 e0       	ldi	r19, 0x00	; 0
 32c:	20 95       	com	r18
 32e:	30 95       	com	r19
 330:	50 e0       	ldi	r21, 0x00	; 0
 332:	24 23       	and	r18, r20
 334:	35 23       	and	r19, r21
 336:	98 ed       	ldi	r25, 0xD8	; 216
 338:	94 bf       	out	0x34, r25	; 52
 33a:	20 93 92 0a 	sts	0x0A92, r18	; 0x800a92 <digital_pin_to_bit_mask+0x7f7c22>
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:202
            while (!(TCD0.STATUS & TCD_ENRDY_bm)); // wait until it can be re-enabled
 33e:	90 91 8e 0a 	lds	r25, 0x0A8E	; 0x800a8e <digital_pin_to_bit_mask+0x7f7c1e>
 342:	90 ff       	sbrs	r25, 0
 344:	fc cf       	rjmp	.-8      	; 0x33e <digitalWrite+0xe8>
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:203
            TCD0.CTRLA |= TCD_ENABLE_bm;           // re-enable it
 346:	90 91 80 0a 	lds	r25, 0x0A80	; 0x800a80 <digital_pin_to_bit_mask+0x7f7c10>
 34a:	91 60       	ori	r25, 0x01	; 1
 34c:	90 93 80 0a 	sts	0x0A80, r25	; 0x800a80 <digital_pin_to_bit_mask+0x7f7c10>
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:220
                  PORTA.PIN6CTRL &= ~(PORT_INVEN_bm);
                } else {
                  PORTA.PIN7CTRL &= ~(PORT_INVEN_bm);
                }
              #else
                if (bit_mask == 0x01) {
 350:	81 30       	cpi	r24, 0x01	; 1
 352:	39 f4       	brne	.+14     	; 0x362 <digitalWrite+0x10c>
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:221
                  PORTC.PIN0CTRL &= ~(PORT_INVEN_bm);
 354:	80 91 50 04 	lds	r24, 0x0450	; 0x800450 <digital_pin_to_bit_mask+0x7f75e0>
 358:	8f 77       	andi	r24, 0x7F	; 127
 35a:	80 93 50 04 	sts	0x0450, r24	; 0x800450 <digital_pin_to_bit_mask+0x7f75e0>
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:227
                } else {
                  PORTC.PIN1CTRL &= ~(PORT_INVEN_bm);
                }
              #endif
            #endif
            SREG = oldSREG;
 35e:	6f bf       	out	0x3f, r22	; 63
 360:	c4 cf       	rjmp	.-120    	; 0x2ea <digitalWrite+0x94>
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:223
                }
              #else
                if (bit_mask == 0x01) {
                  PORTC.PIN0CTRL &= ~(PORT_INVEN_bm);
                } else {
                  PORTC.PIN1CTRL &= ~(PORT_INVEN_bm);
 362:	80 91 51 04 	lds	r24, 0x0451	; 0x800451 <digital_pin_to_bit_mask+0x7f75e1>
 366:	8f 77       	andi	r24, 0x7F	; 127
 368:	80 93 51 04 	sts	0x0451, r24	; 0x800451 <digital_pin_to_bit_mask+0x7f75e1>
 36c:	f8 cf       	rjmp	.-16     	; 0x35e <digitalWrite+0x108>

0000036e <set_RGB_off()>:
_Z11set_RGB_offv():
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:147
// }


void set_RGB_off()
{
  digitalWrite(LED_RED_1,HIGH); 
 36e:	61 e0       	ldi	r22, 0x01	; 1
 370:	8a e0       	ldi	r24, 0x0A	; 10
 372:	71 df       	rcall	.-286    	; 0x256 <digitalWrite>
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:148
  digitalWrite(LED_GREEN_1,HIGH);
 374:	61 e0       	ldi	r22, 0x01	; 1
 376:	8b e0       	ldi	r24, 0x0B	; 11
 378:	6e df       	rcall	.-292    	; 0x256 <digitalWrite>
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:149
  digitalWrite(LED_BLUE_1,HIGH);
 37a:	61 e0       	ldi	r22, 0x01	; 1
 37c:	8c e0       	ldi	r24, 0x0C	; 12
 37e:	6b df       	rcall	.-298    	; 0x256 <digitalWrite>
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:150
  digitalWrite(LED_RED_2,HIGH);
 380:	61 e0       	ldi	r22, 0x01	; 1
 382:	85 e0       	ldi	r24, 0x05	; 5
 384:	68 df       	rcall	.-304    	; 0x256 <digitalWrite>
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:151
  digitalWrite(LED_GREEN_2,HIGH);
 386:	61 e0       	ldi	r22, 0x01	; 1
 388:	86 e0       	ldi	r24, 0x06	; 6
 38a:	65 df       	rcall	.-310    	; 0x256 <digitalWrite>
 38c:	61 e0       	ldi	r22, 0x01	; 1
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:152
  digitalWrite(LED_BLUE_2,HIGH);
 38e:	87 e0       	ldi	r24, 0x07	; 7
 390:	62 cf       	rjmp	.-316    	; 0x256 <digitalWrite>

00000392 <receiveEvent(int)>:
_Z12receiveEventi():
 392:	cf 93       	push	r28
 394:	90 91 19 38 	lds	r25, 0x3819	; 0x803819 <Wire+0xe>
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:205
    Wire.write(temp[i]);
  }
}

void receiveEvent(int howMany) {
  while (Wire.available()) { // loop through all but the last
 398:	80 91 1a 38 	lds	r24, 0x381A	; 0x80381a <Wire+0xf>
 39c:	98 17       	cp	r25, r24
 39e:	61 f1       	breq	.+88     	; 0x3f8 <receiveEvent(int)+0x66>
 3a0:	8b e0       	ldi	r24, 0x0B	; 11
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:206
    char c = Wire.read(); // receive byte as a character
 3a2:	98 e3       	ldi	r25, 0x38	; 56
 3a4:	e1 de       	rcall	.-574    	; 0x168 <TwoWire::read()>
 3a6:	c8 2f       	mov	r28, r24
 3a8:	82 35       	cpi	r24, 0x52	; 82
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:207
    if (c == 'R')
 3aa:	29 f4       	brne	.+10     	; 0x3b6 <receiveEvent(int)+0x24>
 3ac:	10 92 60 38 	sts	0x3860, r1	; 0x803860 <absolute_distance>
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:209
    {
      absolute_distance=0;
 3b0:	10 92 61 38 	sts	0x3861, r1	; 0x803861 <absolute_distance+0x1>
 3b4:	ef cf       	rjmp	.-34     	; 0x394 <receiveEvent(int)+0x2>
set_RGB():
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:168
}

void set_RGB(char color)

{
  set_RGB_off();
 3b6:	db df       	rcall	.-74     	; 0x36e <set_RGB_off()>
 3b8:	c4 34       	cpi	r28, 0x44	; 68
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:169
  switch(color)
 3ba:	59 f0       	breq	.+22     	; 0x3d2 <receiveEvent(int)+0x40>
 3bc:	24 f4       	brge	.+8      	; 0x3c6 <receiveEvent(int)+0x34>
 3be:	c2 34       	cpi	r28, 0x42	; 66
 3c0:	a9 f0       	breq	.+42     	; 0x3ec <receiveEvent(int)+0x5a>
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:186
      digitalWrite(LED_BLUE_2,LOW);
      break;
    case OFF:
      set_RGB_off();
    default:
      set_RGB_off();      
 3c2:	d5 df       	rcall	.-86     	; 0x36e <set_RGB_off()>
 3c4:	e7 cf       	rjmp	.-50     	; 0x394 <receiveEvent(int)+0x2>
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:169

void set_RGB(char color)

{
  set_RGB_off();
  switch(color)
 3c6:	c7 34       	cpi	r28, 0x47	; 71
 3c8:	59 f0       	breq	.+22     	; 0x3e0 <receiveEvent(int)+0x4e>
 3ca:	cf 34       	cpi	r28, 0x4F	; 79
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:184
    case BLUE:
      digitalWrite(LED_BLUE_1,LOW);
      digitalWrite(LED_BLUE_2,LOW);
      break;
    case OFF:
      set_RGB_off();
 3cc:	d1 f7       	brne	.-12     	; 0x3c2 <receiveEvent(int)+0x30>
 3ce:	cf df       	rcall	.-98     	; 0x36e <set_RGB_off()>
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:172
{
  set_RGB_off();
  switch(color)
  {
    case RED:
      digitalWrite(LED_RED_1,LOW); 
 3d0:	f8 cf       	rjmp	.-16     	; 0x3c2 <receiveEvent(int)+0x30>
 3d2:	60 e0       	ldi	r22, 0x00	; 0
 3d4:	8a e0       	ldi	r24, 0x0A	; 10
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:173
      digitalWrite(LED_RED_2,LOW);
 3d6:	3f df       	rcall	.-386    	; 0x256 <digitalWrite>
 3d8:	60 e0       	ldi	r22, 0x00	; 0
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:181
      digitalWrite(LED_GREEN_1,LOW);
      digitalWrite(LED_GREEN_2,LOW);
      break;
    case BLUE:
      digitalWrite(LED_BLUE_1,LOW);
      digitalWrite(LED_BLUE_2,LOW);
 3da:	85 e0       	ldi	r24, 0x05	; 5
 3dc:	3c df       	rcall	.-392    	; 0x256 <digitalWrite>
 3de:	da cf       	rjmp	.-76     	; 0x394 <receiveEvent(int)+0x2>
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:176
    case RED:
      digitalWrite(LED_RED_1,LOW); 
      digitalWrite(LED_RED_2,LOW);
      break;
    case GREEN:
      digitalWrite(LED_GREEN_1,LOW);
 3e0:	60 e0       	ldi	r22, 0x00	; 0
 3e2:	8b e0       	ldi	r24, 0x0B	; 11
 3e4:	38 df       	rcall	.-400    	; 0x256 <digitalWrite>
 3e6:	60 e0       	ldi	r22, 0x00	; 0
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:177
      digitalWrite(LED_GREEN_2,LOW);
 3e8:	86 e0       	ldi	r24, 0x06	; 6
 3ea:	f8 cf       	rjmp	.-16     	; 0x3dc <receiveEvent(int)+0x4a>
 3ec:	60 e0       	ldi	r22, 0x00	; 0
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:180
      break;
    case BLUE:
      digitalWrite(LED_BLUE_1,LOW);
 3ee:	8c e0       	ldi	r24, 0x0C	; 12
 3f0:	32 df       	rcall	.-412    	; 0x256 <digitalWrite>
 3f2:	60 e0       	ldi	r22, 0x00	; 0
 3f4:	87 e0       	ldi	r24, 0x07	; 7
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:181
      digitalWrite(LED_BLUE_2,LOW);
 3f6:	f2 cf       	rjmp	.-28     	; 0x3dc <receiveEvent(int)+0x4a>
_Z12receiveEventi():
 3f8:	cf 91       	pop	r28
 3fa:	08 95       	ret

000003fc <analogRead>:
analogRead():
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:216
    else 
    {
      set_RGB(c);
    }
  }
}
 3fc:	8c 5f       	subi	r24, 0xFC	; 252
 3fe:	90 91 00 06 	lds	r25, 0x0600	; 0x800600 <digital_pin_to_bit_mask+0x7f7790>
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_analog.c:711
      // don't waste flash on smallest parts.
      if ((pin & 0x7F) > 0x1F) { // highest valid mux value for any 0 or 1-series part.
        return ADC_ERROR_BAD_PIN_OR_CHANNEL;
      }
    #endif
    if (!ADC0.CTRLA & 0x01) return ADC_ERROR_DISABLED;
 402:	99 23       	and	r25, r25
 404:	71 f0       	breq	.+28     	; 0x422 <__LOCK_REGION_LENGTH__+0x22>
 406:	80 93 06 06 	sts	0x0606, r24	; 0x800606 <digital_pin_to_bit_mask+0x7f7796>
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_analog.c:715
    pin &= 0x1F;
    /* Reference should be already set up */
    /* Select channel */
    ADC0.MUXPOS = (pin << ADC_MUXPOS_gp);
 40a:	81 e0       	ldi	r24, 0x01	; 1
 40c:	80 93 08 06 	sts	0x0608, r24	; 0x800608 <digital_pin_to_bit_mask+0x7f7798>
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_analog.c:722
    #if defined(STRICT_ERROR_CHECKING)
      if (ADC0.COMMAND) return ADC_ERROR_BUSY;
    #endif

    /* Start conversion */
    ADC0.COMMAND = ADC_STCONV_bm;
 410:	80 91 0b 06 	lds	r24, 0x060B	; 0x80060b <digital_pin_to_bit_mask+0x7f779b>
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_analog.c:725

    /* Wait for result ready */
    while (!(ADC0.INTFLAGS & ADC_RESRDY_bm));
 414:	80 ff       	sbrs	r24, 0
 416:	fc cf       	rjmp	.-8      	; 0x410 <__LOCK_REGION_LENGTH__+0x10>
 418:	80 91 10 06 	lds	r24, 0x0610	; 0x800610 <digital_pin_to_bit_mask+0x7f77a0>
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_analog.c:728

    /* Combine two bytes */
    return ADC0.RES;
 41c:	90 91 11 06 	lds	r25, 0x0611	; 0x800611 <digital_pin_to_bit_mask+0x7f77a1>
 420:	08 95       	ret
 422:	89 ef       	ldi	r24, 0xF9	; 249
 424:	92 e8       	ldi	r25, 0x82	; 130
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_analog.c:711
      // don't waste flash on smallest parts.
      if ((pin & 0x7F) > 0x1F) { // highest valid mux value for any 0 or 1-series part.
        return ADC_ERROR_BAD_PIN_OR_CHANNEL;
      }
    #endif
    if (!ADC0.CTRLA & 0x01) return ADC_ERROR_DISABLED;
 426:	08 95       	ret

00000428 <pinMode.constprop.11>:
pinMode.constprop.11():
 428:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_analog.c:729
    /* Wait for result ready */
    while (!(ADC0.INTFLAGS & ADC_RESRDY_bm));

    /* Combine two bytes */
    return ADC0.RES;
  }
 42a:	fc 01       	movw	r30, r24
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/Arduino.h:873
 42c:	e0 59       	subi	r30, 0x90	; 144
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:44
}

void pinMode(uint8_t pin, uint8_t mode) {
  check_valid_digital_pin(pin);         /* generate compile error if a constant that is not a valid pin is used as the pin */
  check_valid_pin_mode(mode);           /* generate compile error if a constant that is not a valid pin mode is used as the mode */
  uint8_t bit_mask = digitalPinToBitMask(pin);
 42e:	f1 47       	sbci	r31, 0x71	; 113
 430:	20 81       	ld	r18, Z
 432:	2f 3f       	cpi	r18, 0xFF	; 255
 434:	99 f0       	breq	.+38     	; 0x45c <pinMode.constprop.11+0x34>
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:45
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
 436:	fc 01       	movw	r30, r24
 438:	e2 5a       	subi	r30, 0xA2	; 162
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:48
    return;                             /* ignore invalid pins passed at runtime */
  }
  volatile uint8_t * port_base = (volatile uint8_t *) (uint16_t) ((&PORTA) + digitalPinToPort(pin));
 43a:	f1 47       	sbci	r31, 0x71	; 113
 43c:	e0 81       	ld	r30, Z
 43e:	30 e2       	ldi	r19, 0x20	; 32
 440:	e3 9f       	mul	r30, r19
 442:	f0 01       	movw	r30, r0
 444:	11 24       	eor	r1, r1
 446:	fc 5f       	subi	r31, 0xFC	; 252
 448:	21 83       	std	Z+1, r18	; 0x01
 44a:	84 5b       	subi	r24, 0xB4	; 180
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:51
  if (mode & 0x01) {
    // OUTPUT mode, so write DIRSET with the mask.
    *(port_base + 1) = bit_mask;
 44c:	91 47       	sbci	r25, 0x71	; 113
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:77
  // then load with displacement 2 clocks. IFF the compiler puts this pointer into Y or Z, it is faster and smaller
  // by 2 bytes and one clock. And let's hope it is, because the code above would suck too if it was in X.
  // Handwritten assembly that exploited the knowledge that there will never be a carry would save 1 word and 1 clock.
  // and could probably save at least several times that in initializing the port_base pointer. But if you're using
  // pinMode you probably don't care.
  port_base += (uint8_t) digitalPinToBitPosition(pin);
 44e:	dc 01       	movw	r26, r24
 450:	8c 91       	ld	r24, X
 452:	e8 0f       	add	r30, r24
 454:	f1 1d       	adc	r31, r1
 456:	80 89       	ldd	r24, Z+16	; 0x10
 458:	87 7f       	andi	r24, 0xF7	; 247
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:78
  bit_mask = *(port_base + 0x10);
 45a:	80 8b       	std	Z+16, r24	; 0x10
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:82
  if (mode & 2) {
    bit_mask |= 0x08;
  } else {
    bit_mask &= 0xF7;
 45c:	08 95       	ret

0000045e <__vector_15>:
__vector_15():
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:84
  }
  *(port_base + 0x10) = bit_mask;
 45e:	8f 93       	push	r24
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:85
}
 460:	81 e0       	ldi	r24, 0x01	; 1
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:206
  #else
    ISR(MILLIS_TIMER_VECTOR, ISR_NAKED) {
      // Common Interrupt header for TCB, TCA and TCD;
      // Clears the Timer Interrupt flag and pushes the CPU Registers
      // 7 words / 7 clocks
      __asm__ __volatile__(
 462:	80 93 8d 0a 	sts	0x0A8D, r24	; 0x800a8d <digital_pin_to_bit_mask+0x7f7c1d>
 466:	8f b7       	in	r24, 0x3f	; 63
 468:	8f 93       	push	r24
 46a:	ef 93       	push	r30
 46c:	ff 93       	push	r31
 46e:	e2 e9       	ldi	r30, 0x92	; 146
 470:	f8 e3       	ldi	r31, 0x38	; 56
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:317
        [MIINC]  "M" ((0x0000 - MILLIS_INC) & 0xFF),
        [MINCD]  "M" ((0xFFFF - MILLIS_INC) & 0xFF)
      );
  */

      __asm__ __volatile__(
 472:	9f 93       	push	r25
 474:	68 94       	set
 476:	8f ef       	ldi	r24, 0xFF	; 255
 478:	0d c0       	rjmp	.+26     	; 0x494 <sub4>

0000047a <ovf_end>:
 47a:	e8 94       	clt
 47c:	84 81       	ldd	r24, Z+4	; 0x04
 47e:	95 81       	ldd	r25, Z+5	; 0x05
 480:	80 5d       	subi	r24, 0xD0	; 208
 482:	9c 4f       	sbci	r25, 0xFC	; 252
 484:	84 83       	std	Z+4, r24	; 0x04
 486:	95 83       	std	Z+5, r25	; 0x05
 488:	88 5e       	subi	r24, 0xE8	; 232
 48a:	93 40       	sbci	r25, 0x03	; 3
 48c:	80 f0       	brcs	.+32     	; 0x4ae <sub_end>
 48e:	84 83       	std	Z+4, r24	; 0x04
 490:	95 83       	std	Z+5, r25	; 0x05
 492:	8f ef       	ldi	r24, 0xFF	; 255

00000494 <sub4>:
 494:	90 81       	ld	r25, Z
 496:	98 1b       	sub	r25, r24
 498:	91 93       	st	Z+, r25
 49a:	90 81       	ld	r25, Z
 49c:	9f 4f       	sbci	r25, 0xFF	; 255
 49e:	91 93       	st	Z+, r25
 4a0:	90 81       	ld	r25, Z
 4a2:	9f 4f       	sbci	r25, 0xFF	; 255
 4a4:	91 93       	st	Z+, r25
 4a6:	90 81       	ld	r25, Z
 4a8:	9f 4f       	sbci	r25, 0xFF	; 255
 4aa:	91 93       	st	Z+, r25
 4ac:	36 f3       	brts	.-52     	; 0x47a <ovf_end>

000004ae <sub_end>:
 4ae:	9f 91       	pop	r25
 4b0:	ff 91       	pop	r31
 4b2:	ef 91       	pop	r30
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:379
        [MINCD]  "M" ((0xFFFF - MILLIS_INC) & 0xFF)
      );
    #endif /* (defined(MILLIS_USE_TIMERB0) || defined(MILLIS_USE_TIMERB1) || defined(MILLIS_USE_TIMERB2) || defined(MILLIS_USE_TIMERB3) || defined(MILLIS_USE_TIMERB4)) */
    // Common ISR Epilogue for TCA, TCB and TCD, popping register in reverse Order
    // 6 words, 14 clocks
    __asm__ __volatile__(
 4b4:	8f 91       	pop	r24
 4b6:	8f bf       	out	0x3f, r24	; 63
 4b8:	8f 91       	pop	r24
 4ba:	18 95       	reti

000004bc <__vector_24>:
__vector_24():
 4bc:	1f 92       	push	r1
 4be:	0f 92       	push	r0
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:977


/**
 *@brief      TWI0 Slave Interrupt vector
 */
ISR(TWI0_TWIS_vect) {
 4c0:	0f b6       	in	r0, 0x3f	; 63
 4c2:	0f 92       	push	r0
 4c4:	11 24       	eor	r1, r1
 4c6:	1f 93       	push	r17
 4c8:	2f 93       	push	r18
 4ca:	3f 93       	push	r19
 4cc:	4f 93       	push	r20
 4ce:	5f 93       	push	r21
 4d0:	6f 93       	push	r22
 4d2:	7f 93       	push	r23
 4d4:	8f 93       	push	r24
 4d6:	9f 93       	push	r25
 4d8:	af 93       	push	r26
 4da:	bf 93       	push	r27
 4dc:	cf 93       	push	r28
 4de:	df 93       	push	r29
 4e0:	ef 93       	push	r30
 4e2:	ff 93       	push	r31
TWI_HandleSlaveIRQ():
 4e4:	c3 e1       	ldi	r28, 0x13	; 19
 4e6:	d8 e3       	ldi	r29, 0x38	; 56
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:522
  // used as a frame pointer and the compiler avoids using it. So, using it comes with a price of pushing/popping
  // r28/r29, as well as ldi the address of the struct into those, so it only makes sense in a few cases like this.
  // Since the Y register is not call-clobbered, it can be considered persistent in this function and has not to
  // be restored after the icall to the user callbacks, unlike Z (which is used for _module and icall).

  _fastPtr_y(_data,_data);  // force _data into Y and instruct to not change Y
 4e8:	e8 81       	ld	r30, Y
 4ea:	f9 81       	ldd	r31, Y+1	; 0x01
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:564
  #if defined(TWI_MANDS)
    _data->_bools._toggleStreamFn = 0x01;
  #endif

  uint8_t action = 0;
  uint8_t clientStatus = _data->_module->SSTATUS;
 4ec:	83 85       	ldd	r24, Z+11	; 0x0b
 4ee:	86 ff       	sbrs	r24, 6
 4f0:	56 c0       	rjmp	.+172    	; 0x59e <__vector_24+0xe2>
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:566

  if (clientStatus & TWI_APIF_bm) {  // Address/Stop Bit set
 4f2:	80 ff       	sbrs	r24, 0
 4f4:	41 c0       	rjmp	.+130    	; 0x578 <__vector_24+0xbc>
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:567
    if (clientStatus & TWI_AP_bm) {    // Address bit set
 4f6:	15 85       	ldd	r17, Z+13	; 0x0d
 4f8:	81 ff       	sbrs	r24, 1
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:568
      uint8_t payload = _data->_module->SDATA;  // read address from data register
 4fa:	38 c0       	rjmp	.+112    	; 0x56c <__vector_24+0xb0>
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:569
      if (clientStatus & TWI_DIR_bm) {  // Master is reading
 4fc:	8e 81       	ldd	r24, Y+6	; 0x06
 4fe:	88 23       	and	r24, r24
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:570
        if ((*rxHead) > 0) {                    // There is no way to identify a REPSTART,
 500:	59 f0       	breq	.+22     	; 0x518 <__vector_24+0x5c>
popSleep():
 502:	80 91 0a 38 	lds	r24, 0x380A	; 0x80380a <sleepStack>
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:690
        sleepStackLoc = 0;              // reset everything
      }
      sleepStack = sleepStackLoc;
    }
  #else
    SLPCTRL.CTRLA = sleepStack;
 506:	80 93 50 00 	sts	0x0050, r24	; 0x800050 <digital_pin_to_bit_mask+0x7f71e0>
TWI_HandleSlaveIRQ():
 50a:	eb 85       	ldd	r30, Y+11	; 0x0b
 50c:	fc 85       	ldd	r31, Y+12	; 0x0c
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:572
    if (clientStatus & TWI_AP_bm) {    // Address bit set
      uint8_t payload = _data->_module->SDATA;  // read address from data register
      if (clientStatus & TWI_DIR_bm) {  // Master is reading
        if ((*rxHead) > 0) {                    // There is no way to identify a REPSTART,
          popSleep();                           // (have to treat REPSTART as another pop for sleep)
          if (_data->user_onReceive != NULL) {  // so when a Master Read occurs after a Master write
 50e:	30 97       	sbiw	r30, 0x00	; 0
 510:	19 f0       	breq	.+6      	; 0x518 <__vector_24+0x5c>
 512:	8e 81       	ldd	r24, Y+6	; 0x06
 514:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:573
            _data->user_onReceive((*rxHead));   // issue a call to the user callback first
 516:	09 95       	icall
 518:	1c 83       	std	Y+4, r17	; 0x04
 51a:	1d 82       	std	Y+5, r1	; 0x05
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:576
          }
        }
        (*address) = payload;                   // saving address to expose to the user sketch
 51c:	18 86       	std	Y+8, r1	; 0x08
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:577
        (*txHead) = 0;                          // reset buffer positions so the Master can start writing at zero.
 51e:	e9 85       	ldd	r30, Y+9	; 0x09
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:578
        (*txTail) = 0;
 520:	fa 85       	ldd	r31, Y+10	; 0x0a
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:580

        if (_data->user_onRequest != NULL) {
 522:	30 97       	sbiw	r30, 0x00	; 0
 524:	09 f0       	breq	.+2      	; 0x528 <__vector_24+0x6c>
 526:	09 95       	icall
 528:	8d 81       	ldd	r24, Y+5	; 0x05
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:581
          _data->user_onRequest();
 52a:	88 23       	and	r24, r24
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:583
        }
        if ((*txHead) == 0) {                   // If no data to transmit, send NACK
 52c:	19 f1       	breq	.+70     	; 0x574 <__vector_24+0xb8>
__vector_24():
 52e:	83 e0       	ldi	r24, 0x03	; 3
pushSleep():
 530:	90 91 50 00 	lds	r25, 0x0050	; 0x800050 <digital_pin_to_bit_mask+0x7f71e0>
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:672
      sleepStackLoc = SLPCTRL.CTRLA;        // save sleep settings to sleepStack
      SLPCTRL.CTRLA = sleepStackLoc & 0x01; // Set to IDLE if sleep was enabled
    }
    sleepStack = sleepStackLoc;
  #else
    sleepStack = SLPCTRL.CTRLA;           // save old sleep State
 534:	90 93 0a 38 	sts	0x380A, r25	; 0x80380a <sleepStack>
 538:	91 70       	andi	r25, 0x01	; 1
 53a:	90 93 50 00 	sts	0x0050, r25	; 0x800050 <digital_pin_to_bit_mask+0x7f71e0>
TWI_HandleSlaveIRQ():
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:673
    SLPCTRL.CTRLA = sleepStack & 0x01;    // only leave the SEN bit, if it was set
 53e:	e8 81       	ld	r30, Y
 540:	f9 81       	ldd	r31, Y+1	; 0x01
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:639
          action = TWI_ACKACT_bm | TWI_SCMD_COMPTRANS_gc;  // "Execute ACK Action succeeded by waiting for any Start (S/Sr) condition"
        }
      }
    }
  }
  _data->_module->SCTRLB = action;  // using local variable (register) reduces the amount of loading _module
 542:	82 87       	std	Z+10, r24	; 0x0a
__vector_24():
 544:	ff 91       	pop	r31
 546:	ef 91       	pop	r30
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:979
  TwoWire::onSlaveIRQ(&TWI0);
}
 548:	df 91       	pop	r29
 54a:	cf 91       	pop	r28
 54c:	bf 91       	pop	r27
 54e:	af 91       	pop	r26
 550:	9f 91       	pop	r25
 552:	8f 91       	pop	r24
 554:	7f 91       	pop	r23
 556:	6f 91       	pop	r22
 558:	5f 91       	pop	r21
 55a:	4f 91       	pop	r20
 55c:	3f 91       	pop	r19
 55e:	2f 91       	pop	r18
 560:	1f 91       	pop	r17
 562:	0f 90       	pop	r0
 564:	0f be       	out	0x3f, r0	; 63
 566:	0f 90       	pop	r0
 568:	1f 90       	pop	r1
 56a:	18 95       	reti
TWI_HandleSlaveIRQ():
 56c:	1c 83       	std	Y+4, r17	; 0x04
 56e:	1e 82       	std	Y+6, r1	; 0x06
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:590
        } else {
          action = TWI_SCMD_RESPONSE_gc;        // "Execute Acknowledge Action succeeded by reception of next byte"
        }
      } else {                          // Master is writing
        action = TWI_SCMD_RESPONSE_gc;  // "Execute Acknowledge Action succeeded by reception of next byte"
        (*address) = payload;           // saving address to expose to the user sketch
 570:	1f 82       	std	Y+7, r1	; 0x07
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:591
        (*rxHead) = 0;                  // reset buffer positions so the Master can start writing at zero.
 572:	dd cf       	rjmp	.-70     	; 0x52e <__vector_24+0x72>
__vector_24():
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:592
        (*rxTail) = 0;
 574:	86 e0       	ldi	r24, 0x06	; 6
 576:	dc cf       	rjmp	.-72     	; 0x530 <__vector_24+0x74>
popSleep():
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:584

        if (_data->user_onRequest != NULL) {
          _data->user_onRequest();
        }
        if ((*txHead) == 0) {                   // If no data to transmit, send NACK
          action = TWI_ACKACT_bm | TWI_SCMD_COMPTRANS_gc;  // NACK + "Wait for any Start (S/Sr) condition"
 578:	80 91 0a 38 	lds	r24, 0x380A	; 0x80380a <sleepStack>
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:690
        sleepStackLoc = 0;              // reset everything
      }
      sleepStack = sleepStackLoc;
    }
  #else
    SLPCTRL.CTRLA = sleepStack;
 57c:	80 93 50 00 	sts	0x0050, r24	; 0x800050 <digital_pin_to_bit_mask+0x7f71e0>
TWI_HandleSlaveIRQ():
 580:	eb 85       	ldd	r30, Y+11	; 0x0b
 582:	fc 85       	ldd	r31, Y+12	; 0x0c
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:597
        (*rxTail) = 0;
      }
      pushSleep();
    } else {                            // Stop bit set
      popSleep();
      if (_data->user_onReceive != NULL) {
 584:	30 97       	sbiw	r30, 0x00	; 0
 586:	29 f0       	breq	.+10     	; 0x592 <__vector_24+0xd6>
 588:	8e 81       	ldd	r24, Y+6	; 0x06
 58a:	88 23       	and	r24, r24
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:598
        if ((*rxHead) > 0) {
 58c:	11 f0       	breq	.+4      	; 0x592 <__vector_24+0xd6>
 58e:	90 e0       	ldi	r25, 0x00	; 0
 590:	09 95       	icall
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:599
          _data->user_onReceive((*rxHead));
 592:	1e 82       	std	Y+6, r1	; 0x06
 594:	1d 82       	std	Y+5, r1	; 0x05
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:603
        }
      }
      action = TWI_SCMD_COMPTRANS_gc;  // "Wait for any Start (S/Sr) condition"
      (*rxHead) = 0;
 596:	1f 82       	std	Y+7, r1	; 0x07
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:604
      (*txHead) = 0;
 598:	18 86       	std	Y+8, r1	; 0x08
__vector_24():
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:605
      (*rxTail) = 0;
 59a:	82 e0       	ldi	r24, 0x02	; 2
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:606
      (*txTail) = 0;
 59c:	d0 cf       	rjmp	.-96     	; 0x53e <__vector_24+0x82>
TWI_HandleSlaveIRQ():
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:623
        if ((*txTail) < (*txHead)) {            // Data is available
          _data->_module->SDATA = txBuffer[(*txTail)];  // Writing to the register to send data
          (*txTail)++;                            // Increment counter for sent bytes
          action = TWI_SCMD_RESPONSE_gc;          // "Execute a byte read operation followed by Acknowledge Action"
        } else {                                // No more data available
          action = TWI_SCMD_COMPTRANS_gc;         // "Wait for any Start (S/Sr) condition"
 59e:	87 ff       	sbrs	r24, 7
 5a0:	2f c0       	rjmp	.+94     	; 0x600 <__vector_24+0x144>
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:608
      (*rxHead) = 0;
      (*txHead) = 0;
      (*rxTail) = 0;
      (*txTail) = 0;
    }
  } else if (clientStatus & TWI_DIF_bm) { // Data bit set
 5a2:	81 ff       	sbrs	r24, 1
 5a4:	1e c0       	rjmp	.+60     	; 0x5e2 <__vector_24+0x126>
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:609
    if (clientStatus & TWI_DIR_bm) {        // Master is reading
 5a6:	88 71       	andi	r24, 0x18	; 24
 5a8:	39 f0       	breq	.+14     	; 0x5b8 <__vector_24+0xfc>
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:610
      if ((clientStatus & (TWI_COLL_bm | TWI_RXACK_bm)) &&  // If a collision was detected, or RXACK bit is set AND
 5aa:	8a 81       	ldd	r24, Y+2	; 0x02
 5ac:	83 ff       	sbrs	r24, 3
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:611
          (true == _data->_bools._ackMatters)) {            // And we have to check for it
 5ae:	04 c0       	rjmp	.+8      	; 0x5b8 <__vector_24+0xfc>
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:610
      (*rxTail) = 0;
      (*txTail) = 0;
    }
  } else if (clientStatus & TWI_DIF_bm) { // Data bit set
    if (clientStatus & TWI_DIR_bm) {        // Master is reading
      if ((clientStatus & (TWI_COLL_bm | TWI_RXACK_bm)) &&  // If a collision was detected, or RXACK bit is set AND
 5b0:	1d 82       	std	Y+5, r1	; 0x05
 5b2:	87 7f       	andi	r24, 0xF7	; 247
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:612
          (true == _data->_bools._ackMatters)) {            // And we have to check for it
        (*txHead) = 0;                          // Abort further data writes
 5b4:	8a 83       	std	Y+2, r24	; 0x02
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:613
        _data->_bools._ackMatters = false;      // stop checking for NACK
 5b6:	f1 cf       	rjmp	.-30     	; 0x59a <__vector_24+0xde>
 5b8:	8b 81       	ldd	r24, Y+3	; 0x03
 5ba:	8f 5f       	subi	r24, 0xFF	; 255
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:616
        action = TWI_SCMD_COMPTRANS_gc;         // "Wait for any Start (S/Sr) condition"
      } else {                                // RXACK bit not set, no COLL
        _data->_bytesTransmittedS++;            // increment bytes transmitted counter (for register model)
 5bc:	8b 83       	std	Y+3, r24	; 0x03
 5be:	8a 81       	ldd	r24, Y+2	; 0x02
 5c0:	88 60       	ori	r24, 0x08	; 8
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:617
        _data->_bools._ackMatters = true;       // start checking for NACK
 5c2:	8a 83       	std	Y+2, r24	; 0x02
 5c4:	a8 85       	ldd	r26, Y+8	; 0x08
 5c6:	8d 81       	ldd	r24, Y+5	; 0x05
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:618
        if ((*txTail) < (*txHead)) {            // Data is available
 5c8:	a8 17       	cp	r26, r24
 5ca:	38 f7       	brcc	.-50     	; 0x59a <__vector_24+0xde>
 5cc:	ac 0f       	add	r26, r28
 5ce:	bd 2f       	mov	r27, r29
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:619
          _data->_module->SDATA = txBuffer[(*txTail)];  // Writing to the register to send data
 5d0:	b1 1d       	adc	r27, r1
 5d2:	1d 96       	adiw	r26, 0x0d	; 13
 5d4:	8c 91       	ld	r24, X
 5d6:	85 87       	std	Z+13, r24	; 0x0d
 5d8:	88 85       	ldd	r24, Y+8	; 0x08
 5da:	8f 5f       	subi	r24, 0xFF	; 255
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:620
          (*txTail)++;                            // Increment counter for sent bytes
 5dc:	88 87       	std	Y+8, r24	; 0x08
__vector_24():
 5de:	83 e0       	ldi	r24, 0x03	; 3
 5e0:	ae cf       	rjmp	.-164    	; 0x53e <__vector_24+0x82>
TWI_HandleSlaveIRQ():
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:632
      uint8_t payload = _data->_module->SDATA;      // reading SDATA will clear the DATA IRQ flag
      if ((*rxHead) < BUFFER_LENGTH) {              // make sure that we don't have a buffer overflow in case Master ignores NACK
        rxBuffer[(*rxHead)] = payload;              // save data
        (*rxHead)++;                                  // Advance Head
        if ((*rxHead) < BUFFER_LENGTH) {              // if buffer is not yet full
          action = TWI_SCMD_RESPONSE_gc;                // "Execute Acknowledge Action succeeded by reception of next byte"
 5e2:	85 85       	ldd	r24, Z+13	; 0x0d
 5e4:	ee 81       	ldd	r30, Y+6	; 0x06
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:627
        } else {                                // No more data available
          action = TWI_SCMD_COMPTRANS_gc;         // "Wait for any Start (S/Sr) condition"
        }
      }
    } else {                                  // Master is writing
      uint8_t payload = _data->_module->SDATA;      // reading SDATA will clear the DATA IRQ flag
 5e6:	e0 32       	cpi	r30, 0x20	; 32
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:628
      if ((*rxHead) < BUFFER_LENGTH) {              // make sure that we don't have a buffer overflow in case Master ignores NACK
 5e8:	58 f4       	brcc	.+22     	; 0x600 <__vector_24+0x144>
 5ea:	ec 0f       	add	r30, r28
 5ec:	fd 2f       	mov	r31, r29
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:629
        rxBuffer[(*rxHead)] = payload;              // save data
 5ee:	f1 1d       	adc	r31, r1
 5f0:	85 a7       	std	Z+45, r24	; 0x2d
 5f2:	8e 81       	ldd	r24, Y+6	; 0x06
 5f4:	8f 5f       	subi	r24, 0xFF	; 255
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:630
        (*rxHead)++;                                  // Advance Head
 5f6:	8e 83       	std	Y+6, r24	; 0x06
 5f8:	80 32       	cpi	r24, 0x20	; 32
 5fa:	88 f3       	brcs	.-30     	; 0x5de <__vector_24+0x122>
__vector_24():
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:631
        if ((*rxHead) < BUFFER_LENGTH) {              // if buffer is not yet full
 5fc:	86 e0       	ldi	r24, 0x06	; 6
 5fe:	9f cf       	rjmp	.-194    	; 0x53e <__vector_24+0x82>
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:634
          action = TWI_SCMD_RESPONSE_gc;                // "Execute Acknowledge Action succeeded by reception of next byte"
        } else {                                      // else buffer would overflow with next byte
          action = TWI_ACKACT_bm | TWI_SCMD_COMPTRANS_gc;  // "Execute ACK Action succeeded by waiting for any Start (S/Sr) condition"
 600:	80 e0       	ldi	r24, 0x00	; 0
 602:	9d cf       	rjmp	.-198    	; 0x53e <__vector_24+0x82>

00000604 <main>:
main():
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:563

  #if defined(TWI_MANDS)
    _data->_bools._toggleStreamFn = 0x01;
  #endif

  uint8_t action = 0;
 604:	88 ed       	ldi	r24, 0xD8	; 216
 606:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:1536
    #if (defined(CLOCK_TUNE_INTERNAL))
      tune_internal(); // Will be inlined as only called once. Just too long and ugly to put two implementations in middle of this.
    #else
      #if (F_CPU == 20000000)
        /* No division on clock */
        _PROTECTED_WRITE(CLKCTRL_MCLKCTRLB, 0x00);
 608:	84 bf       	out	0x34, r24	; 52
 60a:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <digital_pin_to_bit_mask+0x7f71f1>
init_ADC0():
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:1651


/********************************* ADC ****************************************/
void __attribute__((weak)) init_ADC0() {
  ADC_t* pADC;
  _fastPtr_d(pADC, &ADC0);
 60e:	e0 e0       	ldi	r30, 0x00	; 0
 610:	f6 e0       	ldi	r31, 0x06	; 6
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:1672
   **************************************************************************/
    //                              30 MHz / 32 = 937 kHz,  32 MHz / 32 =  1 MHz.
    #if   F_CPU   > 24000000     // 24 MHz / 16 = 1.5 MHz,  25 MHz / 32 =  780 kHz
      pADC->CTRLC  = ADC_PRESC_DIV32_gc | ADC_REFSEL_VDDREF_gc | ADC_SAMPCAP_bm;
    #elif F_CPU  >= 12000000    // 16 MHz / 16 = 1.0 MHz,  20 MHz / 16 = 1.25 MHz
      pADC->CTRLC  = ADC_PRESC_DIV16_gc | ADC_REFSEL_VDDREF_gc | ADC_SAMPCAP_bm;
 612:	83 e5       	ldi	r24, 0x53	; 83
 614:	82 83       	std	Z+2, r24	; 0x02
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:1683
      pADC->CTRLC  =  ADC_PRESC_DIV2_gc | ADC_REFSEL_VDDREF_gc | ADC_SAMPCAP_bm;
    #endif
    #if   (F_CPU == 6000000 || F_CPU == 12000000 || F_CPU == 24000000 || F_CPU ==25000000)
      pADC->SAMPCTRL = (7); // 9 ADC clocks, 12 us
    #elif (F_CPU == 5000000 || F_CPU == 10000000 || F_CPU == 20000000)
      pADC->SAMPCTRL = (13);   // 15 ADC clock,s 12 us
 616:	8d e0       	ldi	r24, 0x0D	; 13
 618:	85 83       	std	Z+5, r24	; 0x05
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:1687
    #else
      pADC->SAMPCTRL = (10); // 12 ADC clocks, 12 us
    #endif
    pADC->CTRLD    = ADC_INITDLY_DLY16_gc;
 61a:	80 e2       	ldi	r24, 0x20	; 32
 61c:	83 83       	std	Z+3, r24	; 0x03
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:1688
    pADC->CTRLA    = ADC_ENABLE_bm;
 61e:	81 e0       	ldi	r24, 0x01	; 1
 620:	80 83       	st	Z, r24
init_TCA0():
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:1778

void __attribute__((weak)) init_TCA0() {
  /*  TYPE A TIMER   */
  #if !defined(TCA_BUFFERED_3PIN)
    #if defined(PORTMUX_CTRLC)
      PORTMUX.CTRLC = TCA_PORTMUX;
 622:	10 92 02 02 	sts	0x0202, r1	; 0x800202 <digital_pin_to_bit_mask+0x7f7392>
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:1782
    #else
      PORTMUX.TCAROUTEA = TCA_PORTMUX;
    #endif
    TCA0.SPLIT.CTRLD   = TCA_SPLIT_SPLITM_bm;
 626:	80 93 03 0a 	sts	0x0A03, r24	; 0x800a03 <digital_pin_to_bit_mask+0x7f7b93>
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:1783
    TCA0.SPLIT.LPER    = PWM_TIMER_PERIOD;
 62a:	9e ef       	ldi	r25, 0xFE	; 254
 62c:	90 93 26 0a 	sts	0x0A26, r25	; 0x800a26 <digital_pin_to_bit_mask+0x7f7bb6>
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:1784
    TCA0.SPLIT.HPER    = PWM_TIMER_PERIOD;
 630:	90 93 27 0a 	sts	0x0A27, r25	; 0x800a27 <digital_pin_to_bit_mask+0x7f7bb7>
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:1785
    TCA0.SPLIT.CTRLA   = (TIMERA_PRESCALER_bm | TCA_SPLIT_ENABLE_bm);
 634:	9b e0       	ldi	r25, 0x0B	; 11
 636:	90 93 00 0a 	sts	0x0A00, r25	; 0x800a00 <digital_pin_to_bit_mask+0x7f7b90>
init_millis():
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:1427
      #endif
    #elif defined(MILLIS_USE_TIMERA1)
      TCA1.SPLIT.INTCTRL |= TCA_SPLIT_HUNF_bm;
    #elif defined(MILLIS_USE_TIMERD0)
      TCD_t* pTCD;
      _fastPtr_d(pTCD, &TCD0);
 63a:	e0 e8       	ldi	r30, 0x80	; 128
 63c:	fa e0       	ldi	r31, 0x0A	; 10
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:1428
      pTCD->CMPBCLR        = TIME_TRACKING_TIMER_PERIOD; // essentially, this is TOP
 63e:	2d ef       	ldi	r18, 0xFD	; 253
 640:	31 e0       	ldi	r19, 0x01	; 1
 642:	26 a7       	std	Z+46, r18	; 0x2e
 644:	37 a7       	std	Z+47, r19	; 0x2f
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:1429
      pTCD->CTRLB          = 0x00; // oneramp mode
 646:	11 82       	std	Z+1, r1	; 0x01
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:1430
      pTCD->CTRLC          = 0x80;
 648:	90 e8       	ldi	r25, 0x80	; 128
 64a:	92 83       	std	Z+2, r25	; 0x02
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:1431
      pTCD->INTCTRL        = 0x01; // enable interrupt
 64c:	84 87       	std	Z+12, r24	; 0x0c
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:1432
      pTCD->CTRLA          = TIMERD0_PRESCALER | 0x01; // set clock source and enable!
 64e:	81 e1       	ldi	r24, 0x11	; 17
 650:	80 83       	st	Z, r24
main():
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/main.cpp:53
 * just waiting for the DU-series now                                                           */
int main() {
  onBeforeInit(); // Emnpty callback called before init but after the .init stuff. First normal code executed
  init(); // Interrupts are turned on just prior to init() returning.
  initVariant();
  if (!onAfterInit()) sei();  // enable interrupts.
 652:	78 94       	sei
onRequest():
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:963
 *@param      void (*function)(void) - a void returning function that does not accept any parameters
 *
 *@return     void
 */
void TwoWire::onRequest(void (*function)(void)) {
  vars.user_onRequest = function;
 654:	84 e0       	ldi	r24, 0x04	; 4
 656:	91 e0       	ldi	r25, 0x01	; 1
 658:	80 93 1c 38 	sts	0x381C, r24	; 0x80381c <Wire+0x11>
 65c:	90 93 1d 38 	sts	0x381D, r25	; 0x80381d <Wire+0x12>
TWI_SlaveInit():
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:95
  #if defined(TWI_MANDS)                      // Check if the user wants to use Master AND Slave
    if (_data->_bools._clientEnabled  == 1) {  // Master is allowed to be enabled, don't re-enable the client though
      return;
    }
  #else                                         // Master or Slave
    if ((_data->_bools._hostEnabled | _data->_bools._clientEnabled) == 1) {  //If either are enabled
 660:	80 91 15 38 	lds	r24, 0x3815	; 0x803815 <Wire+0xa>
 664:	81 fd       	sbrc	r24, 1
 666:	17 c0       	rjmp	.+46     	; 0x696 <main+0x92>
 668:	82 fd       	sbrc	r24, 2
 66a:	15 c0       	rjmp	.+42     	; 0x696 <main+0x92>
TWI0_ClearPins():
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi_pins.c:140
    #endif
  #elif defined(MEGATINYCORE)  /* tinyAVR 0/1-series */
    #if (MEGATINYCORE_SERIES < 2) // Hey, this erratum isn't listed for the 2-series, so we don't have to do this!
      // 6 bytes of flash saved for 2-series parts, aww yeah!
      #if defined(PORTMUX_TWI0_bm)
        if ((PORTMUX.CTRLB & PORTMUX_TWI0_bm)) {
 66c:	80 91 01 02 	lds	r24, 0x0201	; 0x800201 <digital_pin_to_bit_mask+0x7f7391>
 670:	84 ff       	sbrs	r24, 4
 672:	21 c1       	rjmp	.+578    	; 0x8b6 <__DATA_REGION_LENGTH__+0xb6>
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi_pins.c:143
          // make sure we don't get errata'ed - make sure their bits in the
          // PORTx.OUT registers are 0.
          PORTA.OUTCLR = 0x06;  // if swapped it's on PA1, PA2
 674:	86 e0       	ldi	r24, 0x06	; 6
 676:	80 93 06 04 	sts	0x0406, r24	; 0x800406 <digital_pin_to_bit_mask+0x7f7596>
TWI_SlaveInit():
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:110
    }
  #else
    TWI0_ClearPins();
  #endif

  _data->_bools._clientEnabled = 1;
 67a:	80 91 15 38 	lds	r24, 0x3815	; 0x803815 <Wire+0xa>
 67e:	84 60       	ori	r24, 0x04	; 4
 680:	80 93 15 38 	sts	0x3815, r24	; 0x803815 <Wire+0xa>
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:111
  _data->_module->SADDR        = (address << 1) | receive_broadcast;
 684:	e0 91 13 38 	lds	r30, 0x3813	; 0x803813 <Wire+0x8>
 688:	f0 91 14 38 	lds	r31, 0x3814	; 0x803814 <Wire+0x9>
 68c:	80 e1       	ldi	r24, 0x10	; 16
 68e:	84 87       	std	Z+12, r24	; 0x0c
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:112
  _data->_module->SADDRMASK    = second_address;
 690:	16 86       	std	Z+14, r1	; 0x0e
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi.c:113
  _data->_module->SCTRLA       = TWI_DIEN_bm | TWI_APIEN_bm | TWI_PIEN_bm  | TWI_ENABLE_bm;
 692:	81 ee       	ldi	r24, 0xE1	; 225
 694:	81 87       	std	Z+9, r24	; 0x09
onReceive():
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:949
 *@param      void (*function)(int) - a void returning function that accepts an int as parameter
 *
 *@return     void
 */
void TwoWire::onReceive(void (*function)(int)) {
  vars.user_onReceive = function;
 696:	89 ec       	ldi	r24, 0xC9	; 201
 698:	91 e0       	ldi	r25, 0x01	; 1
 69a:	80 93 1e 38 	sts	0x381E, r24	; 0x80381e <Wire+0x13>
 69e:	90 93 1f 38 	sts	0x381F, r25	; 0x80381f <Wire+0x14>
setup():
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:56
  //4 - 0xB
  //5 - 0xC
  //6 - 0xD
  Wire.onReceive(receiveEvent); // register event

  pinMode(LED_RED_1,OUTPUT);
 6a2:	8a e0       	ldi	r24, 0x0A	; 10
 6a4:	c1 de       	rcall	.-638    	; 0x428 <pinMode.constprop.11>
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:57
  pinMode(LED_GREEN_1,OUTPUT);
 6a6:	8b e0       	ldi	r24, 0x0B	; 11
 6a8:	bf de       	rcall	.-642    	; 0x428 <pinMode.constprop.11>
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:58
  pinMode(LED_BLUE_1,OUTPUT);
 6aa:	8c e0       	ldi	r24, 0x0C	; 12
 6ac:	bd de       	rcall	.-646    	; 0x428 <pinMode.constprop.11>
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:59
  pinMode(LED_RED_2,OUTPUT);
 6ae:	85 e0       	ldi	r24, 0x05	; 5
 6b0:	bb de       	rcall	.-650    	; 0x428 <pinMode.constprop.11>
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:60
  pinMode(LED_GREEN_2,OUTPUT);
 6b2:	86 e0       	ldi	r24, 0x06	; 6
 6b4:	b9 de       	rcall	.-654    	; 0x428 <pinMode.constprop.11>
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:61
  pinMode(LED_BLUE_2,OUTPUT);
 6b6:	87 e0       	ldi	r24, 0x07	; 7
 6b8:	b7 de       	rcall	.-658    	; 0x428 <pinMode.constprop.11>
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:63
//  
  digitalWrite(LED_RED_1,LOW); 
 6ba:	60 e0       	ldi	r22, 0x00	; 0
 6bc:	8a e0       	ldi	r24, 0x0A	; 10
 6be:	cb dd       	rcall	.-1130   	; 0x256 <digitalWrite>
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:64
  digitalWrite(LED_GREEN_1,HIGH);
 6c0:	61 e0       	ldi	r22, 0x01	; 1
 6c2:	8b e0       	ldi	r24, 0x0B	; 11
 6c4:	c8 dd       	rcall	.-1136   	; 0x256 <digitalWrite>
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:65
  digitalWrite(LED_BLUE_1,HIGH);
 6c6:	61 e0       	ldi	r22, 0x01	; 1
 6c8:	8c e0       	ldi	r24, 0x0C	; 12
 6ca:	c5 dd       	rcall	.-1142   	; 0x256 <digitalWrite>
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:66
  digitalWrite(LED_RED_2,LOW);
 6cc:	60 e0       	ldi	r22, 0x00	; 0
 6ce:	85 e0       	ldi	r24, 0x05	; 5
 6d0:	c2 dd       	rcall	.-1148   	; 0x256 <digitalWrite>
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:67
  digitalWrite(LED_GREEN_2,HIGH);
 6d2:	61 e0       	ldi	r22, 0x01	; 1
 6d4:	86 e0       	ldi	r24, 0x06	; 6
 6d6:	bf dd       	rcall	.-1154   	; 0x256 <digitalWrite>
 6d8:	61 e0       	ldi	r22, 0x01	; 1
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:68
  digitalWrite(LED_BLUE_2,HIGH);
 6da:	87 e0       	ldi	r24, 0x07	; 7
 6dc:	bc dd       	rcall	.-1160   	; 0x256 <digitalWrite>
 6de:	82 e0       	ldi	r24, 0x02	; 2
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:69
  cosine = analogRead(COS_IN)-512 - cosine_off;
 6e0:	8d de       	rcall	.-742    	; 0x3fc <analogRead>
 6e2:	92 50       	subi	r25, 0x02	; 2
 6e4:	80 93 68 38 	sts	0x3868, r24	; 0x803868 <cosine>
 6e8:	90 93 69 38 	sts	0x3869, r25	; 0x803869 <cosine+0x1>
 6ec:	83 e0       	ldi	r24, 0x03	; 3
 6ee:	86 de       	rcall	.-756    	; 0x3fc <analogRead>
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:70
  sine = analogRead(SIN_IN)-512 - sine_off;
 6f0:	ec 01       	movw	r28, r24
 6f2:	d2 50       	subi	r29, 0x02	; 2
 6f4:	c0 93 66 38 	sts	0x3866, r28	; 0x803866 <sine>
 6f8:	d0 93 67 38 	sts	0x3867, r29	; 0x803867 <sine+0x1>
 6fc:	60 91 68 38 	lds	r22, 0x3868	; 0x803868 <cosine>
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:71
  current_distance = atan2(sine,cosine)*180/3.14159*1000/360+500;
 700:	70 91 69 38 	lds	r23, 0x3869	; 0x803869 <cosine+0x1>
 704:	07 2e       	mov	r0, r23
 706:	00 0c       	add	r0, r0
 708:	88 0b       	sbc	r24, r24
 70a:	99 0b       	sbc	r25, r25
 70c:	67 d2       	rcall	.+1230   	; 0xbdc <__floatsisf>
 70e:	6b 01       	movw	r12, r22
 710:	7c 01       	movw	r14, r24
 712:	be 01       	movw	r22, r28
 714:	dd 0f       	add	r29, r29
 716:	88 0b       	sbc	r24, r24
 718:	99 0b       	sbc	r25, r25
 71a:	60 d2       	rcall	.+1216   	; 0xbdc <__floatsisf>
 71c:	a7 01       	movw	r20, r14
 71e:	96 01       	movw	r18, r12
 720:	6f d1       	rcall	.+734    	; 0xa00 <atan2>
 722:	20 e0       	ldi	r18, 0x00	; 0
 724:	30 e0       	ldi	r19, 0x00	; 0
 726:	44 e3       	ldi	r20, 0x34	; 52
 728:	53 e4       	ldi	r21, 0x43	; 67
 72a:	10 d3       	rcall	.+1568   	; 0xd4c <__mulsf3>
 72c:	20 ed       	ldi	r18, 0xD0	; 208
 72e:	3f e0       	ldi	r19, 0x0F	; 15
 730:	49 e4       	ldi	r20, 0x49	; 73
 732:	50 e4       	ldi	r21, 0x40	; 64
 734:	b8 d1       	rcall	.+880    	; 0xaa6 <__divsf3>
 736:	20 e0       	ldi	r18, 0x00	; 0
 738:	30 e0       	ldi	r19, 0x00	; 0
 73a:	4a e7       	ldi	r20, 0x7A	; 122
 73c:	54 e4       	ldi	r21, 0x44	; 68
 73e:	06 d3       	rcall	.+1548   	; 0xd4c <__mulsf3>
 740:	20 e0       	ldi	r18, 0x00	; 0
 742:	30 e0       	ldi	r19, 0x00	; 0
 744:	44 eb       	ldi	r20, 0xB4	; 180
 746:	53 e4       	ldi	r21, 0x43	; 67
 748:	ae d1       	rcall	.+860    	; 0xaa6 <__divsf3>
 74a:	20 e0       	ldi	r18, 0x00	; 0
 74c:	30 e0       	ldi	r19, 0x00	; 0
 74e:	4a ef       	ldi	r20, 0xFA	; 250
 750:	53 e4       	ldi	r21, 0x43	; 67
 752:	e3 d0       	rcall	.+454    	; 0x91a <__addsf3>
 754:	10 d2       	rcall	.+1056   	; 0xb76 <__fixsfsi>
 756:	60 93 64 38 	sts	0x3864, r22	; 0x803864 <previous_distance>
 75a:	70 93 65 38 	sts	0x3865, r23	; 0x803865 <previous_distance+0x1>
 75e:	10 92 60 38 	sts	0x3860, r1	; 0x803860 <absolute_distance>
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:73
  previous_distance = current_distance;
  absolute_distance = current_distance - previous_distance;
 762:	10 92 61 38 	sts	0x3861, r1	; 0x803861 <absolute_distance+0x1>
loop():
 766:	c8 ee       	ldi	r28, 0xE8	; 232
 768:	d3 e0       	ldi	r29, 0x03	; 3
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:107
  if (abs(difference) > Switch_Bound)
  {
      // Moving Up
      if (difference < 0)
      {
        absolute_distance += ((Upper_Bound - previous_distance) + (current_distance - Lower_Bound));
 76a:	0e e7       	ldi	r16, 0x7E	; 126
 76c:	18 e3       	ldi	r17, 0x38	; 56
 76e:	4a e6       	ldi	r20, 0x6A	; 106
 770:	e4 2e       	mov	r14, r20
 772:	48 e3       	ldi	r20, 0x38	; 56
 774:	f4 2e       	mov	r15, r20
 776:	82 e0       	ldi	r24, 0x02	; 2
 778:	41 de       	rcall	.-894    	; 0x3fc <analogRead>
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:80

void loop() {

  // Take 10 samples
  for (int i = 0; i < SAMPLE_SIZE; i++) {
    cosineSamples[i] = analogRead(COS_IN) - 512 - cosine_off;
 77a:	92 50       	subi	r25, 0x02	; 2
 77c:	f8 01       	movw	r30, r16
 77e:	81 93       	st	Z+, r24
 780:	91 93       	st	Z+, r25
 782:	8f 01       	movw	r16, r30
 784:	83 e0       	ldi	r24, 0x03	; 3
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:81
    sineSamples[i] = analogRead(SIN_IN) - 512 - sine_off;
 786:	3a de       	rcall	.-908    	; 0x3fc <analogRead>
 788:	92 50       	subi	r25, 0x02	; 2
 78a:	f7 01       	movw	r30, r14
 78c:	81 93       	st	Z+, r24
 78e:	91 93       	st	Z+, r25
 790:	7f 01       	movw	r14, r30
_delay_us():
 792:	83 ef       	ldi	r24, 0xF3	; 243
 794:	91 e0       	ldi	r25, 0x01	; 1
c:\users\taimu\appdata\local\arduino15\packages\dxcore\tools\avr-gcc\7.3.0-atmel3.6.1-azduino7b1\avr\include\util/delay.h:276
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 796:	01 97       	sbiw	r24, 0x01	; 1
 798:	f1 f7       	brne	.-4      	; 0x796 <main+0x192>
 79a:	00 c0       	rjmp	.+0      	; 0x79c <main+0x198>
 79c:	00 00       	nop
loop():
 79e:	98 e3       	ldi	r25, 0x38	; 56
 7a0:	02 39       	cpi	r16, 0x92	; 146
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:79
}

void loop() {

  // Take 10 samples
  for (int i = 0; i < SAMPLE_SIZE; i++) {
 7a2:	19 07       	cpc	r17, r25
 7a4:	41 f7       	brne	.-48     	; 0x776 <main+0x172>
 7a6:	8e e7       	ldi	r24, 0x7E	; 126
 7a8:	98 e3       	ldi	r25, 0x38	; 56
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:86
    sineSamples[i] = analogRead(SIN_IN) - 512 - sine_off;
    delayMicroseconds(100); // small delay between readings to allow ADC to stabilize
  }

    // Sort the samples to find the median
  sortArray(cosineSamples, SAMPLE_SIZE);
 7aa:	a7 dc       	rcall	.-1714   	; 0xfa <sortArray(int*, int) [clone .constprop.5]>
 7ac:	8a e6       	ldi	r24, 0x6A	; 106
 7ae:	98 e3       	ldi	r25, 0x38	; 56
 7b0:	a4 dc       	rcall	.-1720   	; 0xfa <sortArray(int*, int) [clone .constprop.5]>
calculateMedian():
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:87
  sortArray(sineSamples, SAMPLE_SIZE);
 7b2:	60 91 86 38 	lds	r22, 0x3886	; 0x803886 <cosineSamples+0x8>
 7b6:	70 91 87 38 	lds	r23, 0x3887	; 0x803887 <cosineSamples+0x9>
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:234

int calculateMedian(int arr[], int size) {
  if (size % 2 != 0)
    return arr[size / 2]; // if size is odd, return the middle number
  else
    return (arr[(size - 1) / 2] + arr[size / 2]) / 2; // if size is even, return the average of the two middle numbers
 7ba:	80 91 88 38 	lds	r24, 0x3888	; 0x803888 <cosineSamples+0xa>
 7be:	90 91 89 38 	lds	r25, 0x3889	; 0x803889 <cosineSamples+0xb>
 7c2:	86 0f       	add	r24, r22
 7c4:	97 1f       	adc	r25, r23
 7c6:	97 fd       	sbrc	r25, 7
 7c8:	01 96       	adiw	r24, 0x01	; 1
 7ca:	95 95       	asr	r25
 7cc:	87 95       	ror	r24
loop():
 7ce:	80 93 68 38 	sts	0x3868, r24	; 0x803868 <cosine>
 7d2:	90 93 69 38 	sts	0x3869, r25	; 0x803869 <cosine+0x1>
calculateMedian():
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:90
    // Sort the samples to find the median
  sortArray(cosineSamples, SAMPLE_SIZE);
  sortArray(sineSamples, SAMPLE_SIZE);

  // Calculate and print the median
  cosine = calculateMedian(cosineSamples, SAMPLE_SIZE);
 7d6:	60 91 72 38 	lds	r22, 0x3872	; 0x803872 <sineSamples+0x8>
 7da:	70 91 73 38 	lds	r23, 0x3873	; 0x803873 <sineSamples+0x9>
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:234

int calculateMedian(int arr[], int size) {
  if (size % 2 != 0)
    return arr[size / 2]; // if size is odd, return the middle number
  else
    return (arr[(size - 1) / 2] + arr[size / 2]) / 2; // if size is even, return the average of the two middle numbers
 7de:	20 91 74 38 	lds	r18, 0x3874	; 0x803874 <sineSamples+0xa>
 7e2:	30 91 75 38 	lds	r19, 0x3875	; 0x803875 <sineSamples+0xb>
 7e6:	62 0f       	add	r22, r18
 7e8:	73 1f       	adc	r23, r19
 7ea:	77 ff       	sbrs	r23, 7
 7ec:	02 c0       	rjmp	.+4      	; 0x7f2 <main+0x1ee>
 7ee:	6f 5f       	subi	r22, 0xFF	; 255
 7f0:	7f 4f       	sbci	r23, 0xFF	; 255
 7f2:	8b 01       	movw	r16, r22
 7f4:	15 95       	asr	r17
 7f6:	07 95       	ror	r16
loop():
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:91
  sortArray(cosineSamples, SAMPLE_SIZE);
  sortArray(sineSamples, SAMPLE_SIZE);

  // Calculate and print the median
  cosine = calculateMedian(cosineSamples, SAMPLE_SIZE);
  sine = calculateMedian(sineSamples, SAMPLE_SIZE);
 7f8:	00 93 66 38 	sts	0x3866, r16	; 0x803866 <sine>
 7fc:	10 93 67 38 	sts	0x3867, r17	; 0x803867 <sine+0x1>
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:94

  
  current_distance = atan2(sine,cosine)*180/3.14159*1000/360+500;
 800:	bc 01       	movw	r22, r24
 802:	99 0f       	add	r25, r25
 804:	88 0b       	sbc	r24, r24
 806:	99 0b       	sbc	r25, r25
 808:	e9 d1       	rcall	.+978    	; 0xbdc <__floatsisf>
 80a:	6b 01       	movw	r12, r22
 80c:	7c 01       	movw	r14, r24
 80e:	b8 01       	movw	r22, r16
 810:	11 0f       	add	r17, r17
 812:	88 0b       	sbc	r24, r24
 814:	99 0b       	sbc	r25, r25
 816:	e2 d1       	rcall	.+964    	; 0xbdc <__floatsisf>
 818:	a7 01       	movw	r20, r14
 81a:	96 01       	movw	r18, r12
 81c:	f1 d0       	rcall	.+482    	; 0xa00 <atan2>
 81e:	20 e0       	ldi	r18, 0x00	; 0
 820:	30 e0       	ldi	r19, 0x00	; 0
 822:	44 e3       	ldi	r20, 0x34	; 52
 824:	53 e4       	ldi	r21, 0x43	; 67
 826:	92 d2       	rcall	.+1316   	; 0xd4c <__mulsf3>
 828:	20 ed       	ldi	r18, 0xD0	; 208
 82a:	3f e0       	ldi	r19, 0x0F	; 15
 82c:	49 e4       	ldi	r20, 0x49	; 73
 82e:	50 e4       	ldi	r21, 0x40	; 64
 830:	3a d1       	rcall	.+628    	; 0xaa6 <__divsf3>
 832:	20 e0       	ldi	r18, 0x00	; 0
 834:	30 e0       	ldi	r19, 0x00	; 0
 836:	4a e7       	ldi	r20, 0x7A	; 122
 838:	54 e4       	ldi	r21, 0x44	; 68
 83a:	88 d2       	rcall	.+1296   	; 0xd4c <__mulsf3>
 83c:	20 e0       	ldi	r18, 0x00	; 0
 83e:	30 e0       	ldi	r19, 0x00	; 0
 840:	44 eb       	ldi	r20, 0xB4	; 180
 842:	53 e4       	ldi	r21, 0x43	; 67
 844:	30 d1       	rcall	.+608    	; 0xaa6 <__divsf3>
 846:	20 e0       	ldi	r18, 0x00	; 0
 848:	30 e0       	ldi	r19, 0x00	; 0
 84a:	4a ef       	ldi	r20, 0xFA	; 250
 84c:	53 e4       	ldi	r21, 0x43	; 67
 84e:	65 d0       	rcall	.+202    	; 0x91a <__addsf3>
 850:	92 d1       	rcall	.+804    	; 0xb76 <__fixsfsi>
 852:	6b 01       	movw	r12, r22
 854:	40 91 64 38 	lds	r20, 0x3864	; 0x803864 <previous_distance>
 858:	50 91 65 38 	lds	r21, 0x3865	; 0x803865 <previous_distance+0x1>
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:95
  difference = current_distance - previous_distance;
 85c:	9b 01       	movw	r18, r22
 85e:	24 1b       	sub	r18, r20
 860:	35 0b       	sbc	r19, r21
 862:	80 91 62 38 	lds	r24, 0x3862	; 0x803862 <Lower_Bound>
 866:	90 91 63 38 	lds	r25, 0x3863	; 0x803863 <Lower_Bound+0x1>
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:96
  if (current_distance < Lower_Bound)
 86a:	c8 16       	cp	r12, r24
 86c:	d9 06       	cpc	r13, r25
 86e:	24 f4       	brge	.+8      	; 0x878 <__DATA_REGION_LENGTH__+0x78>
 870:	c0 92 62 38 	sts	0x3862, r12	; 0x803862 <Lower_Bound>
 874:	d0 92 63 38 	sts	0x3863, r13	; 0x803863 <Lower_Bound+0x1>
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:98
  {
    Lower_Bound = current_distance;
 878:	80 91 60 38 	lds	r24, 0x3860	; 0x803860 <absolute_distance>
 87c:	90 91 61 38 	lds	r25, 0x3861	; 0x803861 <absolute_distance+0x1>
 880:	b9 01       	movw	r22, r18
 882:	37 ff       	sbrs	r19, 7
 884:	04 c0       	rjmp	.+8      	; 0x88e <__DATA_REGION_LENGTH__+0x8e>
 886:	66 27       	eor	r22, r22
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:102
  }

  // Detect if distance changes abruptly. means a switch has happened
  if (abs(difference) > Switch_Bound)
 888:	77 27       	eor	r23, r23
 88a:	62 1b       	sub	r22, r18
 88c:	73 0b       	sbc	r23, r19
 88e:	65 3f       	cpi	r22, 0xF5	; 245
 890:	71 40       	sbci	r23, 0x01	; 1
 892:	74 f0       	brlt	.+28     	; 0x8b0 <__DATA_REGION_LENGTH__+0xb0>
 894:	60 91 62 38 	lds	r22, 0x3862	; 0x803862 <Lower_Bound>
 898:	70 91 63 38 	lds	r23, 0x3863	; 0x803863 <Lower_Bound+0x1>
 89c:	37 ff       	sbrs	r19, 7
 89e:	0f c0       	rjmp	.+30     	; 0x8be <__DATA_REGION_LENGTH__+0xbe>
 8a0:	9e 01       	movw	r18, r28
 8a2:	24 1b       	sub	r18, r20
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:105
  {
      // Moving Up
      if (difference < 0)
 8a4:	35 0b       	sbc	r19, r21
 8a6:	a6 01       	movw	r20, r12
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:107
      {
        absolute_distance += ((Upper_Bound - previous_distance) + (current_distance - Lower_Bound));
 8a8:	46 1b       	sub	r20, r22
 8aa:	57 0b       	sbc	r21, r23
 8ac:	24 0f       	add	r18, r20
 8ae:	35 1f       	adc	r19, r21
 8b0:	82 0f       	add	r24, r18
 8b2:	93 1f       	adc	r25, r19
 8b4:	0d c0       	rjmp	.+26     	; 0x8d0 <__DATA_REGION_LENGTH__+0xd0>
TWI0_ClearPins():
 8b6:	83 e0       	ldi	r24, 0x03	; 3
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:117
        absolute_distance -= ((current_distance - Upper_Bound) + (previous_distance - Lower_Bound));
      }
  }
  else
  {
    absolute_distance += difference;
 8b8:	80 93 26 04 	sts	0x0426, r24	; 0x800426 <digital_pin_to_bit_mask+0x7f75b6>
 8bc:	de ce       	rjmp	.-580    	; 0x67a <main+0x76>
loop():
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/twi_pins.c:145
        } else {
          PORTB.OUTCLR = 0x03;  // else PB0, PB1
 8be:	46 1b       	sub	r20, r22
 8c0:	57 0b       	sbc	r21, r23
 8c2:	96 01       	movw	r18, r12
 8c4:	28 5e       	subi	r18, 0xE8	; 232
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:112
        absolute_distance += ((Upper_Bound - previous_distance) + (current_distance - Lower_Bound));
      }
     // Moving Down
      else
      {
        absolute_distance -= ((current_distance - Upper_Bound) + (previous_distance - Lower_Bound));
 8c6:	33 40       	sbci	r19, 0x03	; 3
 8c8:	24 0f       	add	r18, r20
 8ca:	35 1f       	adc	r19, r21
 8cc:	82 1b       	sub	r24, r18
 8ce:	93 0b       	sbc	r25, r19
 8d0:	80 93 60 38 	sts	0x3860, r24	; 0x803860 <absolute_distance>
 8d4:	90 93 61 38 	sts	0x3861, r25	; 0x803861 <absolute_distance+0x1>
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:117
      }
  }
  else
  {
    absolute_distance += difference;
 8d8:	c0 92 64 38 	sts	0x3864, r12	; 0x803864 <previous_distance>
 8dc:	d0 92 65 38 	sts	0x3865, r13	; 0x803865 <previous_distance+0x1>
_delay_us():
C:\Users\taimu\OneDrive\Desktop\LE Programmer\LE_Final/LE_Final.ino:120
  }

  previous_distance = current_distance;
 8e0:	83 ef       	ldi	r24, 0xF3	; 243
 8e2:	91 e0       	ldi	r25, 0x01	; 1
 8e4:	01 97       	sbiw	r24, 0x01	; 1
 8e6:	f1 f7       	brne	.-4      	; 0x8e4 <__DATA_REGION_LENGTH__+0xe4>
c:\users\taimu\appdata\local\arduino15\packages\dxcore\tools\avr-gcc\7.3.0-atmel3.6.1-azduino7b1\avr\include\util/delay.h:276
 8e8:	00 c0       	rjmp	.+0      	; 0x8ea <__DATA_REGION_LENGTH__+0xea>
 8ea:	00 00       	nop
 8ec:	3e cf       	rjmp	.-388    	; 0x76a <main+0x166>

000008ee <_GLOBAL__sub_I__ZN7TwoWireC2EP10TWI_struct>:
_ZN5PrintC2Ev():
 8ee:	eb e0       	ldi	r30, 0x0B	; 11
 8f0:	f8 e3       	ldi	r31, 0x38	; 56
 8f2:	12 82       	std	Z+2, r1	; 0x02
 8f4:	13 82       	std	Z+3, r1	; 0x03
_ZN6StreamC2Ev():
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/api/Print.h:42
  protected:
    void setWriteError(int err = 1) {
      write_error = err;
    }
  public:
    Print() : write_error(0) {}
 8f6:	88 ee       	ldi	r24, 0xE8	; 232
 8f8:	93 e0       	ldi	r25, 0x03	; 3
 8fa:	a0 e0       	ldi	r26, 0x00	; 0
 8fc:	b0 e0       	ldi	r27, 0x00	; 0
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/api/Stream.h:63
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {
      _timeout = 1000;
 8fe:	84 83       	std	Z+4, r24	; 0x04
 900:	95 83       	std	Z+5, r25	; 0x05
 902:	a6 83       	std	Z+6, r26	; 0x06
 904:	b7 83       	std	Z+7, r27	; 0x07
_GLOBAL__sub_I__ZN7TwoWireC2EP10TWI_struct():
 906:	8c e2       	ldi	r24, 0x2C	; 44
 908:	9e e8       	ldi	r25, 0x8E	; 142
 90a:	80 83       	st	Z, r24
 90c:	91 83       	std	Z+1, r25	; 0x01
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:52
 *
 *@param      TWI_t *module - the pointer to the TWI module that the Wire object is supposed to use
 *
 *@return     constructor can't return anything
 */
TwoWire::TwoWire(TWI_t *twi_module) {
 90e:	80 e1       	ldi	r24, 0x10	; 16
 910:	98 e0       	ldi	r25, 0x08	; 8
 912:	80 87       	std	Z+8, r24	; 0x08
 914:	91 87       	std	Z+9, r25	; 0x09
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:53
  vars._module = twi_module;
 916:	08 95       	ret

00000918 <__subsf3>:
__subsf3():
 918:	50 58       	subi	r21, 0x80	; 128

0000091a <__addsf3>:
 91a:	bb 27       	eor	r27, r27
 91c:	aa 27       	eor	r26, r26
C:\Users\taimu\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\libraries\Wire\src/Wire.cpp:998
 *  Wire object constructors with the default TWI modules.
 *  If there is absolutely no way to swap the pins physically,
 *  here is the best way to do so in software.
 */
#if defined(TWI0)
  TwoWire Wire(&TWI0);
 91e:	0e d0       	rcall	.+28     	; 0x93c <__addsf3x>
 920:	d4 c1       	rjmp	.+936    	; 0xcca <__fp_round>
__addsf3():
 922:	c5 d1       	rcall	.+906    	; 0xcae <__fp_pscA>
 924:	30 f0       	brcs	.+12     	; 0x932 <__addsf3+0x18>
 926:	ca d1       	rcall	.+916    	; 0xcbc <__fp_pscB>
 928:	20 f0       	brcs	.+8      	; 0x932 <__addsf3+0x18>
 92a:	31 f4       	brne	.+12     	; 0x938 <__addsf3+0x1e>
 92c:	9f 3f       	cpi	r25, 0xFF	; 255
 92e:	11 f4       	brne	.+4      	; 0x934 <__addsf3+0x1a>
 930:	1e f4       	brtc	.+6      	; 0x938 <__addsf3+0x1e>
 932:	95 c1       	rjmp	.+810    	; 0xc5e <__fp_nan>
 934:	0e f4       	brtc	.+2      	; 0x938 <__addsf3+0x1e>
 936:	e0 95       	com	r30
 938:	e7 fb       	bst	r30, 7
 93a:	8b c1       	rjmp	.+790    	; 0xc52 <__fp_inf>

0000093c <__addsf3x>:
__addsf3x():
 93c:	e9 2f       	mov	r30, r25
 93e:	d6 d1       	rcall	.+940    	; 0xcec <__fp_split3>
 940:	80 f3       	brcs	.-32     	; 0x922 <__addsf3+0x8>
 942:	ba 17       	cp	r27, r26
 944:	62 07       	cpc	r22, r18
 946:	73 07       	cpc	r23, r19
 948:	84 07       	cpc	r24, r20
 94a:	95 07       	cpc	r25, r21
 94c:	18 f0       	brcs	.+6      	; 0x954 <__addsf3x+0x18>
 94e:	71 f4       	brne	.+28     	; 0x96c <__addsf3x+0x30>
 950:	9e f5       	brtc	.+102    	; 0x9b8 <__addsf3x+0x7c>
 952:	ee c1       	rjmp	.+988    	; 0xd30 <__fp_zero>
 954:	0e f4       	brtc	.+2      	; 0x958 <__addsf3x+0x1c>
 956:	e0 95       	com	r30
 958:	0b 2e       	mov	r0, r27
 95a:	ba 2f       	mov	r27, r26
 95c:	a0 2d       	mov	r26, r0
 95e:	0b 01       	movw	r0, r22
 960:	b9 01       	movw	r22, r18
 962:	90 01       	movw	r18, r0
 964:	0c 01       	movw	r0, r24
 966:	ca 01       	movw	r24, r20
 968:	a0 01       	movw	r20, r0
 96a:	11 24       	eor	r1, r1
 96c:	ff 27       	eor	r31, r31
 96e:	59 1b       	sub	r21, r25
 970:	99 f0       	breq	.+38     	; 0x998 <__addsf3x+0x5c>
 972:	59 3f       	cpi	r21, 0xF9	; 249
 974:	50 f4       	brcc	.+20     	; 0x98a <__addsf3x+0x4e>
 976:	50 3e       	cpi	r21, 0xE0	; 224
 978:	68 f1       	brcs	.+90     	; 0x9d4 <__addsf3x+0x98>
 97a:	1a 16       	cp	r1, r26
 97c:	f0 40       	sbci	r31, 0x00	; 0
 97e:	a2 2f       	mov	r26, r18
 980:	23 2f       	mov	r18, r19
 982:	34 2f       	mov	r19, r20
 984:	44 27       	eor	r20, r20
 986:	58 5f       	subi	r21, 0xF8	; 248
 988:	f3 cf       	rjmp	.-26     	; 0x970 <__addsf3x+0x34>
 98a:	46 95       	lsr	r20
 98c:	37 95       	ror	r19
 98e:	27 95       	ror	r18
 990:	a7 95       	ror	r26
 992:	f0 40       	sbci	r31, 0x00	; 0
 994:	53 95       	inc	r21
 996:	c9 f7       	brne	.-14     	; 0x98a <__addsf3x+0x4e>
 998:	7e f4       	brtc	.+30     	; 0x9b8 <__addsf3x+0x7c>
 99a:	1f 16       	cp	r1, r31
 99c:	ba 0b       	sbc	r27, r26
 99e:	62 0b       	sbc	r22, r18
 9a0:	73 0b       	sbc	r23, r19
 9a2:	84 0b       	sbc	r24, r20
 9a4:	ba f0       	brmi	.+46     	; 0x9d4 <__addsf3x+0x98>
 9a6:	91 50       	subi	r25, 0x01	; 1
 9a8:	a1 f0       	breq	.+40     	; 0x9d2 <__addsf3x+0x96>
 9aa:	ff 0f       	add	r31, r31
 9ac:	bb 1f       	adc	r27, r27
 9ae:	66 1f       	adc	r22, r22
 9b0:	77 1f       	adc	r23, r23
 9b2:	88 1f       	adc	r24, r24
 9b4:	c2 f7       	brpl	.-16     	; 0x9a6 <__addsf3x+0x6a>
 9b6:	0e c0       	rjmp	.+28     	; 0x9d4 <__addsf3x+0x98>
 9b8:	ba 0f       	add	r27, r26
 9ba:	62 1f       	adc	r22, r18
 9bc:	73 1f       	adc	r23, r19
 9be:	84 1f       	adc	r24, r20
 9c0:	48 f4       	brcc	.+18     	; 0x9d4 <__addsf3x+0x98>
 9c2:	87 95       	ror	r24
 9c4:	77 95       	ror	r23
 9c6:	67 95       	ror	r22
 9c8:	b7 95       	ror	r27
 9ca:	f7 95       	ror	r31
 9cc:	9e 3f       	cpi	r25, 0xFE	; 254
 9ce:	08 f0       	brcs	.+2      	; 0x9d2 <__addsf3x+0x96>
 9d0:	b3 cf       	rjmp	.-154    	; 0x938 <__addsf3+0x1e>
 9d2:	93 95       	inc	r25
 9d4:	88 0f       	add	r24, r24
 9d6:	08 f0       	brcs	.+2      	; 0x9da <__addsf3x+0x9e>
 9d8:	99 27       	eor	r25, r25
 9da:	ee 0f       	add	r30, r30
 9dc:	97 95       	ror	r25
 9de:	87 95       	ror	r24
 9e0:	08 95       	ret
 9e2:	65 d1       	rcall	.+714    	; 0xcae <__fp_pscA>
 9e4:	58 f0       	brcs	.+22     	; 0x9fc <__addsf3x+0xc0>
 9e6:	80 e8       	ldi	r24, 0x80	; 128
 9e8:	91 e0       	ldi	r25, 0x01	; 1
 9ea:	09 f4       	brne	.+2      	; 0x9ee <__addsf3x+0xb2>
 9ec:	9e ef       	ldi	r25, 0xFE	; 254
 9ee:	66 d1       	rcall	.+716    	; 0xcbc <__fp_pscB>
 9f0:	28 f0       	brcs	.+10     	; 0x9fc <__addsf3x+0xc0>
 9f2:	40 e8       	ldi	r20, 0x80	; 128
 9f4:	51 e0       	ldi	r21, 0x01	; 1
 9f6:	59 f4       	brne	.+22     	; 0xa0e <atan2+0xe>
 9f8:	5e ef       	ldi	r21, 0xFE	; 254
 9fa:	09 c0       	rjmp	.+18     	; 0xa0e <atan2+0xe>
 9fc:	30 c1       	rjmp	.+608    	; 0xc5e <__fp_nan>
 9fe:	98 c1       	rjmp	.+816    	; 0xd30 <__fp_zero>

00000a00 <atan2>:
 a00:	e9 2f       	mov	r30, r25
 a02:	e0 78       	andi	r30, 0x80	; 128
 a04:	73 d1       	rcall	.+742    	; 0xcec <__fp_split3>
 a06:	68 f3       	brcs	.-38     	; 0x9e2 <__addsf3x+0xa6>
atan2():
 a08:	09 2e       	mov	r0, r25
 a0a:	05 2a       	or	r0, r21
 a0c:	c1 f3       	breq	.-16     	; 0x9fe <__addsf3x+0xc2>
 a0e:	26 17       	cp	r18, r22
 a10:	37 07       	cpc	r19, r23
 a12:	48 07       	cpc	r20, r24
 a14:	59 07       	cpc	r21, r25
 a16:	38 f0       	brcs	.+14     	; 0xa26 <atan2+0x26>
 a18:	0e 2e       	mov	r0, r30
 a1a:	07 f8       	bld	r0, 7
 a1c:	e0 25       	eor	r30, r0
 a1e:	69 f0       	breq	.+26     	; 0xa3a <atan2+0x3a>
 a20:	e0 25       	eor	r30, r0
 a22:	e0 64       	ori	r30, 0x40	; 64
 a24:	0a c0       	rjmp	.+20     	; 0xa3a <atan2+0x3a>
 a26:	ef 63       	ori	r30, 0x3F	; 63
 a28:	07 f8       	bld	r0, 7
 a2a:	00 94       	com	r0
 a2c:	07 fa       	bst	r0, 7
 a2e:	db 01       	movw	r26, r22
 a30:	b9 01       	movw	r22, r18
 a32:	9d 01       	movw	r18, r26
 a34:	dc 01       	movw	r26, r24
 a36:	ca 01       	movw	r24, r20
 a38:	ad 01       	movw	r20, r26
 a3a:	ef 93       	push	r30
 a3c:	43 d0       	rcall	.+134    	; 0xac4 <__divsf3_pse>
 a3e:	45 d1       	rcall	.+650    	; 0xcca <__fp_round>
 a40:	0a d0       	rcall	.+20     	; 0xa56 <atan>
 a42:	5f 91       	pop	r21
 a44:	55 23       	and	r21, r21
 a46:	31 f0       	breq	.+12     	; 0xa54 <atan2+0x54>
 a48:	2b ed       	ldi	r18, 0xDB	; 219
 a4a:	3f e0       	ldi	r19, 0x0F	; 15
 a4c:	49 e4       	ldi	r20, 0x49	; 73
 a4e:	50 fd       	sbrc	r21, 0
 a50:	49 ec       	ldi	r20, 0xC9	; 201
 a52:	63 cf       	rjmp	.-314    	; 0x91a <__addsf3>
 a54:	08 95       	ret

00000a56 <atan>:
 a56:	df 93       	push	r29
 a58:	dd 27       	eor	r29, r29
 a5a:	b9 2f       	mov	r27, r25
 a5c:	bf 77       	andi	r27, 0x7F	; 127
 a5e:	40 e8       	ldi	r20, 0x80	; 128
 a60:	5f e3       	ldi	r21, 0x3F	; 63
 a62:	16 16       	cp	r1, r22
 a64:	17 06       	cpc	r1, r23
 a66:	48 07       	cpc	r20, r24
 a68:	5b 07       	cpc	r21, r27
 a6a:	10 f4       	brcc	.+4      	; 0xa70 <atan+0x1a>
 a6c:	d9 2f       	mov	r29, r25
 a6e:	67 d1       	rcall	.+718    	; 0xd3e <inverse>
 a70:	9f 93       	push	r25
 a72:	8f 93       	push	r24
 a74:	7f 93       	push	r23
 a76:	6f 93       	push	r22
 a78:	cc d1       	rcall	.+920    	; 0xe12 <square>
 a7a:	ec e7       	ldi	r30, 0x7C	; 124
 a7c:	f0 e0       	ldi	r31, 0x00	; 0
 a7e:	f2 d0       	rcall	.+484    	; 0xc64 <__fp_powser>
 a80:	24 d1       	rcall	.+584    	; 0xcca <__fp_round>
 a82:	2f 91       	pop	r18
 a84:	3f 91       	pop	r19
atan():
 a86:	4f 91       	pop	r20
 a88:	5f 91       	pop	r21
 a8a:	6c d1       	rcall	.+728    	; 0xd64 <__mulsf3x>
 a8c:	dd 23       	and	r29, r29
 a8e:	49 f0       	breq	.+18     	; 0xaa2 <atan+0x4c>
 a90:	90 58       	subi	r25, 0x80	; 128
 a92:	a2 ea       	ldi	r26, 0xA2	; 162
 a94:	2a ed       	ldi	r18, 0xDA	; 218
 a96:	3f e0       	ldi	r19, 0x0F	; 15
 a98:	49 ec       	ldi	r20, 0xC9	; 201
 a9a:	5f e3       	ldi	r21, 0x3F	; 63
 a9c:	d0 78       	andi	r29, 0x80	; 128
 a9e:	5d 27       	eor	r21, r29
 aa0:	4d df       	rcall	.-358    	; 0x93c <__addsf3x>
 aa2:	df 91       	pop	r29
 aa4:	12 c1       	rjmp	.+548    	; 0xcca <__fp_round>

00000aa6 <__divsf3>:
__divsf3():
 aa6:	0c d0       	rcall	.+24     	; 0xac0 <__divsf3x>
 aa8:	10 c1       	rjmp	.+544    	; 0xcca <__fp_round>
 aaa:	08 d1       	rcall	.+528    	; 0xcbc <__fp_pscB>
 aac:	40 f0       	brcs	.+16     	; 0xabe <__divsf3+0x18>
 aae:	ff d0       	rcall	.+510    	; 0xcae <__fp_pscA>
 ab0:	30 f0       	brcs	.+12     	; 0xabe <__divsf3+0x18>
 ab2:	21 f4       	brne	.+8      	; 0xabc <__divsf3+0x16>
 ab4:	5f 3f       	cpi	r21, 0xFF	; 255
 ab6:	19 f0       	breq	.+6      	; 0xabe <__divsf3+0x18>
 ab8:	cc c0       	rjmp	.+408    	; 0xc52 <__fp_inf>
 aba:	51 11       	cpse	r21, r1
 abc:	3a c1       	rjmp	.+628    	; 0xd32 <__fp_szero>
 abe:	cf c0       	rjmp	.+414    	; 0xc5e <__fp_nan>

00000ac0 <__divsf3x>:
__divsf3x():
 ac0:	15 d1       	rcall	.+554    	; 0xcec <__fp_split3>
 ac2:	98 f3       	brcs	.-26     	; 0xaaa <__divsf3+0x4>

00000ac4 <__divsf3_pse>:
 ac4:	99 23       	and	r25, r25
 ac6:	c9 f3       	breq	.-14     	; 0xaba <__divsf3+0x14>
 ac8:	55 23       	and	r21, r21
 aca:	b1 f3       	breq	.-20     	; 0xab8 <__divsf3+0x12>
 acc:	95 1b       	sub	r25, r21
 ace:	55 0b       	sbc	r21, r21
 ad0:	bb 27       	eor	r27, r27
 ad2:	aa 27       	eor	r26, r26
 ad4:	62 17       	cp	r22, r18
 ad6:	73 07       	cpc	r23, r19
 ad8:	84 07       	cpc	r24, r20
 ada:	38 f0       	brcs	.+14     	; 0xaea <__divsf3_pse+0x26>
 adc:	9f 5f       	subi	r25, 0xFF	; 255
 ade:	5f 4f       	sbci	r21, 0xFF	; 255
 ae0:	22 0f       	add	r18, r18
 ae2:	33 1f       	adc	r19, r19
 ae4:	44 1f       	adc	r20, r20
 ae6:	aa 1f       	adc	r26, r26
 ae8:	a9 f3       	breq	.-22     	; 0xad4 <__divsf3_pse+0x10>
 aea:	33 d0       	rcall	.+102    	; 0xb52 <__divsf3_pse+0x8e>
 aec:	0e 2e       	mov	r0, r30
 aee:	3a f0       	brmi	.+14     	; 0xafe <__divsf3_pse+0x3a>
 af0:	e0 e8       	ldi	r30, 0x80	; 128
 af2:	30 d0       	rcall	.+96     	; 0xb54 <__divsf3_pse+0x90>
 af4:	91 50       	subi	r25, 0x01	; 1
 af6:	50 40       	sbci	r21, 0x00	; 0
 af8:	e6 95       	lsr	r30
 afa:	00 1c       	adc	r0, r0
 afc:	ca f7       	brpl	.-14     	; 0xaf0 <__divsf3_pse+0x2c>
 afe:	29 d0       	rcall	.+82     	; 0xb52 <__divsf3_pse+0x8e>
 b00:	fe 2f       	mov	r31, r30
 b02:	27 d0       	rcall	.+78     	; 0xb52 <__divsf3_pse+0x8e>
 b04:	66 0f       	add	r22, r22
 b06:	77 1f       	adc	r23, r23
 b08:	88 1f       	adc	r24, r24
 b0a:	bb 1f       	adc	r27, r27
 b0c:	26 17       	cp	r18, r22
 b0e:	37 07       	cpc	r19, r23
 b10:	48 07       	cpc	r20, r24
 b12:	ab 07       	cpc	r26, r27
 b14:	b0 e8       	ldi	r27, 0x80	; 128
 b16:	09 f0       	breq	.+2      	; 0xb1a <__divsf3_pse+0x56>
 b18:	bb 0b       	sbc	r27, r27
 b1a:	80 2d       	mov	r24, r0
 b1c:	bf 01       	movw	r22, r30
 b1e:	ff 27       	eor	r31, r31
 b20:	93 58       	subi	r25, 0x83	; 131
 b22:	5f 4f       	sbci	r21, 0xFF	; 255
 b24:	2a f0       	brmi	.+10     	; 0xb30 <__divsf3_pse+0x6c>
 b26:	9e 3f       	cpi	r25, 0xFE	; 254
 b28:	51 05       	cpc	r21, r1
 b2a:	68 f0       	brcs	.+26     	; 0xb46 <__divsf3_pse+0x82>
 b2c:	92 c0       	rjmp	.+292    	; 0xc52 <__fp_inf>
 b2e:	01 c1       	rjmp	.+514    	; 0xd32 <__fp_szero>
 b30:	5f 3f       	cpi	r21, 0xFF	; 255
 b32:	ec f3       	brlt	.-6      	; 0xb2e <__divsf3_pse+0x6a>
 b34:	98 3e       	cpi	r25, 0xE8	; 232
 b36:	dc f3       	brlt	.-10     	; 0xb2e <__divsf3_pse+0x6a>
 b38:	86 95       	lsr	r24
 b3a:	77 95       	ror	r23
 b3c:	67 95       	ror	r22
 b3e:	b7 95       	ror	r27
 b40:	f7 95       	ror	r31
 b42:	9f 5f       	subi	r25, 0xFF	; 255
 b44:	c9 f7       	brne	.-14     	; 0xb38 <__divsf3_pse+0x74>
 b46:	88 0f       	add	r24, r24
 b48:	91 1d       	adc	r25, r1
 b4a:	96 95       	lsr	r25
 b4c:	87 95       	ror	r24
 b4e:	97 f9       	bld	r25, 7
 b50:	08 95       	ret
 b52:	e1 e0       	ldi	r30, 0x01	; 1
 b54:	66 0f       	add	r22, r22
 b56:	77 1f       	adc	r23, r23
 b58:	88 1f       	adc	r24, r24
 b5a:	bb 1f       	adc	r27, r27
 b5c:	62 17       	cp	r22, r18
 b5e:	73 07       	cpc	r23, r19
 b60:	84 07       	cpc	r24, r20
 b62:	ba 07       	cpc	r27, r26
 b64:	20 f0       	brcs	.+8      	; 0xb6e <__divsf3_pse+0xaa>
 b66:	62 1b       	sub	r22, r18
 b68:	73 0b       	sbc	r23, r19
 b6a:	84 0b       	sbc	r24, r20
 b6c:	ba 0b       	sbc	r27, r26
 b6e:	ee 1f       	adc	r30, r30
 b70:	88 f7       	brcc	.-30     	; 0xb54 <__divsf3_pse+0x90>
 b72:	e0 95       	com	r30
 b74:	08 95       	ret

00000b76 <__fixsfsi>:
 b76:	04 d0       	rcall	.+8      	; 0xb80 <__fixunssfsi>
 b78:	68 94       	set
 b7a:	b1 11       	cpse	r27, r1
 b7c:	da c0       	rjmp	.+436    	; 0xd32 <__fp_szero>
 b7e:	08 95       	ret

00000b80 <__fixunssfsi>:
 b80:	bd d0       	rcall	.+378    	; 0xcfc <__fp_splitA>
 b82:	88 f0       	brcs	.+34     	; 0xba6 <__fixunssfsi+0x26>
 b84:	9f 57       	subi	r25, 0x7F	; 127
 b86:	90 f0       	brcs	.+36     	; 0xbac <__fixunssfsi+0x2c>
 b88:	b9 2f       	mov	r27, r25
 b8a:	99 27       	eor	r25, r25
 b8c:	b7 51       	subi	r27, 0x17	; 23
 b8e:	a0 f0       	brcs	.+40     	; 0xbb8 <__fixunssfsi+0x38>
 b90:	d1 f0       	breq	.+52     	; 0xbc6 <__fixunssfsi+0x46>
 b92:	66 0f       	add	r22, r22
 b94:	77 1f       	adc	r23, r23
 b96:	88 1f       	adc	r24, r24
 b98:	99 1f       	adc	r25, r25
 b9a:	1a f0       	brmi	.+6      	; 0xba2 <__fixunssfsi+0x22>
__fixunssfsi():
 b9c:	ba 95       	dec	r27
 b9e:	c9 f7       	brne	.-14     	; 0xb92 <__fixunssfsi+0x12>
 ba0:	12 c0       	rjmp	.+36     	; 0xbc6 <__fixunssfsi+0x46>
 ba2:	b1 30       	cpi	r27, 0x01	; 1
 ba4:	81 f0       	breq	.+32     	; 0xbc6 <__fixunssfsi+0x46>
 ba6:	c4 d0       	rcall	.+392    	; 0xd30 <__fp_zero>
 ba8:	b1 e0       	ldi	r27, 0x01	; 1
 baa:	08 95       	ret
 bac:	c1 c0       	rjmp	.+386    	; 0xd30 <__fp_zero>
 bae:	67 2f       	mov	r22, r23
 bb0:	78 2f       	mov	r23, r24
 bb2:	88 27       	eor	r24, r24
 bb4:	b8 5f       	subi	r27, 0xF8	; 248
 bb6:	39 f0       	breq	.+14     	; 0xbc6 <__fixunssfsi+0x46>
 bb8:	b9 3f       	cpi	r27, 0xF9	; 249
 bba:	cc f3       	brlt	.-14     	; 0xbae <__fixunssfsi+0x2e>
 bbc:	86 95       	lsr	r24
 bbe:	77 95       	ror	r23
 bc0:	67 95       	ror	r22
 bc2:	b3 95       	inc	r27
 bc4:	d9 f7       	brne	.-10     	; 0xbbc <__fixunssfsi+0x3c>
 bc6:	3e f4       	brtc	.+14     	; 0xbd6 <__fixunssfsi+0x56>
 bc8:	90 95       	com	r25
 bca:	80 95       	com	r24
 bcc:	70 95       	com	r23
 bce:	61 95       	neg	r22
 bd0:	7f 4f       	sbci	r23, 0xFF	; 255
 bd2:	8f 4f       	sbci	r24, 0xFF	; 255
 bd4:	9f 4f       	sbci	r25, 0xFF	; 255
 bd6:	08 95       	ret

00000bd8 <__floatunsisf>:
__floatunsisf():
 bd8:	e8 94       	clt
 bda:	09 c0       	rjmp	.+18     	; 0xbee <__floatsisf+0x12>

00000bdc <__floatsisf>:
 bdc:	97 fb       	bst	r25, 7
 bde:	3e f4       	brtc	.+14     	; 0xbee <__floatsisf+0x12>
 be0:	90 95       	com	r25
 be2:	80 95       	com	r24
 be4:	70 95       	com	r23
 be6:	61 95       	neg	r22
 be8:	7f 4f       	sbci	r23, 0xFF	; 255
 bea:	8f 4f       	sbci	r24, 0xFF	; 255
 bec:	9f 4f       	sbci	r25, 0xFF	; 255
 bee:	99 23       	and	r25, r25
 bf0:	a9 f0       	breq	.+42     	; 0xc1c <__floatsisf+0x40>
 bf2:	f9 2f       	mov	r31, r25
 bf4:	96 e9       	ldi	r25, 0x96	; 150
 bf6:	bb 27       	eor	r27, r27
 bf8:	93 95       	inc	r25
 bfa:	f6 95       	lsr	r31
 bfc:	87 95       	ror	r24
 bfe:	77 95       	ror	r23
 c00:	67 95       	ror	r22
 c02:	b7 95       	ror	r27
 c04:	f1 11       	cpse	r31, r1
 c06:	f8 cf       	rjmp	.-16     	; 0xbf8 <__floatsisf+0x1c>
 c08:	fa f4       	brpl	.+62     	; 0xc48 <__floatsisf+0x6c>
 c0a:	bb 0f       	add	r27, r27
 c0c:	11 f4       	brne	.+4      	; 0xc12 <__floatsisf+0x36>
 c0e:	60 ff       	sbrs	r22, 0
 c10:	1b c0       	rjmp	.+54     	; 0xc48 <__floatsisf+0x6c>
 c12:	6f 5f       	subi	r22, 0xFF	; 255
 c14:	7f 4f       	sbci	r23, 0xFF	; 255
 c16:	8f 4f       	sbci	r24, 0xFF	; 255
 c18:	9f 4f       	sbci	r25, 0xFF	; 255
 c1a:	16 c0       	rjmp	.+44     	; 0xc48 <__floatsisf+0x6c>
 c1c:	88 23       	and	r24, r24
 c1e:	11 f0       	breq	.+4      	; 0xc24 <__floatsisf+0x48>
 c20:	96 e9       	ldi	r25, 0x96	; 150
 c22:	11 c0       	rjmp	.+34     	; 0xc46 <__floatsisf+0x6a>
 c24:	77 23       	and	r23, r23
 c26:	21 f0       	breq	.+8      	; 0xc30 <__floatsisf+0x54>
 c28:	9e e8       	ldi	r25, 0x8E	; 142
 c2a:	87 2f       	mov	r24, r23
 c2c:	76 2f       	mov	r23, r22
 c2e:	05 c0       	rjmp	.+10     	; 0xc3a <__floatsisf+0x5e>
 c30:	66 23       	and	r22, r22
 c32:	71 f0       	breq	.+28     	; 0xc50 <__floatsisf+0x74>
 c34:	96 e8       	ldi	r25, 0x86	; 134
 c36:	86 2f       	mov	r24, r22
 c38:	70 e0       	ldi	r23, 0x00	; 0
 c3a:	60 e0       	ldi	r22, 0x00	; 0
 c3c:	2a f0       	brmi	.+10     	; 0xc48 <__floatsisf+0x6c>
 c3e:	9a 95       	dec	r25
 c40:	66 0f       	add	r22, r22
 c42:	77 1f       	adc	r23, r23
 c44:	88 1f       	adc	r24, r24
 c46:	da f7       	brpl	.-10     	; 0xc3e <__floatsisf+0x62>
 c48:	88 0f       	add	r24, r24
 c4a:	96 95       	lsr	r25
 c4c:	87 95       	ror	r24
 c4e:	97 f9       	bld	r25, 7
 c50:	08 95       	ret

00000c52 <__fp_inf>:
__fp_inf():
 c52:	97 f9       	bld	r25, 7
 c54:	9f 67       	ori	r25, 0x7F	; 127
 c56:	80 e8       	ldi	r24, 0x80	; 128
 c58:	70 e0       	ldi	r23, 0x00	; 0
 c5a:	60 e0       	ldi	r22, 0x00	; 0
 c5c:	08 95       	ret

00000c5e <__fp_nan>:
__fp_nan():
 c5e:	9f ef       	ldi	r25, 0xFF	; 255
 c60:	80 ec       	ldi	r24, 0xC0	; 192
 c62:	08 95       	ret

00000c64 <__fp_powser>:
__fp_powser():
 c64:	df 93       	push	r29
 c66:	cf 93       	push	r28
 c68:	1f 93       	push	r17
 c6a:	0f 93       	push	r16
 c6c:	ff 92       	push	r15
 c6e:	ef 92       	push	r14
 c70:	df 92       	push	r13
 c72:	7b 01       	movw	r14, r22
 c74:	8c 01       	movw	r16, r24
 c76:	68 94       	set
 c78:	05 c0       	rjmp	.+10     	; 0xc84 <__fp_powser+0x20>
 c7a:	da 2e       	mov	r13, r26
 c7c:	ef 01       	movw	r28, r30
 c7e:	72 d0       	rcall	.+228    	; 0xd64 <__mulsf3x>
 c80:	fe 01       	movw	r30, r28
 c82:	e8 94       	clt
 c84:	a5 91       	lpm	r26, Z+
 c86:	25 91       	lpm	r18, Z+
 c88:	35 91       	lpm	r19, Z+
 c8a:	45 91       	lpm	r20, Z+
 c8c:	55 91       	lpm	r21, Z+
 c8e:	ae f3       	brts	.-22     	; 0xc7a <__fp_powser+0x16>
 c90:	ef 01       	movw	r28, r30
 c92:	54 de       	rcall	.-856    	; 0x93c <__addsf3x>
 c94:	fe 01       	movw	r30, r28
 c96:	97 01       	movw	r18, r14
 c98:	a8 01       	movw	r20, r16
 c9a:	da 94       	dec	r13
 c9c:	79 f7       	brne	.-34     	; 0xc7c <__fp_powser+0x18>
 c9e:	df 90       	pop	r13
 ca0:	ef 90       	pop	r14
 ca2:	ff 90       	pop	r15
 ca4:	0f 91       	pop	r16
 ca6:	1f 91       	pop	r17
 ca8:	cf 91       	pop	r28
 caa:	df 91       	pop	r29
 cac:	08 95       	ret

00000cae <__fp_pscA>:
__fp_pscA():
 cae:	00 24       	eor	r0, r0
 cb0:	0a 94       	dec	r0
 cb2:	16 16       	cp	r1, r22
 cb4:	17 06       	cpc	r1, r23
 cb6:	18 06       	cpc	r1, r24
 cb8:	09 06       	cpc	r0, r25
 cba:	08 95       	ret

00000cbc <__fp_pscB>:
__fp_pscB():
 cbc:	00 24       	eor	r0, r0
 cbe:	0a 94       	dec	r0
 cc0:	12 16       	cp	r1, r18
 cc2:	13 06       	cpc	r1, r19
 cc4:	14 06       	cpc	r1, r20
 cc6:	05 06       	cpc	r0, r21
 cc8:	08 95       	ret

00000cca <__fp_round>:
__fp_round():
 cca:	09 2e       	mov	r0, r25
 ccc:	03 94       	inc	r0
 cce:	00 0c       	add	r0, r0
 cd0:	11 f4       	brne	.+4      	; 0xcd6 <__fp_round+0xc>
 cd2:	88 23       	and	r24, r24
 cd4:	52 f0       	brmi	.+20     	; 0xcea <__fp_round+0x20>
 cd6:	bb 0f       	add	r27, r27
 cd8:	40 f4       	brcc	.+16     	; 0xcea <__fp_round+0x20>
 cda:	bf 2b       	or	r27, r31
 cdc:	11 f4       	brne	.+4      	; 0xce2 <__fp_round+0x18>
 cde:	60 ff       	sbrs	r22, 0
 ce0:	04 c0       	rjmp	.+8      	; 0xcea <__fp_round+0x20>
 ce2:	6f 5f       	subi	r22, 0xFF	; 255
 ce4:	7f 4f       	sbci	r23, 0xFF	; 255
 ce6:	8f 4f       	sbci	r24, 0xFF	; 255
 ce8:	9f 4f       	sbci	r25, 0xFF	; 255
 cea:	08 95       	ret

00000cec <__fp_split3>:
__fp_split3():
 cec:	57 fd       	sbrc	r21, 7
 cee:	90 58       	subi	r25, 0x80	; 128
 cf0:	44 0f       	add	r20, r20
 cf2:	55 1f       	adc	r21, r21
 cf4:	59 f0       	breq	.+22     	; 0xd0c <__fp_splitA+0x10>
 cf6:	5f 3f       	cpi	r21, 0xFF	; 255
 cf8:	71 f0       	breq	.+28     	; 0xd16 <__fp_splitA+0x1a>
 cfa:	47 95       	ror	r20

00000cfc <__fp_splitA>:
 cfc:	88 0f       	add	r24, r24
 cfe:	97 fb       	bst	r25, 7
 d00:	99 1f       	adc	r25, r25
 d02:	61 f0       	breq	.+24     	; 0xd1c <__fp_splitA+0x20>
 d04:	9f 3f       	cpi	r25, 0xFF	; 255
 d06:	79 f0       	breq	.+30     	; 0xd26 <__fp_splitA+0x2a>
 d08:	87 95       	ror	r24
 d0a:	08 95       	ret
 d0c:	12 16       	cp	r1, r18
 d0e:	13 06       	cpc	r1, r19
 d10:	14 06       	cpc	r1, r20
 d12:	55 1f       	adc	r21, r21
 d14:	f2 cf       	rjmp	.-28     	; 0xcfa <__fp_split3+0xe>
 d16:	46 95       	lsr	r20
 d18:	f1 df       	rcall	.-30     	; 0xcfc <__fp_splitA>
 d1a:	08 c0       	rjmp	.+16     	; 0xd2c <__fp_splitA+0x30>
 d1c:	16 16       	cp	r1, r22
 d1e:	17 06       	cpc	r1, r23
 d20:	18 06       	cpc	r1, r24
 d22:	99 1f       	adc	r25, r25
 d24:	f1 cf       	rjmp	.-30     	; 0xd08 <__fp_splitA+0xc>
 d26:	86 95       	lsr	r24
 d28:	71 05       	cpc	r23, r1
 d2a:	61 05       	cpc	r22, r1
 d2c:	08 94       	sec
 d2e:	08 95       	ret

00000d30 <__fp_zero>:
__fp_zero():
 d30:	e8 94       	clt

00000d32 <__fp_szero>:
 d32:	bb 27       	eor	r27, r27
 d34:	66 27       	eor	r22, r22
 d36:	77 27       	eor	r23, r23
 d38:	cb 01       	movw	r24, r22
 d3a:	97 f9       	bld	r25, 7
 d3c:	08 95       	ret

00000d3e <inverse>:
inverse():
 d3e:	9b 01       	movw	r18, r22
 d40:	ac 01       	movw	r20, r24
 d42:	60 e0       	ldi	r22, 0x00	; 0
 d44:	70 e0       	ldi	r23, 0x00	; 0
 d46:	80 e8       	ldi	r24, 0x80	; 128
 d48:	9f e3       	ldi	r25, 0x3F	; 63
 d4a:	ad ce       	rjmp	.-678    	; 0xaa6 <__divsf3>

00000d4c <__mulsf3>:
__mulsf3():
 d4c:	0b d0       	rcall	.+22     	; 0xd64 <__mulsf3x>
 d4e:	bd cf       	rjmp	.-134    	; 0xcca <__fp_round>
 d50:	ae df       	rcall	.-164    	; 0xcae <__fp_pscA>
 d52:	28 f0       	brcs	.+10     	; 0xd5e <__mulsf3+0x12>
 d54:	b3 df       	rcall	.-154    	; 0xcbc <__fp_pscB>
 d56:	18 f0       	brcs	.+6      	; 0xd5e <__mulsf3+0x12>
 d58:	95 23       	and	r25, r21
 d5a:	09 f0       	breq	.+2      	; 0xd5e <__mulsf3+0x12>
 d5c:	7a cf       	rjmp	.-268    	; 0xc52 <__fp_inf>
 d5e:	7f cf       	rjmp	.-258    	; 0xc5e <__fp_nan>
 d60:	11 24       	eor	r1, r1
 d62:	e7 cf       	rjmp	.-50     	; 0xd32 <__fp_szero>

00000d64 <__mulsf3x>:
__mulsf3x():
 d64:	c3 df       	rcall	.-122    	; 0xcec <__fp_split3>
 d66:	a0 f3       	brcs	.-24     	; 0xd50 <__mulsf3+0x4>

00000d68 <__mulsf3_pse>:
 d68:	95 9f       	mul	r25, r21
 d6a:	d1 f3       	breq	.-12     	; 0xd60 <__mulsf3+0x14>
 d6c:	95 0f       	add	r25, r21
 d6e:	50 e0       	ldi	r21, 0x00	; 0
 d70:	55 1f       	adc	r21, r21
 d72:	62 9f       	mul	r22, r18
 d74:	f0 01       	movw	r30, r0
 d76:	72 9f       	mul	r23, r18
 d78:	bb 27       	eor	r27, r27
 d7a:	f0 0d       	add	r31, r0
 d7c:	b1 1d       	adc	r27, r1
 d7e:	63 9f       	mul	r22, r19
 d80:	aa 27       	eor	r26, r26
 d82:	f0 0d       	add	r31, r0
 d84:	b1 1d       	adc	r27, r1
 d86:	aa 1f       	adc	r26, r26
 d88:	64 9f       	mul	r22, r20
 d8a:	66 27       	eor	r22, r22
 d8c:	b0 0d       	add	r27, r0
 d8e:	a1 1d       	adc	r26, r1
 d90:	66 1f       	adc	r22, r22
 d92:	82 9f       	mul	r24, r18
 d94:	22 27       	eor	r18, r18
 d96:	b0 0d       	add	r27, r0
 d98:	a1 1d       	adc	r26, r1
 d9a:	62 1f       	adc	r22, r18
 d9c:	73 9f       	mul	r23, r19
 d9e:	b0 0d       	add	r27, r0
 da0:	a1 1d       	adc	r26, r1
 da2:	62 1f       	adc	r22, r18
 da4:	83 9f       	mul	r24, r19
 da6:	a0 0d       	add	r26, r0
 da8:	61 1d       	adc	r22, r1
 daa:	22 1f       	adc	r18, r18
 dac:	74 9f       	mul	r23, r20
 dae:	33 27       	eor	r19, r19
 db0:	a0 0d       	add	r26, r0
 db2:	61 1d       	adc	r22, r1
 db4:	23 1f       	adc	r18, r19
 db6:	84 9f       	mul	r24, r20
 db8:	60 0d       	add	r22, r0
 dba:	21 1d       	adc	r18, r1
 dbc:	82 2f       	mov	r24, r18
 dbe:	76 2f       	mov	r23, r22
 dc0:	6a 2f       	mov	r22, r26
 dc2:	11 24       	eor	r1, r1
 dc4:	9f 57       	subi	r25, 0x7F	; 127
 dc6:	50 40       	sbci	r21, 0x00	; 0
 dc8:	8a f0       	brmi	.+34     	; 0xdec <__mulsf3_pse+0x84>
 dca:	e1 f0       	breq	.+56     	; 0xe04 <__mulsf3_pse+0x9c>
 dcc:	88 23       	and	r24, r24
 dce:	4a f0       	brmi	.+18     	; 0xde2 <__mulsf3_pse+0x7a>
 dd0:	ee 0f       	add	r30, r30
 dd2:	ff 1f       	adc	r31, r31
 dd4:	bb 1f       	adc	r27, r27
 dd6:	66 1f       	adc	r22, r22
 dd8:	77 1f       	adc	r23, r23
 dda:	88 1f       	adc	r24, r24
 ddc:	91 50       	subi	r25, 0x01	; 1
 dde:	50 40       	sbci	r21, 0x00	; 0
 de0:	a9 f7       	brne	.-22     	; 0xdcc <__mulsf3_pse+0x64>
 de2:	9e 3f       	cpi	r25, 0xFE	; 254
 de4:	51 05       	cpc	r21, r1
 de6:	70 f0       	brcs	.+28     	; 0xe04 <__mulsf3_pse+0x9c>
 de8:	34 cf       	rjmp	.-408    	; 0xc52 <__fp_inf>
 dea:	a3 cf       	rjmp	.-186    	; 0xd32 <__fp_szero>
 dec:	5f 3f       	cpi	r21, 0xFF	; 255
 dee:	ec f3       	brlt	.-6      	; 0xdea <__mulsf3_pse+0x82>
 df0:	98 3e       	cpi	r25, 0xE8	; 232
 df2:	dc f3       	brlt	.-10     	; 0xdea <__mulsf3_pse+0x82>
 df4:	86 95       	lsr	r24
 df6:	77 95       	ror	r23
 df8:	67 95       	ror	r22
 dfa:	b7 95       	ror	r27
 dfc:	f7 95       	ror	r31
 dfe:	e7 95       	ror	r30
 e00:	9f 5f       	subi	r25, 0xFF	; 255
 e02:	c1 f7       	brne	.-16     	; 0xdf4 <__mulsf3_pse+0x8c>
 e04:	fe 2b       	or	r31, r30
 e06:	88 0f       	add	r24, r24
 e08:	91 1d       	adc	r25, r1
 e0a:	96 95       	lsr	r25
 e0c:	87 95       	ror	r24
 e0e:	97 f9       	bld	r25, 7
 e10:	08 95       	ret

00000e12 <square>:
 e12:	9b 01       	movw	r18, r22
 e14:	ac 01       	movw	r20, r24
 e16:	9a cf       	rjmp	.-204    	; 0xd4c <__mulsf3>

00000e18 <__tablejump2__>:
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2296
 e18:	ee 0f       	add	r30, r30
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2297
 e1a:	ff 1f       	adc	r31, r31
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2328
 e1c:	05 90       	lpm	r0, Z+
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2329
 e1e:	f4 91       	lpm	r31, Z
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2330
 e20:	e0 2d       	mov	r30, r0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2331
 e22:	09 94       	ijmp

00000e24 <_exit>:
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
 e24:	f8 94       	cli

00000e26 <__stop_program>:
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
 e26:	ff cf       	rjmp	.-2      	; 0xe26 <__stop_program>
